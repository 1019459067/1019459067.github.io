<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CocoaPods私有库</title>
      <link href="/2019/08/09/CocoaPods%E7%A7%81%E6%9C%89%E5%BA%93/"/>
      <url>/2019/08/09/CocoaPods%E7%A7%81%E6%9C%89%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>最近因为工程的复杂度不断加深，各个功能模块间的解耦显得尤为重要，模块化开发应运而生，而对CocoaPods使用的熟练程度就显得尤为重要。</p><p>此前也研究过<a href="https://1019459067.github.io/" target="_blank" rel="noopener">上传Github的代码添加Cocoapods支持</a>，这篇文章主要研究公共库的Cocoapods支持。</p><p>此文主要是写一下私有库的主要建立步骤。当然，之所以写下来，也是因为遇到很坑，走过很长的路。</p><h2 id="一、环境要求"><a href="#一、环境要求" class="headerlink" title="一、环境要求"></a>一、环境要求</h2><p>1、MacOS Mojave 10.14.4<br>2、Xcode 10.2.1<br>3、git version 2.20.1 (Apple Git-117)<br>4、Gitlab</p><p>关于什么是Gitlab?与Github有什么区别？怎么安装git？。。。自行百度解决。</p><h2 id="二、私有仓库文件层级关系"><a href="#二、私有仓库文件层级关系" class="headerlink" title="二、私有仓库文件层级关系"></a>二、私有仓库文件层级关系</h2><h4 id="1、创建一个私有的代码仓库。"><a href="#1、创建一个私有的代码仓库。" class="headerlink" title="1、创建一个私有的代码仓库。"></a>1、创建一个私有的代码仓库。</h4><p>在远程创建私有仓库地址:<a href="http://gitlab.sz.sensetime.com/app-ios-library/BI-Camera.git" target="_blank" rel="noopener">http://gitlab.sz.sensetime.com/app-ios-library/BI-Camera.git</a></p><p>工程内容结构如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">➜  BI-Camera git:(master) ✗ tree .</span><br><span class="line">.</span><br><span class="line">├── LICENSE</span><br><span class="line">├── LICENSE.txt</span><br><span class="line">├── README.md</span><br><span class="line">├── README_CN.md</span><br><span class="line">├── app</span><br><span class="line">│   └── CameraDemo</span><br><span class="line">│       ├── CameraDemo</span><br><span class="line">│       │   ├── AppDelegate.h</span><br><span class="line">│       │   ├── AppDelegate.m</span><br><span class="line">│       │   ├── Assets.xcassets</span><br><span class="line">│       │   │   ├── AppIcon.appiconset</span><br><span class="line">│       │   │   │   └── Contents.json</span><br><span class="line">│       │   │   └── Contents.json</span><br><span class="line">│       │   ├── Base.lproj</span><br><span class="line">│       │   │   ├── LaunchScreen.storyboard</span><br><span class="line">│       │   │   └── Main.storyboard</span><br><span class="line">│       │   ├── Info.plist</span><br><span class="line">│       │   ├── ViewController.h</span><br><span class="line">│       │   ├── ViewController.m</span><br><span class="line">│       │   └── main.m</span><br><span class="line">│       └── CameraDemo.xcodeproj</span><br><span class="line">│           ├── project.pbxproj</span><br><span class="line">│           ├── project.xcworkspace</span><br><span class="line">│           │   ├── contents.xcworkspacedata</span><br><span class="line">│           │   ├── xcshareddata</span><br><span class="line">│           │   │   └── IDEWorkspaceChecks.plist</span><br><span class="line">│           │   └── xcuserdata</span><br><span class="line">│           │       └── weihua.xcuserdatad</span><br><span class="line">│           │           └── UserInterfaceState.xcuserstate</span><br><span class="line">│           └── xcuserdata</span><br><span class="line">│               └── weihua.xcuserdatad</span><br><span class="line">│                   └── xcschemes</span><br><span class="line">│                       └── xcschememanagement.plist</span><br><span class="line">└── camera</span><br><span class="line">    ├── BICamera.h</span><br><span class="line">    ├── camera</span><br><span class="line">    │   ├── Camera.h</span><br><span class="line">    │   └── Camera.m</span><br><span class="line">    └── preview</span><br><span class="line">        ├── Preview.h</span><br><span class="line">        └── Preview.m</span><br><span class="line"></span><br><span class="line"><span class="number">17</span> directories, <span class="number">24</span> files</span><br></pre></td></tr></table></figure></p><p>简单解释一下上面的内容：</p><p>其实<code>camera</code>文件中才是私有库的所有源码，即最终提交上到<code>cocoapods</code>仓库中提供给被人用的源码。</p><h4 id="2、把远程的私有版本库添加到本地索引，"><a href="#2、把远程的私有版本库添加到本地索引，" class="headerlink" title="2、把远程的私有版本库添加到本地索引，"></a>2、把远程的私有版本库添加到本地索引，</h4><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod repo <span class="built_in">add</span> <span class="built_in">camera</span> http:<span class="comment">//gitlab.sz.sensetime.com/app-ios-library/BI-Camera.git</span></span><br></pre></td></tr></table></figure><h4 id="3、创建podspec文件，内容如下："><a href="#3、创建podspec文件，内容如下：" class="headerlink" title="3、创建podspec文件，内容如下："></a>3、创建<code>podspec</code>文件，内容如下：</h4><p>命令行：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod <span class="keyword">spec</span> create BICamera</span><br></pre></td></tr></table></figure></p><p><code>BICamera.podspec</code>的主要内容如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Pod::Spec.new <span class="keyword">do</span> <span class="params">|spec|</span></span><br><span class="line"></span><br><span class="line">  spec.name         = <span class="string">"BICamera"</span></span><br><span class="line">  spec.version      = <span class="string">"0.0.1"</span></span><br><span class="line">  spec.summary      = <span class="string">"A Library for iOS to use for Camera."</span></span><br><span class="line">  spec.description  = <span class="string">&lt;&lt;-DESC</span></span><br><span class="line"><span class="string">                    "iOS pure native API camera based on Objective-C, highly integrated, fast and easy to use. Fast integration. Minimum support for iOS7 systems."</span></span><br><span class="line"><span class="string">                   DESC</span></span><br><span class="line">  spec.platform     = <span class="symbol">:ios</span>, <span class="string">"7.0"</span></span><br><span class="line">  spec.homepage     = <span class="string">"http://gitlab.sz.sensetime.com/app-ios-library/BI-Camera.git"</span></span><br><span class="line">  spec.license      = <span class="string">"MIT"</span></span><br><span class="line">  spec.author       = &#123; <span class="string">"1019459067"</span> =&gt; <span class="string">"1019459067@qq.com"</span> &#125;</span><br><span class="line">  spec.source       = &#123; <span class="symbol">:git</span> =&gt; <span class="string">"http://gitlab.sz.sensetime.com/app-ios-library/BI-Camera.git"</span>, <span class="symbol">:tag</span> =&gt; <span class="string">"<span class="subst">#&#123;spec.version.to_s&#125;</span>"</span>,<span class="symbol">:submodules</span> =&gt; <span class="literal">true</span> &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  spec.public_header_files = <span class="string">'camera/BICamera.h'</span></span><br><span class="line">  spec.source_files = <span class="string">'camera/BICamera.h'</span></span><br><span class="line"></span><br><span class="line">  spec.subspec <span class="string">'camera'</span> <span class="keyword">do</span> <span class="params">|ss|</span></span><br><span class="line">  ss.dependency <span class="string">'BICamera/preview'</span>  <span class="comment"># 这里表示camera中有依赖preview</span></span><br><span class="line"></span><br><span class="line">    ss.source_files = <span class="string">'camera/camera/*.&#123;h,m&#125;'</span></span><br><span class="line">    ss.public_header_files = <span class="string">'camera/camera/*.h'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  spec.subspec <span class="string">'preview'</span> <span class="keyword">do</span> <span class="params">|ss|</span></span><br><span class="line">    ss.source_files = <span class="string">'camera/preview/*.&#123;h,m&#125;'</span></span><br><span class="line">    ss.public_header_files = <span class="string">'camera/preview/*.h'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>更多关于PodSpec用法请参考 <a href="https://www.jianshu.com/p/4b0f45ea7517" target="_blank" rel="noopener">podspec用法</a></p><h4 id="4、验证私有库的合法性"><a href="#4、验证私有库的合法性" class="headerlink" title="4、验证私有库的合法性"></a>4、验证私有库的合法性</h4><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod <span class="class"><span class="keyword">lib</span> <span class="title">lint</span></span></span><br></pre></td></tr></table></figure><p>成功后有如下提示，说明配置成功</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> -&gt; BICamera (0.0.1)</span><br><span class="line">    -<span class="built_in"> NOTE </span> | [BICamera/camera,BICamera/preview] xcodebuild:  note: Using new build system</span><br><span class="line">    -<span class="built_in"> NOTE </span> | [BICamera/camera,BICamera/preview] xcodebuild:  note: Planning build</span><br><span class="line">    -<span class="built_in"> NOTE </span> | [BICamera/camera,BICamera/preview] xcodebuild:  note: Constructing build description</span><br><span class="line"></span><br><span class="line">BICamera passed validation.</span><br></pre></td></tr></table></figure><h4 id="5、将私有库推送至远程"><a href="#5、将私有库推送至远程" class="headerlink" title="5、将私有库推送至远程"></a>5、将私有库推送至远程</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">pod</span> repo <span class="keyword">push </span>camera <span class="keyword">BICamera.podspec</span></span><br></pre></td></tr></table></figure><p>为了方便调试，这里给出脚本供大家参考使用：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">tag</span> <span class="title">-d</span> $<span class="number">1</span></span><br><span class="line">git push origin :refs/tags/$<span class="number">1</span></span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"release $1"</span></span><br><span class="line">git push</span><br><span class="line">git <span class="keyword">tag</span> <span class="title">-m</span> <span class="string">"release $1"</span> $<span class="number">1</span></span><br><span class="line">git push --<span class="keyword">tag</span></span><br><span class="line">pod repo push camera BICamera.podspec</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure></p><h4 id="6、私有库使用"><a href="#6、私有库使用" class="headerlink" title="6、私有库使用"></a>6、私有库使用</h4><p>一般会使用<code>cocoapods</code>的童鞋都知道如何在工程中集成。这里简单介绍一下：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">platform</span> :ios, <span class="string">'7.0'</span></span><br><span class="line">use_frameworks!</span><br><span class="line">target :<span class="string">'testApp'</span> <span class="keyword">do</span></span><br><span class="line">  pod <span class="string">'Camera'</span>, source: <span class="string">'http://gitlab.sz.sensetime.com/app-ios-library/BI-Camera.git'</span> #<span class="keyword">private</span> pod server address</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h4 id="7、更新本地cocoapods的spec资源配置信息"><a href="#7、更新本地cocoapods的spec资源配置信息" class="headerlink" title="7、更新本地cocoapods的spec资源配置信息"></a>7、更新本地<code>cocoapods</code>的<code>spec</code>资源配置信息</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">pod repo update</span></span><br></pre></td></tr></table></figure><h4 id="8、最终结果"><a href="#8、最终结果" class="headerlink" title="8、最终结果"></a>8、最终结果</h4><p><img src="/2019/08/09/CocoaPods私有库/001.jpg" alt></p><h4 id="9、为了方便大家理解，这里在进行第一个版本发布后，再次罗列下工程的文件结构目录："><a href="#9、为了方便大家理解，这里在进行第一个版本发布后，再次罗列下工程的文件结构目录：" class="headerlink" title="9、为了方便大家理解，这里在进行第一个版本发布后，再次罗列下工程的文件结构目录："></a>9、为了方便大家理解，这里在进行第一个版本发布后，再次罗列下工程的文件结构目录：</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">➜  BI-Camera git:(master) ✗ tree .</span><br><span class="line">.</span><br><span class="line">├── BICamera</span><br><span class="line">│   └── <span class="number">0.0</span>.<span class="number">1</span></span><br><span class="line">│       └── BICamera.podspec</span><br><span class="line">├── BICamera.podspec</span><br><span class="line">├── LICENSE</span><br><span class="line">├── LICENSE.txt</span><br><span class="line">├── README.md</span><br><span class="line">├── README_CN.md</span><br><span class="line">├── app</span><br><span class="line">│   └── CameraDemo</span><br><span class="line">│       ├── CameraDemo</span><br><span class="line">│       │   ├── AppDelegate.h</span><br><span class="line">│       │   ├── AppDelegate.m</span><br><span class="line">│       │   ├── Assets.xcassets</span><br><span class="line">│       │   │   ├── AppIcon.appiconset</span><br><span class="line">│       │   │   │   └── Contents.json</span><br><span class="line">│       │   │   └── Contents.json</span><br><span class="line">│       │   ├── Base.lproj</span><br><span class="line">│       │   │   ├── LaunchScreen.storyboard</span><br><span class="line">│       │   │   └── Main.storyboard</span><br><span class="line">│       │   ├── Info.plist</span><br><span class="line">│       │   ├── ViewController.h</span><br><span class="line">│       │   ├── ViewController.m</span><br><span class="line">│       │   └── main.m</span><br><span class="line">│       └── CameraDemo.xcodeproj</span><br><span class="line">│           ├── project.pbxproj</span><br><span class="line">│           ├── project.xcworkspace</span><br><span class="line">│           │   ├── contents.xcworkspacedata</span><br><span class="line">│           │   ├── xcshareddata</span><br><span class="line">│           │   │   └── IDEWorkspaceChecks.plist</span><br><span class="line">│           │   └── xcuserdata</span><br><span class="line">│           │       └── weihua.xcuserdatad</span><br><span class="line">│           │           └── UserInterfaceState.xcuserstate</span><br><span class="line">│           └── xcuserdata</span><br><span class="line">│               └── weihua.xcuserdatad</span><br><span class="line">│                   └── xcschemes</span><br><span class="line">│                       └── xcschememanagement.plist</span><br><span class="line">└── camera</span><br><span class="line">    ├── BICamera.h</span><br><span class="line">    ├── camera</span><br><span class="line">    │   ├── Camera.h</span><br><span class="line">    │   └── Camera.m</span><br><span class="line">    └── preview</span><br><span class="line">        ├── Preview.h</span><br><span class="line">        └── Preview.m</span><br><span class="line"></span><br><span class="line"><span class="number">19</span> directories, <span class="number">26</span> files</span><br></pre></td></tr></table></figure><h2 id="三、私有仓库支持-a"><a href="#三、私有仓库支持-a" class="headerlink" title="三、私有仓库支持.a"></a>三、私有仓库支持.a</h2><p>因为创建、添加、验证、推送等操作已经介绍完成，这里只做关键部分的介绍。</p><p>以FaceSDK工程为例。</p><h5 id="1、工程目录如下："><a href="#1、工程目录如下：" class="headerlink" title="1、工程目录如下："></a>1、工程目录如下：</h5><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">➜  BI-FaceSDK git:(master) ✗ tree .</span><br><span class="line">.</span><br><span class="line">├── BIFaceSDK</span><br><span class="line">│   └── <span class="number">0.0</span>.<span class="number">1</span></span><br><span class="line">│       └── BIFaceSDK.podspec</span><br><span class="line">├── BIFaceSDK.podspec</span><br><span class="line">├── LICENSE.txt</span><br><span class="line">├── README.md</span><br><span class="line">├── README_CN.md</span><br><span class="line">├── app</span><br><span class="line">│   └── FaceSDKDemo</span><br><span class="line">│       ├── FaceSDKDemo</span><br><span class="line">│       │   ├── AppDelegate.h</span><br><span class="line">│       │   ├── AppDelegate.m</span><br><span class="line">│       │   ├── Assets.xcassets</span><br><span class="line">│       │   │   ├── AppIcon.appiconset</span><br><span class="line">│       │   │   │   └── Contents.json</span><br><span class="line">│       │   │   └── Contents.json</span><br><span class="line">│       │   ├── Base.lproj</span><br><span class="line">│       │   │   ├── LaunchScreen.storyboard</span><br><span class="line">│       │   │   └── Main.storyboard</span><br><span class="line">│       │   ├── Info.plist</span><br><span class="line">│       │   ├── ViewController.h</span><br><span class="line">│       │   ├── ViewController.m</span><br><span class="line">│       │   └── main.m</span><br><span class="line">│       └── FaceSDKDemo.xcodeproj</span><br><span class="line">│           ├── project.pbxproj</span><br><span class="line">│           ├── project.xcworkspace</span><br><span class="line">│           │   ├── contents.xcworkspacedata</span><br><span class="line">│           │   ├── xcshareddata</span><br><span class="line">│           │   │   └── IDEWorkspaceChecks.plist</span><br><span class="line">│           │   └── xcuserdata</span><br><span class="line">│           │       └── weihua.xcuserdatad</span><br><span class="line">│           │           └── UserInterfaceState.xcuserstate</span><br><span class="line">│           └── xcuserdata</span><br><span class="line">│               └── weihua.xcuserdatad</span><br><span class="line">│                   └── xcschemes</span><br><span class="line">│                       └── xcschememanagement.plist</span><br><span class="line">└── facesdk</span><br><span class="line">    ├── include</span><br><span class="line">    │   ├── cv_common.h</span><br><span class="line">    │   ├── cv_utils.h</span><br><span class="line">    │   ├── mid_face.h</span><br><span class="line">    │   ├── mid_face_attr.h</span><br><span class="line">    │   ├── mid_face_internal.h</span><br><span class="line">    │   └── mid_idcard.h</span><br><span class="line">    ├── lib</span><br><span class="line">    │   └── libMidFace.a</span><br><span class="line">    └── model</span><br><span class="line">        ├── M_Align_Deepface_106_track_2.<span class="number">17.6</span>.model</span><br><span class="line">        ├── M_Detect_Hunter_Common_Gray_11.<span class="number">2.0</span>.model</span><br><span class="line">        ├── M_Liveness_Antispoofing_3D_iPhoneX_Mobile_RGB_Depth_5.<span class="number">2.0</span>.model</span><br><span class="line">        ├── M_Liveness_Antispoofing_General_RGB_AIO_NoTrack_9.<span class="number">1.4</span>.model</span><br><span class="line">        └── M_Verify_Mobilenetv2Pruned_RGB_Surveillance_4.<span class="number">5.0</span>.model</span><br><span class="line"></span><br><span class="line"><span class="number">20</span> directories, <span class="number">32</span> files</span><br></pre></td></tr></table></figure><h5 id="2、BIFaceSDK-podspec内容如下："><a href="#2、BIFaceSDK-podspec内容如下：" class="headerlink" title="2、BIFaceSDK.podspec内容如下："></a>2、<code>BIFaceSDK.podspec</code>内容如下：</h5><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Pod::Spec.<span class="keyword">new</span> <span class="keyword">do</span> |s|</span><br><span class="line"></span><br><span class="line">  s.name         = <span class="string">"BIFaceSDK"</span></span><br><span class="line">  s.version      = <span class="string">"0.0.1"</span></span><br><span class="line">  s.summary      = <span class="string">"FaceSDK for iOS"</span></span><br><span class="line">  s.homepage     = <span class="string">"http://gitlab.sz.sensetime.com/app-ios-library/BI-FaceSDK.git"</span></span><br><span class="line">  s.license      = <span class="string">"MIT"</span></span><br><span class="line">  s.author       = &#123; <span class="string">"1019459067"</span> =&gt; <span class="string">"1019459067@qq.com"</span> &#125;</span><br><span class="line">  s.ios.deployment_target = <span class="string">"10.0"</span></span><br><span class="line"> </span><br><span class="line">  s.source        = &#123;:git =&gt;<span class="string">"http://gitlab.sz.sensetime.com/app-ios-library/BI-FaceSDK.git"</span>, :tag =&gt; <span class="string">"#&#123;s.version.to_s&#125;"</span>,:submodules =&gt; <span class="keyword">true</span> &#125;</span><br><span class="line">  s.vendored_libraries = <span class="string">"facesdk/lib/*.a"</span></span><br><span class="line">  s.resources     = <span class="string">"facesdk/model/*.&#123;model&#125;"</span></span><br><span class="line"></span><br><span class="line">  # s.frameworks = <span class="string">"Foundation"</span>,<span class="string">"UIKit"</span>,<span class="string">"AVFoundation"</span>,<span class="string">"AudioToolbox"</span>,<span class="string">"CoreGraphics"</span>,<span class="string">"CoreMedia"</span>,<span class="string">"CoreVideo"</span>,<span class="string">"MediaPlayer"</span>,<span class="string">"OpenGLES"</span>,<span class="string">"QuartzCore"</span></span><br><span class="line"></span><br><span class="line">  s.libraries = <span class="string">"bz2"</span>, <span class="string">"z"</span>,<span class="string">"stdc++"</span>,<span class="string">"iconv"</span></span><br><span class="line">  s.pod_target_xcconfig = &#123; <span class="string">'OTHER_LDFLAGS'</span> =&gt; <span class="string">'-lObjC'</span> &#125;</span><br><span class="line"></span><br><span class="line">  s.requires_arc = <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">   s.subspec <span class="string">'include'</span> <span class="keyword">do</span> |ss|</span><br><span class="line">      ss.source_files = <span class="string">'facesdk/include/*.&#123;h,m&#125;'</span></span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="3、最终结果"><a href="#3、最终结果" class="headerlink" title="3、最终结果"></a>3、最终结果</h4><p><img src="/2019/08/09/CocoaPods私有库/002.jpg" alt></p><p>这一部分主要介绍私有库对<code>.a</code>静态库的依赖，需要主要的地方是<code>配置文件的设置</code>和<code>文件的路径设置</code>。</p><h2 id="四、私有仓库支持-framework和私有库之间的相互依赖"><a href="#四、私有仓库支持-framework和私有库之间的相互依赖" class="headerlink" title="四、私有仓库支持.framework和私有库之间的相互依赖"></a>四、私有仓库支持.framework和私有库之间的相互依赖</h2>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
          <category> CocoaPods </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十八章、拓展一面试问题积累</title>
      <link href="/2019/08/02/%E7%AC%AC%E5%8D%81%E5%85%AB%E7%AB%A0%E3%80%81%E6%8B%93%E5%B1%95%E4%B8%80%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E7%A7%AF%E7%B4%AF/"/>
      <url>/2019/08/02/%E7%AC%AC%E5%8D%81%E5%85%AB%E7%AB%A0%E3%80%81%E6%8B%93%E5%B1%95%E4%B8%80%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E7%A7%AF%E7%B4%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Masonry设置等高、等宽"><a href="#一、Masonry设置等高、等宽" class="headerlink" title="一、Masonry设置等高、等宽"></a>一、Masonry设置等高、等宽</h2><p>子视图等高/等宽练习</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> 下面的例子是通过给equalTo()方法传入一个数组，设置数组中子视图及当前make对应的视图之间等高。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> 需要注意的是，下面block中设置边距的时候，应该用insets来设置，而不是用offset。</span></span><br><span class="line"><span class="comment"> 因为用offset设置right和bottom的边距时，这两个值应该是负数，所以如果通过offset来统一设置值会有问题。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    </span><br><span class="line">CGFloat padding = <span class="number">10</span><span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">UIView *redView = [[UIView alloc]init]<span class="comment">;</span></span><br><span class="line">redView.<span class="keyword">backgroundColor </span>= [UIColor redColor]<span class="comment">;</span></span><br><span class="line">[self.view <span class="keyword">addSubview:redView];</span></span><br><span class="line"><span class="keyword"> </span>   </span><br><span class="line">UIView *<span class="keyword">blueView </span>= [[UIView alloc]init]<span class="comment">;</span></span><br><span class="line"><span class="keyword">blueView.backgroundColor </span>= [UIColor <span class="keyword">blueColor];</span></span><br><span class="line"><span class="keyword">[self.view </span><span class="keyword">addSubview:blueView];</span></span><br><span class="line"><span class="keyword"> </span>   </span><br><span class="line">UIView *yellowView = [[UIView alloc]init]<span class="comment">;</span></span><br><span class="line">yellowView.<span class="keyword">backgroundColor </span>= [UIColor yellowColor]<span class="comment">;</span></span><br><span class="line">[self.view <span class="keyword">addSubview:yellowView];</span></span><br></pre></td></tr></table></figure><ul><li>等高</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********  等高   ***********/</span></span><br><span class="line">[redView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.left.right.top.equalTo(self.view).<span class="keyword">insets(UIEdgeInsetsMake(padding, </span>padding, <span class="number">0</span>, padding))<span class="comment">;</span></span><br><span class="line">    make.<span class="keyword">bottom.equalTo(blueView.mas_top).offset(-padding);</span></span><br><span class="line"><span class="keyword">&#125;];</span></span><br><span class="line"><span class="keyword">[blueView </span>mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.left.right.equalTo(self.view).<span class="keyword">insets(UIEdgeInsetsMake(0, </span>padding, <span class="number">0</span>, padding))<span class="comment">;</span></span><br><span class="line">    make.<span class="keyword">bottom.equalTo(yellowView.mas_top).offset(-padding);</span></span><br><span class="line"><span class="keyword">&#125;];</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">/**</span></span><br><span class="line"><span class="keyword"> </span>下面设置make.height的数组是关键，通过这个数组可以设置这三个视图高度相等。其他例如宽度之类的，也是类似的方式。</span><br><span class="line"> */</span><br><span class="line">[yellowView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.left.right.<span class="keyword">bottom.equalTo(self.view).insets(UIEdgeInsetsMake(0, </span>padding, padding, padding))<span class="comment">;</span></span><br><span class="line">    make.height.equalTo(@[<span class="keyword">blueView, </span>redView])<span class="comment">;</span></span><br><span class="line">&#125;]<span class="comment">;</span></span><br></pre></td></tr></table></figure><ul><li>等宽</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********  等宽   ***********/</span></span><br><span class="line">[redView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.top.left.<span class="keyword">bottom.equalTo(self.view).insets(UIEdgeInsetsMake(padding, </span>padding, padding, <span class="number">0</span>))<span class="comment">;</span></span><br><span class="line">    make.right.equalTo(<span class="keyword">blueView.mas_left).offset(-padding);</span></span><br><span class="line"><span class="keyword">&#125;];</span></span><br><span class="line"><span class="keyword">[blueView </span>mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.top.<span class="keyword">bottom.equalTo(self.view).insets(UIEdgeInsetsMake(padding, </span><span class="number">0</span>, padding, <span class="number">0</span>))<span class="comment">;</span></span><br><span class="line">    make.right.equalTo(yellowView.mas_left).offset(-padding)<span class="comment">;</span></span><br><span class="line">&#125;]<span class="comment">;</span></span><br><span class="line">[yellowView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.top.<span class="keyword">bottom.right.equalTo(self.view).insets(UIEdgeInsetsMake(padding, </span><span class="number">0</span>, padding, padding))<span class="comment">;</span></span><br><span class="line">    make.width.equalTo(@[redView, <span class="keyword">blueView]);</span></span><br><span class="line"><span class="keyword">&#125;];</span></span><br></pre></td></tr></table></figure><p>更多详情<a href="https://www.jianshu.com/p/587efafdd2b3" target="_blank" rel="noopener">iOS Masonry详解</a></p><h2 id="二、iOS原生推送（APNS）进阶推送图片、视频、音乐"><a href="#二、iOS原生推送（APNS）进阶推送图片、视频、音乐" class="headerlink" title="二、iOS原生推送（APNS）进阶推送图片、视频、音乐"></a>二、iOS原生推送（APNS）进阶推送图片、视频、音乐</h2><p>可以实现自定义的推送是源自于iOS10.0（iOS10才支持推送多媒体文件）</p><h2 id="三、签名和加密"><a href="#三、签名和加密" class="headerlink" title="三、签名和加密"></a>三、签名和加密</h2><ul><li>加密，是指对某个内容加密，加密后的内容还可以通过解密进行还原。</li></ul><p>比如我们把一封邮件进行加密，加密后的内容在网络上进行传输，接收者在收到后，通过解密可以还原邮件的真实内容。</p><ul><li>签名就是在信息的后面再加上一段内容，可以证明信息没有被修改过，怎么样可以达到这个效果呢？一般是对信息做一个hash计算得到一个hash值，注意，这个过程是不可逆的，也就是说无法通过hash值得出原来的信息内容。在把信息发送出去时，把这个hash值加密后做为一个签名和信息一起发出去。接收方在收到信息后，会重新计算信息的hash值，并和信息所附带的hash值(解密后)进行对比，如果一致，就说明信息的内容没有被修改过，因为这里hash计算可以保证不同的内容一定会得到不同的hash值，所以只要内容一被修改，根据信息内容计算的hash值就会变化。当然，不怀好意的人也可以修改信息内容的同时也修改hash值，从而让它们可以相匹配，为了防止这种情况，hash值一般都会加密后(也就是签名)再和信息一起发送，以保证这个hash值不被修改。至于如何让别人可以解密这个签名，这个过程涉及到数字证书等概念，我们后面在说到数字证书时再详细说明，这里您先只需先理解签名的这个概念。</li></ul><blockquote><p>哈希值，又称：散列函数（或散列算法，又称哈希函数，英语：Hash Function）是一种从任何一种数据中创建小的数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫做散列值（hash values，hash codes，hash sums，或hashes）的指纹。散列值通常用一个短的随机字母和数字组成的字符串来代表。好的散列函数在输入域中很少出现散列冲突。在散列表和数据处理中，不抑制冲突来区别数据，会使得数据库记录更难找到。</p></blockquote><h2 id="四、https连接过程"><a href="#四、https连接过程" class="headerlink" title="四、https连接过程"></a>四、https连接过程</h2><ul><li><strong>服务器端需要认证的通信过程</strong></li></ul><p>1、客户端发送请求到服务器端<br>2、服务器端返回证书和公开密钥，公开密钥作为证书的一部分而存在<br>3、客户端验证证书和公开密钥的有效性，如果有效，则生成共享密钥并使用公开密钥加密发送到服务器端<br>4、服务器端使用私有密钥解密数据，并使用收到的共享密钥加密数据，发送到客户端<br>5、客户端使用共享密钥解密数据<br>6、SSL加密建立…</p><ul><li><strong>客户端认证的通信的过程</strong></li></ul><p>客户端需要认证的过程跟服务器端需要认证的过程基本相同，并且少了最开始的两步。这种情况都是证书存储在客户端，并且应用场景比较少，一般金融才使用，比如支付宝、银行客户端都需要安装证书</p><h2 id="五socket端口范围"><a href="#五socket端口范围" class="headerlink" title="五socket端口范围"></a>五socket端口范围</h2><p>端口号范围:0-65535（2^16），总共能表示65536个数。</p><p>按端口号可分为3大类：</p><p>　　（1）公认端口（WellKnownPorts）：从0到1023，它们紧密绑定（binding）于一些服务。通常这些端口的通讯明确表明了某种服务的协议。例如：80端口实际上总是HTTP通讯。</p><p>　　（2）注册端口（RegisteredPorts）：从1024到49151。它们松散地绑定于一些服务。也就是说有许多服务绑定于这些端口，这些端口同样用于许多其它目的。例如：许多系统处理动态端口从1024左右开始。</p><p>　　（3）动态和/或私有端口（Dynamicand/orPrivatePorts）：从49152到65535。理论上，不应为服务分配这些端口。实际上，机器通常从1024起分配动态端口。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十七章、拓展一之基本问题</title>
      <link href="/2019/08/01/%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0%E3%80%81%E6%8B%93%E5%B1%95%E4%B8%80%E4%B9%8B%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98/"/>
      <url>/2019/08/01/%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0%E3%80%81%E6%8B%93%E5%B1%95%E4%B8%80%E4%B9%8B%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Swift与OC的区别？"><a href="#一、Swift与OC的区别？" class="headerlink" title="一、Swift与OC的区别？"></a>一、Swift与OC的区别？</h2><p><code>Swift</code>和<code>Objective-C</code>共用一套运行时环境。两者可以互相引用混合编程。其次就是，OC之前积累的很多类库，在<code>Swift</code>中大部分依然可以直接使用。OC出现过的绝大多数概念，比如引用计数、ARC、属性、协议、接口、初始化、扩展类、命名参数、匿名函数等，在<code>Swift</code>中继续有效。<code>Swift</code>大多数概念与OC一样。当然<code>Swift</code>也多出了一些新兴概念，这些在OC中是没有的，比如范型、元组等。</p><p>其实到现在为止<code>Swift</code>离完全替代<code>Objective-C</code>还是很遥远，因为Apple内部一直在用 <code>Objective-C</code>来做一些<code>Framework</code>的开发，底层也不可能用<code>Swift</code>实现，所以现在更多的替代是体现在外部开发。</p><p>优点：<br>1、Swift容易阅读，语法和文件结构简易化。<br>2、Swift更易于维护，文件分离后结构更清晰。<br>3、Swift更加安全，它是类型安全的语言。<br>4、Swift代码更少，简洁的语法，可以省去大量冗余代码。<br>5、Swift速度更快，运算性能更高。</p><p>缺点：<br>1、版本不稳定，之前升级Swift3大动刀<br>2、使用人数比例偏低，目前还是OC的天下<br>3、社区的开源项目偏少，毕竟OC独大好多年，很多优秀的类库都不支持Swift，不过这种状况正在改变，现在有好多优秀的Swift的开源类库了<br>4、公司使用的比例不高，很多公司以稳为主，还是在使用OC开发，很少一些在进行混合开发，更少一些是纯Swift开发<br>5、偶尔开发中遇到的一些问题，很难查找到相关资料，这是一个弊端<br>6、纯Swift的运行时和OC有本质区别，一些OC中运行时的强大功能，在纯Swift中变无效了<br>7、对于不支持<code>Swift</code>的一些第三方类库，如果非得使用，只能混合编程，利用桥接文件实现</p><h2 id="二、OC是动态语言？Swift为静态语言？"><a href="#二、OC是动态语言？Swift为静态语言？" class="headerlink" title="二、OC是动态语言？Swift为静态语言？"></a>二、OC是动态语言？Swift为静态语言？</h2><p>1、动态语言<br>是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构。</p><p>主要动态语言：<code>Objective-C、C#、JavaScript、PHP、Python、Erlang</code></p><p>2、静态语言<br>与动态语言相对应的，运行时结构不可变的语言就是静态语言。如<code>Java、C、C++</code></p><h2 id="三、如何理解OC是一门动态语言"><a href="#三、如何理解OC是一门动态语言" class="headerlink" title="三、如何理解OC是一门动态语言"></a>三、如何理解OC是一门动态语言</h2><p><a href="https://blog.csdn.net/wangsongyang617/article/details/79550045" target="_blank" rel="noopener">https://blog.csdn.net/wangsongyang617/article/details/79550045</a></p><h2 id="四、runtime的消息传递机制"><a href="#四、runtime的消息传递机制" class="headerlink" title="四、runtime的消息传递机制"></a>四、runtime的消息传递机制</h2><p>首先，<code>runtime</code>系统会把方法调用转化为消息发送，即<code>objc_msgSend</code>，并且把方法的调用者、方法选择器，当做参数传递过去.<br>此时，方法的调用者会通过<code>isa</code>指针来找到其所属的类，然后在<code>cache</code>或者<code>methodLists</code>中查找该方法，找得到就跳到对应的方法去执行。<br>如果在类中没有找到该方法，则通过<code>super_class</code>往上一级超类查找（如果一直找到<code>NSObject</code>都没有找到该方法的话，这种情况，我们放到后面消息转发的时候再说）。</p><p>在<code>runtime</code>中维护了一个SEL的表，这个表存储SEL不按照类来存储，只要相同的SEL就会被看做一个，并存储到表中。在项目加载时，会将所有方法都加载到这个表中，而动态生成的方法也会被加载到表中。</p><p>简单讲，对象根据方法编号SEL去映射表查找对应的方法实现。</p><h2 id="五、block和weak"><a href="#五、block和weak" class="headerlink" title="五、block和weak?"></a>五、<strong>block和</strong>weak?</h2><ul><li>__block</li></ul><p>对被截获变量进行赋值操作需要添加<code>__block</code>修饰符。<code>__block</code>修饰的变量最终变成了对象。<code>__block</code>本身并不能避免循环引用，避免循环引用需要在block内部把<code>__block</code>修饰的obj置为nil。另外一点就是<code>__block</code>修饰的变量在<code>block</code>内外都是唯一的，要注意这个特性可能带来的隐患。</p><p>1、<strong>block对象在block中是可以被修改、重新赋值的。<br>2、</strong>block对象在block中不会被block强引用一次，从而不会出现循环引用问题。</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)test0506_1</span><br><span class="line">&#123;</span><br><span class="line">    __block NSMutableArray *array;</span><br><span class="line">    void(^Block)(void) = ^&#123;</span><br><span class="line">       <span class="built_in"> array </span>= [NSMutableArray array];</span><br><span class="line">    &#125;;</span><br><span class="line">    Block();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>__weak</li></ul><p>本身是可以避免循环引用的问题的。但是其会导致外部对象释放了之后，<code>block</code>内部也访问不到这个对象的问题，我们可以通过在block内部声明一个<code>__strong</code>的变量来指向 weakObj，使外部对象既能在block内部保持住，又能避免循环引用的问题。</p><p>使用了<code>__weak</code>修饰符的对象，作用等同于定义为weak的property。自然不会导致循环引用问题，当原对象没有任何强引用的时候，弱引用指针也会被设置为nil。</p><p>更多详情<a href="https://blog.csdn.net/leikezhu1981/article/details/45009123" target="_blank" rel="noopener"><strong>block 与 </strong>weak的区别理解</a></p><h2 id="六、为什么在Block里面不加-block不允许更改变量？"><a href="#六、为什么在Block里面不加-block不允许更改变量？" class="headerlink" title="六、为什么在Block里面不加__block不允许更改变量？"></a>六、为什么在Block里面不加__block不允许更改变量？</h2><p>我们可以发现，系统自动给我们加上的注释，<code>bound by copy</code>，自动变量val虽然被捕获进来了，但是是用 <strong>cself-&gt;val来访问的。Block仅仅捕获了val的值，并没有捕获val的内存地址。所以在`</strong>main_block_func_0`这个函数中即使我们重写这个自动变量val的值，依旧没法去改变Block外面自动变量val的值。</p><p>OC可能是基于这一点，在编译的层面就防止开发者可能犯的错误，因为自动变量没法在Block中改变外部变量的值，所以编译过程中就报编译错误。</p><h2 id="七、为什么自动变量的值没有增加，而其他几个变量的值是增加的？自动变量是什么状态下被block捕获进去的？"><a href="#七、为什么自动变量的值没有增加，而其他几个变量的值是增加的？自动变量是什么状态下被block捕获进去的？" class="headerlink" title="七、为什么自动变量的值没有增加，而其他几个变量的值是增加的？自动变量是什么状态下被block捕获进去的？"></a>七、为什么自动变量的值没有增加，而其他几个变量的值是增加的？自动变量是什么状态下被block捕获进去的？</h2><p>自动变量是以值传递方式传递到Block的构造函数里面去的。Block只捕获Block中会用到的变量。由于只捕获了自动变量的值，并非内存地址，所以Block内部不能改变自动变量的值。Block捕获的外部变量可以改变值的是静态变量，静态全局变量，全局变量。</p><p>1、静态全局变量，全局变量由于作用域的原因，于是可以直接在Block里面被改变。他们也都存储在全局区。<br>2、静态变量传递给Block是内存地址值，所以能在Block里面直接改变值。</p><h2 id="八、为什么block能捕获变量"><a href="#八、为什么block能捕获变量" class="headerlink" title="八、为什么block能捕获变量"></a>八、为什么block能捕获变量</h2><p>__block将变量包装成对象，然后在把捕获到的变量封装在block的结构体里面，block内部存储的变量为结构体指针，也就可以通过指针找到内存地址进而修改变量的值。</p><h2 id="九、load和initialize的区别"><a href="#九、load和initialize的区别" class="headerlink" title="九、load和initialize的区别"></a>九、load和initialize的区别</h2><p>load是只要类所在文件被引用就会被调用，而initialize是在类或者其子类的第一个方法被调用前调用。所以如果类没有被引用进项目，就不会有load调用；但即使类文件被引用进来，但是没有使用，那么initialize也不会被调用。</p><p>相同点在于：方法只会被调用一次。</p><h2 id="十、关联对象为分类实现的添加对象，对象添加到哪里了？"><a href="#十、关联对象为分类实现的添加对象，对象添加到哪里了？" class="headerlink" title="十、关联对象为分类实现的添加对象，对象添加到哪里了？"></a>十、关联对象为分类实现的添加对象，对象添加到哪里了？</h2><p>关联对象由<code>AssociationsManager</code>管理，并在<code>AssociationsHashMap</code>存储。所有对象的关联内容都在同一个<strong>全局容器</strong>中。</p><h2 id="十一、了解关联对象的本质"><a href="#十一、了解关联对象的本质" class="headerlink" title="十一、了解关联对象的本质"></a>十一、了解关联对象的本质</h2><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AssociationsManager</span><br><span class="line">A<span class="function"><span class="title">ssociationsHashMap</span> --&gt;</span> object</span><br><span class="line">O<span class="function"><span class="title">bjectAssociationMap</span> --&gt;</span> key</span><br><span class="line">O<span class="function"><span class="title">bjectAssociation</span> --&gt;</span> value、policy</span><br></pre></td></tr></table></figure><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_setAssociatedObject(id _Nonnull <span class="keyword">object</span>, <span class="keyword">const</span> <span class="keyword">void</span> * _Nonnull key, id _Nullable <span class="keyword">value</span>, objc_AssociationPolicy policy)</span><br></pre></td></tr></table></figure><p>例子说明：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">setSex</span><span class="selector-pseudo">:(NSString</span> *)<span class="selector-tag">sex</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="selector-tag">objc_setAssociatedObject</span>(self, <span class="variable">@selector</span>(sex), sex, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>self</code>也就是<code>person</code>对象被赋给了<code>AssociationHashMap的key</code>，而<code>@selector(sex)</code>的地址被赋给了<code>ObjectAssociationMap</code>的<code>key</code>，策略<code>OBJC_ASSOCIATION_COPY_NONATOMIC</code>被赋值给了<code>ObjectAssociation</code>的<code>policy</code>，传递进来的值<code>sex</code>被赋值给了<code>ObjectAssociation</code>的<code>value</code>。</p><p>这种设计的巧妙之处就在于：</p><p>当一个<code>person</code>对象不光有一个属性值要关联时，比如我们要关联<code>height</code>和<code>sex</code>这两个属性时，我们以<code>person</code>对象作为<code>key</code>，然后值是<code>AssociationMap</code>这个字典类型，在这个字典类型中，分别使用<code>@selector(sex)</code>和<code>@selector(height)</code>作为<code>key</code>，然后分别利用<code>sex</code>属性的<code>policy</code>和传递进来的<code>value</code>和<code>height</code>属性的<code>policy</code>和传递进来的<code>value</code>生成<code>ObjectAssociation</code>作为<code>value</code>。而如果有多个<code>person</code>对象需要关联时，我们只需要在<code>AssociationHashMap</code>中创造更多的键值对就可以解决这个问题。</p><p><strong>通过这个过程我们也能明白：</strong><br>关联对象的值它不是存储在自己的实例对象的结构中，而是维护了一个全局的结构<code>AssociationManager</code></p><p>更多请参考<a href="https://www.jianshu.com/p/4b463169a84a" target="_blank" rel="noopener">Category的本质&lt;三&gt;关联对象</a></p><h2 id="十二、TCP为什么三次握手、四次释放？"><a href="#十二、TCP为什么三次握手、四次释放？" class="headerlink" title="十二、TCP为什么三次握手、四次释放？"></a>十二、TCP为什么三次握手、四次释放？</h2><h2 id="十三、项目中有没有用到runtime？怎么使用的？"><a href="#十三、项目中有没有用到runtime？怎么使用的？" class="headerlink" title="十三、项目中有没有用到runtime？怎么使用的？"></a>十三、项目中有没有用到runtime？怎么使用的？</h2><h2 id="十四、iOS中成员变量、实例变量、属性区分"><a href="#十四、iOS中成员变量、实例变量、属性区分" class="headerlink" title="十四、iOS中成员变量、实例变量、属性区分"></a>十四、iOS中成员变量、实例变量、属性区分</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span>  <span class="title">MyViewController</span> :<span class="title">UIViewController</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UIButton</span> *yourButton;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">id</span> data；</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIButton</span> *myButton;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><ul><li>成员变量</li></ul><p>在<code>{ }</code>中所声明的变量都为成员变量。<code>yourButton、count、data</code>都是成员变量。<br>成员变量用于类内部，无需与外界接触的变量。因为成员变量不会生成set、get方法，所以外界无法与成员变量接触。</p><ul><li>实例变量</li></ul><p>实例变量本质上就是成员变量。只是实例是针对类而言，实例是指类的声明。</p><ul><li>属性变量</li></ul><p>根据成员变量的私有性，为了方便访问，所以就有了属性变量。属性变量的好处就是允许让其他对象访问到该变量。<br>你可以设置只读或者可写等，设置方法也可自定义。所以，属性变量是用于与其他对象交互的变量。<code>myButton</code>是属性变量。</p><p>综上所述可知：<br>成员变量是定义在<code>{}</code>号中的变量，如果变量的数据类型是一个类则称这个变量为实例变量。因为实例变量是成员变量的一种特殊情况，所以实例变量也是类内部使用的，无需与外部接触的变量，这个也就是所谓的类私有变量。而属性变量是用于与其他对象交互的变量。</p><h2 id="十五、TCP连接与轮询拉取数据有什么区别？"><a href="#十五、TCP连接与轮询拉取数据有什么区别？" class="headerlink" title="十五、TCP连接与轮询拉取数据有什么区别？"></a>十五、TCP连接与轮询拉取数据有什么区别？</h2><h2 id="十六、自我介绍"><a href="#十六、自我介绍" class="headerlink" title="十六、自我介绍"></a>十六、自我介绍</h2><h2 id="十七、简单介绍一下自己的项目"><a href="#十七、简单介绍一下自己的项目" class="headerlink" title="十七、简单介绍一下自己的项目"></a>十七、简单介绍一下自己的项目</h2><h2 id="十八、iOS开发中的几种设计模式"><a href="#十八、iOS开发中的几种设计模式" class="headerlink" title="十八、iOS开发中的几种设计模式"></a>十八、iOS开发中的几种设计模式</h2><p>目前常用的几种设计模式：代理模式、观察者模式、MVC模式、单例模式、策略模式、工厂模式、MVVM</p><p><a href="https://www.cnblogs.com/wangbinios/p/7882082.html" target="_blank" rel="noopener">https://www.cnblogs.com/wangbinios/p/7882082.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十六章、HR提问要点</title>
      <link href="/2019/07/31/%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0%E3%80%81HR%E6%8F%90%E9%97%AE%E8%A6%81%E7%82%B9/"/>
      <url>/2019/07/31/%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0%E3%80%81HR%E6%8F%90%E9%97%AE%E8%A6%81%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="一、贵公司XXX业务发展很好，这是公司发展的重点么？"><a href="#一、贵公司XXX业务发展很好，这是公司发展的重点么？" class="headerlink" title="一、贵公司XXX业务发展很好，这是公司发展的重点么？"></a>一、贵公司XXX业务发展很好，这是公司发展的重点么？</h2><h2 id="二、怎么看待业务和技术？"><a href="#二、怎么看待业务和技术？" class="headerlink" title="二、怎么看待业务和技术？"></a>二、怎么看待业务和技术？</h2><h2 id="三、贵公司一般的团队的规模有多大，几个人负责一个产品或者业务？"><a href="#三、贵公司一般的团队的规模有多大，几个人负责一个产品或者业务？" class="headerlink" title="三、贵公司一般的团队的规模有多大，几个人负责一个产品或者业务？"></a>三、贵公司一般的团队的规模有多大，几个人负责一个产品或者业务？</h2><h2 id="四、贵公司的开发中是否会使用到一些最新技术？"><a href="#四、贵公司的开发中是否会使用到一些最新技术？" class="headerlink" title="四、贵公司的开发中是否会使用到一些最新技术？"></a>四、贵公司的开发中是否会使用到一些最新技术？</h2><h2 id="五、对新人有没有什么培训，会不会安排导师？"><a href="#五、对新人有没有什么培训，会不会安排导师？" class="headerlink" title="五、对新人有没有什么培训，会不会安排导师？"></a>五、对新人有没有什么培训，会不会安排导师？</h2><h2 id="六、你觉得我有哪些需要提高的地方？"><a href="#六、你觉得我有哪些需要提高的地方？" class="headerlink" title="六、你觉得我有哪些需要提高的地方？"></a>六、你觉得我有哪些需要提高的地方？</h2>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十五章、开发常见问题的积累及解答</title>
      <link href="/2019/07/30/%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0%E3%80%81%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E7%9A%84%E7%A7%AF%E7%B4%AF%E5%8F%8A%E8%A7%A3%E7%AD%94/"/>
      <url>/2019/07/30/%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0%E3%80%81%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E7%9A%84%E7%A7%AF%E7%B4%AF%E5%8F%8A%E8%A7%A3%E7%AD%94/</url>
      
        <content type="html"><![CDATA[<h2 id="一、iOS打包与提交测试"><a href="#一、iOS打包与提交测试" class="headerlink" title="一、iOS打包与提交测试"></a>一、iOS打包与提交测试</h2><p>1、使用Jenkins自动化自动化打包ipa<br>2、脚本支持python3或shell脚本<br>3、支持workspace和非workspace工程<br>4、采有蒲公英、fir.im第三方平台管理ipa下载分发，或自己建立下载平台（fir下载次数有限，蒲公英下载时间有限）</p><p>自动化打包脚本如下：<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 编译部分</span><br><span class="line">xcodebuild archive -project $targetName.xcodeproj -scheme $targetName -configuration Release -archivePath $targetName.xcarchive</span><br><span class="line"></span><br><span class="line"># xcodebuild -<span class="keyword">workspace</span> $targetName.xcworkspace -scheme $targetName -configuration Release -sdk iphoneos archive -archivePath $path_xcarchive</span><br><span class="line"></span><br><span class="line"># 输出ipa部分</span><br><span class="line">xcodebuild -exportArchive -archivePath $targetName.xcarchive -exportPath $path_ipa -exportOptionsPlist $path_exportOptionsPlist</span><br></pre></td></tr></table></figure></p><h2 id="二、使用apache探索iOS关于下载安装包下载的问题"><a href="#二、使用apache探索iOS关于下载安装包下载的问题" class="headerlink" title="二、使用apache探索iOS关于下载安装包下载的问题"></a>二、使用apache探索iOS关于下载安装包下载的问题</h2><p>1、推荐使用企业版证书打扮ipa，否则下载使用受限制<br>2、需要https服务托管ipa</p><h2 id="三、Xcode10与iOS12动态库适配以及解决方案"><a href="#三、Xcode10与iOS12动态库适配以及解决方案" class="headerlink" title="三、Xcode10与iOS12动态库适配以及解决方案"></a>三、Xcode10与iOS12动态库适配以及解决方案</h2><p>因Xcode升级，导致部分工程无法正常使用，分析其主要原因是<code>libstdc++.6.0.9.tbd</code>、<code>libstdc++.6.tbd</code>、<code>libstdc++.tbd</code>等动态库已经被移除。iOS12.0中全部采用<code>libc++</code>代替<code>lstdc++</code>的动态库。</p><p>其动态库路径：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/<span class="class"><span class="keyword">lib</span></span></span><br></pre></td></tr></table></figure></p><h2 id="四、研究iOS逆向工程"><a href="#四、研究iOS逆向工程" class="headerlink" title="四、研究iOS逆向工程"></a>四、研究iOS逆向工程</h2><p>1、成功更改过微信运动步数<br>2、移除过Oplayer lite以及搜狐视频的广告</p><p>其原理是：<br>1、通过runtime进行函数的进行消息转发<br>2、或通过hook的方式消息函数进行界面元素查找后，对其进行隐藏或显示操作</p><p>常用的软件推荐：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">MachOView</span>、<span class="keyword">Reveal14、Hopper </span>Disassembler <span class="built_in">v4</span>、iFunBox</span><br></pre></td></tr></table></figure></p><h2 id="五、简单理解音视频方面的知识"><a href="#五、简单理解音视频方面的知识" class="headerlink" title="五、简单理解音视频方面的知识"></a>五、简单理解音视频方面的知识</h2><ul><li>关于编码</li></ul><p>从存储角度、网络传输以及通用性的3个角度，压缩已经成了不可或缺的动作。编码就是按照一定的格式记录采样和量化后的数据。</p><ul><li>编码中软编码和硬编码的区别</li></ul><p>硬编码: 使用非CPU进行编码，例如使用GPU芯片处理。实现直接、简单，参数调整方便，升级易，但CPU负载重，性能较硬编码低，低码率下质量通常比硬编码要好一点。<br>软编码: 使用CPU来进行编码计算。性能高，低码率下通常质量低于硬编码器，但部分产品在GPU硬件平台移植了优秀的软编码算法（如X264）的，质量基本等同于软编码。</p><p>采集的时候需要给每个视频帧和音频样本加上时间戳，再通过一个基准将音画进行同步处理，</p><p>解决方案有如下几种：<br>1、将视频同步到音频上，就是以音频的播放速度为基准来同步视频。视频比音频播放慢了，加快其播放速度；快了，则延迟播放。<br>2、将音频同步到视频上，就是以视频的播放速度为基准来同步音频。<br>3、将视频和音频同步外部的时钟上，选择一个外部时钟为基准，视频和音频的播放速度都以该时钟为标准。</p><h2 id="六、谈谈Core-Graphics框架"><a href="#六、谈谈Core-Graphics框架" class="headerlink" title="六、谈谈Core Graphics框架"></a>六、谈谈Core Graphics框架</h2><h2 id="七、谈谈iOS开发过程中证书的理解"><a href="#七、谈谈iOS开发过程中证书的理解" class="headerlink" title="七、谈谈iOS开发过程中证书的理解"></a>七、谈谈iOS开发过程中证书的理解</h2><h2 id="八、谈谈对MDM的理解"><a href="#八、谈谈对MDM的理解" class="headerlink" title="八、谈谈对MDM的理解"></a>八、谈谈对MDM的理解</h2><h2 id="九、对相册优化"><a href="#九、对相册优化" class="headerlink" title="九、对相册优化"></a>九、对相册优化</h2><p>模拟微信相册，解决了icloud照片显示问题。</p><h2 id="十、ipa下发的方式"><a href="#十、ipa下发的方式" class="headerlink" title="十、ipa下发的方式"></a>十、ipa下发的方式</h2><p>1、Xcode直接编译<br>2、Xcode拖拽<br>3、iTunes拖拽<br>4、第三方平台，fir、pgyer等<br>5、自定义服务器，即搭建下载平台<br>6、AdHoc测试设备<br>7、AppStore上架</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十四章、消息相关</title>
      <link href="/2019/07/30/%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%E3%80%81%E6%B6%88%E6%81%AF%E7%9B%B8%E5%85%B3/"/>
      <url>/2019/07/30/%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%E3%80%81%E6%B6%88%E6%81%AF%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="说一下远程推送的流程。苹果怎么知道远程推送给哪台设备？又如何知道推送给哪个应用？"><a href="#说一下远程推送的流程。苹果怎么知道远程推送给哪台设备？又如何知道推送给哪个应用？" class="headerlink" title="说一下远程推送的流程。苹果怎么知道远程推送给哪台设备？又如何知道推送给哪个应用？"></a>说一下远程推送的流程。苹果怎么知道远程推送给哪台设备？又如何知道推送给哪个应用？</h2><p>iOS远程推送通过<code>APNs</code>实现。<code>APNs</code>是<code>Apple Push Notification service</code>的简称，它由Apple独家提供。远程推送的服务的实现依据的是服务器和客户端的长连接，信息通过服务器主动推送（push）给客户端（我们的手机）。</p><p>iOS的远程推送需要在真机上调试。使用<a href="https://github.com/shaojiankui/SmartPush" target="_blank" rel="noopener">SmartPush</a>调试。</p><ul><li>详细流程：(以今日头条为例)</li></ul><p>1、在今日头条App的<code>AppDelegate的didFinishLaunchingWithOptions</code>方法中注册远程推送通知，此时只要iOS设备正常联网能够访问到外网，iOS设备默认就会和<code>APNs</code>建立长连接，就会把iOS设备的<code>UDID(Unique Device Identifier：</code>唯一设备标识码，用来标识唯一一台苹果设备)和今日头条的<code>Bundle Identifier</code>通过长连接发送给<code>APNs</code>服务器，然后苹果通过这两个的值根据一定的加密算法得出<code>deviceToken</code>，并将<code>deviceToken</code>返回给iOS设备。(注：APNs服务器会留有<code>UDID+Bundle Identifier+deviceToken</code>的映射表)<br>2、实现<code>UIApplicationDelegate</code>代理中的有关于注册远程通知的相关方法，包括注册成功、注册失败、对接收到通知的处理等。<br>3、如果注册成功，实现注册成功的代理方法，就能够接收到<code>deviceToken</code>，并将<code>deviceToken</code>发送给今日头条服务器，今日头条服务器将此<code>deviceToken</code>存储在数据库中(一般如果是及时通讯类应用那么还会与用户的账号进行映射)。<br>4、如果注册失败，那么实现注册失败的协议方法，处理失败后的事情(包括发送给今日头条服务器注册失败等)。<br>5、今日头条服务器接收到<code>deviceToken</code>之后，就可以根据这些<code>deviceToken</code>向APNs发送推送一条新闻简要消息。<br>6、<code>APNs</code>接收到<code>deviceToken</code>和新闻简要消息之后，根据<code>deviceToken</code>查找映射表找到对应的<code>UDID</code>和<code>Bundle Identifier</code>，根据<code>UDID</code>找到唯一一台苹果设备，再在找到的苹果设备上根据<code>Bundle Identifier</code>找到唯一的应用(此处为今日头条)，然后推送消息。<br>7、当设备接收到消息的时候，如果今日头条在前台也就是用户正在使用今日头条，那么不会在设备上方弹出横幅(如果使用了音效，还会触发音效的播放)，直接调用我们实现的<code>UIApplicationDelegate</code>中的接收消息的方法。反之如果今日头条在后台或者未运行时就会在设备的上方弹出横幅(如果使用了音效，还会触发音效的播放)，点击横幅才会触发调用我们实现的<code>UIApplicationDelegate</code>中的接收消息的方法，这个时候你直接点击应用图标进来是不会调用的。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十三章、设计模式相关</title>
      <link href="/2019/07/30/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9B%B8%E5%85%B3/"/>
      <url>/2019/07/30/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="一、谈谈对设计模式的理解。你知道哪些设计模式，并简要叙述。"><a href="#一、谈谈对设计模式的理解。你知道哪些设计模式，并简要叙述。" class="headerlink" title="一、谈谈对设计模式的理解。你知道哪些设计模式，并简要叙述。"></a>一、谈谈对设计模式的理解。你知道哪些设计模式，并简要叙述。</h2><p>使用设计模式的目的：为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。 </p><p>设计模式是一种编码经验，就是用比较成熟的逻辑去处理某一种类型的事情。<br>1、MVC模式：<code>Model View Control</code>，把模型、视图、控制器层进行解耦和编写。<br>2、MVVM模式：<code>Model View ViewModel</code>，把模型、视图、业务逻辑层进行解耦和编写。<br>3、单例模式：通过<code>static</code>关键词，声明全局变量。在整个进程运行期间只会被赋值一次。<br>4、观察者模式：KVO是典型的通知模式，观察某个属性的状态，状态发生变化时通知观察者。<br>5、委托模式：代理+协议的组合。实现1对1的反向传值操作。<br>6、工厂模式：通过一个类方法，批量的根据已有模板生产对象。</p><h2 id="二、MVC和MVVM的区别"><a href="#二、MVC和MVVM的区别" class="headerlink" title="二、MVC和MVVM的区别"></a>二、MVC和MVVM的区别</h2><p>1、<code>MVVM</code>是对胖模型进行的拆分，其本质是给控制器减负，将一些弱业务逻辑放到<code>VM</code>中去处理。<br>2、<code>MV</code>是一切设计的基础，所有新的设计模式都是基于<code>MVC</code>进行的改进。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十二章、第三方库相关</title>
      <link href="/2019/07/30/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%E3%80%81%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E7%9B%B8%E5%85%B3/"/>
      <url>/2019/07/30/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%E3%80%81%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="一、AFNetworking框架分析"><a href="#一、AFNetworking框架分析" class="headerlink" title="一、AFNetworking框架分析"></a>一、AFNetworking框架分析</h2><ul><li>AFURLSessionManager、AFHTTPSessionManager</li></ul><p><code>AFHTTPSessionManager</code>又是继承于<code>AFURLSessionManager</code>，进行了封装。主要负责网络请求通讯。</p><ul><li>AFURLRequestSerialization</li></ul><p>主要用于网络请求之前的操作配置，负责配置网络请求的请求头部、序列化请求参数。</p><ul><li>AFURLResponseSerialization</li></ul><p>主要用于网络请求之后的数据处理，针对不同的数据进行处理，比如<code>JSON、XML、plist、图片格式等数据</code>。</p><ul><li>AFSecurityPolicy</li></ul><p>主要用于<code>HTTPS</code>环境下的认证安全请求通讯。如果是通过CA认证过的<code>HTTPS</code>访问地址，使用AFN时只需要拼接上<code>https://</code>即可，AFN的网络请求配置中默认使用CA认证访问<code>HTTPS</code>地址；若是自签的证书时，则需要当前类用于进行认证。</p><ul><li>AFNetworkReachabilityManager</li></ul><p>用于网络状态的监听，判断是否有网络，以及判断网络连接类型，比如蜂窝网络或WiFi环境。但当前类无法判断当前环境能否访问服务器服务。其原理是利用主机的数据包发送。</p><h2 id="二、SDWebImage分析"><a href="#二、SDWebImage分析" class="headerlink" title="二、SDWebImage分析"></a>二、SDWebImage分析</h2><ul><li>图片缓存在那个目录下？</li></ul><p>缓存的方法在SDImageCache.m里面，图片默认缓存路径<code>~/Library/Caches/default/com.hackemist.SDWebImageCache.default</code></p><ul><li>图片下载最大并发数和超时时间？</li></ul><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">import</span> <span class="string">"SDWebImageDownloader.h"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下载最大并发数</span></span><br><span class="line">_downloadQueue.maxConcurrentOperationCount = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下载超时时间</span></span><br><span class="line">_downloadTimeout = <span class="number">15.0</span>;</span><br></pre></td></tr></table></figure><ul><li>图片是怎样命名的？</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"SDImageCache.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//写入缓存用url做key</span></span><br><span class="line"><span class="built_in">NSUInteger</span> cost = SDCacheCostForImage(image);</span><br><span class="line">[<span class="keyword">self</span>.memCache setObject:image forKey:key cost:cost];</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入磁盘需要将url进行md5作为图片的key,防止文件名称过长</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)cachedFileNameForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *str = key.UTF8String;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        str = <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> r[CC_MD5_DIGEST_LENGTH];</span><br><span class="line">    CC_MD5(str, (CC_LONG)strlen(str), r);</span><br><span class="line">    <span class="built_in">NSURL</span> *keyURL = [<span class="built_in">NSURL</span> URLWithString:key];</span><br><span class="line">    <span class="built_in">NSString</span> *ext = keyURL ? keyURL.pathExtension : key.pathExtension;</span><br><span class="line">    <span class="built_in">NSString</span> *filename = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%@"</span>,</span><br><span class="line">                          r[<span class="number">0</span>], r[<span class="number">1</span>], r[<span class="number">2</span>], r[<span class="number">3</span>], r[<span class="number">4</span>], r[<span class="number">5</span>], r[<span class="number">6</span>], r[<span class="number">7</span>], r[<span class="number">8</span>], r[<span class="number">9</span>], r[<span class="number">10</span>],</span><br><span class="line">                          r[<span class="number">11</span>], r[<span class="number">12</span>], r[<span class="number">13</span>], r[<span class="number">14</span>], r[<span class="number">15</span>], ext.length == <span class="number">0</span> ? <span class="string">@""</span> : [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@".%@"</span>, ext]];</span><br><span class="line">    <span class="keyword">return</span> filename;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如何识别图片类型？</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"NSData+ImageContentType.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过NSData的第一个字符判断图片类型</span></span><br><span class="line">+ (SDImageFormat)sd_imageFormatForImageData:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)data;</span><br></pre></td></tr></table></figure><ul><li>查找到的图片可以知道图片来源吗？</li></ul><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="type">NS_ENUM</span>(<span class="type">NSInteger</span>, <span class="type">SDImageCacheType</span>) &#123; /**</span><br><span class="line">     * 从网上下载</span><br><span class="line">    */ <span class="type">SDImageCacheTypeNone</span>, /**</span><br><span class="line">     * 从磁盘获得</span><br><span class="line">     */ <span class="type">SDImageCacheTypeDisk</span>, /**</span><br><span class="line">     * 从内存获得</span><br><span class="line">     */ <span class="type">SDImageCacheTypeMemory</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>所有下载的图片都将被写入缓存？磁盘呢？何时缓存的？</li></ul><p>其一是下载成功后、自动保存。或者开发者通过代理处理图片并返回后缓存<br>其二是当缓存中没有、但是从硬盘中查询到了图片,在缓存上进行缓存。</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//磁盘不是强制写入。从枚举<span class="type">SDWebImageOptions</span>可见</span><br><span class="line">typedef <span class="type">NS_OPTIONS</span>(<span class="type">NSUInteger</span>, <span class="type">SDWebImageOptions</span>) &#123; /**</span><br><span class="line">     *  禁用磁盘缓存</span><br><span class="line">     */ <span class="type">SDWebImageCacheMemoryOnly</span> = 1 &lt;&lt; 2,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>磁盘缓存的时长？清理操作的时间点？</li></ul><p>默认一周清理一次；首先、通过时间进行清理。（最后修改时间&gt;一周）；然后、根据占据内存大小进行清理。（如果占据内存大于上限、则按时间排序、删除到上限的1/2。）</p><ul><li>下载图片的URL必须是NSURL么？</li></ul><p>不是，有容错处理。</p><ul><li>读取缓存以及读取磁盘的时候如何保证线程安全？</li></ul><p>读取缓存：<br>读取缓存的时候是在主线程进行。由于使用<code>NSCache</code>进行存储、所以不需要担心单个<code>value</code>对象的线程安全。</p><p>读取磁盘：<br>磁盘的读取虽然创建了一个<code>NSOperation</code>对象，但据我所见这个对象只是用来标记该操作是否被取消、以及取消之后不再读取磁盘文件的作用。<br>真正的磁盘缓存是在另一个IO专属线程中的一个串行队列下进行的。<br>如果你搜索self.ioQueue还能发现、不只是读取磁盘内容。<br>包括删除、写入等所有磁盘内容都是在这个IO线程进行、以保证线程安全。<br>但计算大小、获取文件总数等操作。则是在主线程进行。</p><h2 id="AsyncDisplayKit理解"><a href="#AsyncDisplayKit理解" class="headerlink" title="AsyncDisplayKit理解"></a>AsyncDisplayKit理解</h2><p>其主要目的就只解决App使用卡顿问题。</p><ul><li>分析原因部分：</li></ul><p>尽管从iPhone4S(A5)开始CPU已经采用多核，然而对于大多数app来说，多线程协作并没有被充分利用。换句话说，在app卡顿（主线程所占用的核心满负荷）时，往往CPU的其他核心几乎无事可做。一般情况下，由于主线程承担了绝大部分的工作，如果能把主线程的任务转移一部给其他线程进行异步处理，就可以马上享受到并发带来的性能提升。这应该也是<code>AsyncDisplayKit</code>得名的原因之一。</p><p><code>UIKit</code>的单线程设计也有一定的历史原因。早在十年前<code>iOS SDK</code>刚问世的时候，<code>mobileSDK</code>还是一个非常新的概念，更没有移动多核CPU的存在，因此当时的重点是简单可靠，大多数API都没有支持相对复杂的异步操作。时至今日，如果要完全重构<code>UIKit</code>使之支持异步绘制和布局，对于兼容已有海量的app，难度可想而知。在<code>iOS10</code>中虽然对U<code>ICollectionView/UITableView</code>做了一定的预加载优化（WWDC2016Session219），然而并没有从根本上解决主线程布局和渲染的问题。</p><ul><li><p>主要处理的问题：<br><code>UILayout</code>：文本计算、视图布局计算<br><code>Rendering</code>：文本渲染、图片解码、图形绘制<br><code>UIKit Objects</code>：对象的创建、调整、销毁</p></li><li><p>基本原理：<br>针对<code>ASNode</code>的修改和提交，会对其进行封装并提交到一个全局容器中<br><code>ASDK</code>也在<code>RunLoop</code>中注册了一个<code>Observer</code><br>当<code>RunLoop</code>进入休眠前，<code>ASDK</code>执行该Loop内提交的所有任务</p></li></ul><h2 id="三、ReactiveCocoa理解"><a href="#三、ReactiveCocoa理解" class="headerlink" title="三、ReactiveCocoa理解"></a>三、ReactiveCocoa理解</h2><p>ReactiveCocoa是一个基于函数响应式编程思想<code>（Function Reactive Programming，简称FRP）</code>的框架。由几个重要的部分组成，如下：<br>1、信号：例如<code>RACSignal</code>，可以被订阅，订阅后进行逻辑处理或者数据传递。<br>2、订阅者：例如<code>RACSubscriber</code>，表示订阅者的意思。用于订阅和发送数据。它是一个协议，由具体的类实现。<br>3、清理者：例如RACDisposable，用于取消或者清理订阅者的资源。<br>4、RACSubject：可以当成一个信号，也可以充当信号发送者。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十一章、加密算法相关</title>
      <link href="/2019/07/30/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%E3%80%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/"/>
      <url>/2019/07/30/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%E3%80%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="一、理解对称加密与非对称加密"><a href="#一、理解对称加密与非对称加密" class="headerlink" title="一、理解对称加密与非对称加密"></a>一、理解对称加密与非对称加密</h2><ul><li>对称加密</li></ul><p>对称加密是指加密与解密的使用同一个密钥的加密算法。<br>目前常见的加密算法有：<code>DES、AES、IDEA</code>等</p><ul><li>非对称加密</li></ul><p>非对称加密使用的是两个密钥，公钥与私钥，我们会使用公钥对网站账号密码等数据进行加密，再用私钥对数据进行解密。这个公钥会发给查看网站的所有人，而私钥是只有网站服务器自己拥有的。<br>目前常见非对称加密算法：<code>RSA、DSA、DH</code>等。</p><h2 id="二、Base64加密"><a href="#二、Base64加密" class="headerlink" title="二、Base64加密"></a>二、Base64加密</h2><p>采用64个基本的ASCII码字符对数据进行重新编码。Base64加密原则：6bit（原8bit）一个字节，不足的位数用0补齐，两个0用一个<code>=</code>表示。</p><p>例如：将对ABC进行Base64编码首先取ABC对应的ASCII码值，<code>A : 65</code>、<code>B : 66</code>、<code>C : 67</code>，再取二进制值<code>A : 01000001</code>、<code>B : 01000010</code>、<code>C : 01000011</code>，然后把这三个字节的二进制码接起来<code>010000010100001001000011</code>，再以6位为单位分成4个数据块并在最高位填充两个0后形成4个字节的编码后的值<code>00010000</code>、<code>00010100</code>、<code>00001001</code>、<code>00000011</code>；再把这4个字节数据转化成10进制数得<code>16</code>、<code>20</code>、<code>19</code>、<code>3</code>；最后根据Base64给出的64个基本字符表，查出对应的ASCII码字符<code>Q</code>、<code>U</code>、<code>J</code>、<code>D</code>，这里的值实际就是数据在字符表中的索引。解码过程就是把4个字节再还原成3个字节再根据不同的数据形式把字节数组重新整理成数据。</p><p>注：Base64字符表，包括大写<code>A-Z</code>小写<code>a-z</code>数字<code>0-9</code>和<code>+</code>以及<code>/</code>。</p><blockquote><p>Base64加密特点：</p><ul><li>数据加密之后，数据量会变大，变大1/3左右。</li><li>可进行反向解密。</li><li>编码后有个非常显著的特点，末尾有个=号。</li></ul></blockquote><h2 id="三、MD5加密"><a href="#三、MD5加密" class="headerlink" title="三、MD5加密"></a>三、MD5加密</h2><p>把一个任意长度的字节串变换成一定长的大整数。<br>请注意我使用了字节串而不是字符串这个词，是因为这种变换只与字节的值有关，与字符集或编码方式无关。MD5将任意长度的字节串变换成一个128bit的大整数，并且它是一个不可逆的字符串变换算法</p><p>注：MD5加密是不可逆的，也就是说，MD5加密后是不能解密的，所谓的解密只是用大数据的”试用”，来测出结果的。</p><blockquote><p>MD5特点:</p><ul><li>压缩性 : 任意长度的数据,算出的MD5值长度都是固定的。</li><li>容易计算 : 从原数据计算出MD5值很容易。</li><li>抗修改性 : 对原数据进行任何改动，哪怕只修改一个字节，所得到的MD5值都有很大区别。</li><li>弱抗碰撞 : 已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。</li><li>强抗碰撞 : 想找到两个不同数据，使他们具有相同的MD5值，是非常困难的。</li></ul></blockquote><h2 id="四、AES加密"><a href="#四、AES加密" class="headerlink" title="四、AES加密"></a>四、AES加密</h2><p>它是一种对称加密算法，这个标准也替代原先的DES标准，已经被多方分析且广为全世界所使用。AES作为新一代的数据加密标准汇聚了强安全性、高性能、高效率、易用和灵活，在软件及硬件上都能快速地加解密且只需要很少的存储资源等优点。</p><blockquote><p>AES加解密特点：</p><ul><li>AES强安全性、高性能、高效率、易用和灵活。</li><li>在软件及硬件上都能快速地加解密且只需要很少的存储资源。</li></ul></blockquote><h2 id="五、RSA加密"><a href="#五、RSA加密" class="headerlink" title="五、RSA加密"></a>五、RSA加密</h2><p>RSA是目前最有影响力的公钥加密算法，它能够抵抗到目前为止已知的绝大多数密码攻击，已被ISO推荐为公钥数据加密标准。RSA的公开密钥密码体制就是使用不同的加密密钥与解密密钥，是一种“由已知加密密钥推导出解密密钥在计算上是不可行的”密码体制。通常是先生成一对RSA密钥，其中之一是保密密钥，由用户保存；另一个为公开密钥，可对外公开，甚至可在网络服务器中注册。为提高保密强度，RSA密钥至少为500位长，一般推荐使用1024位，这就使加密的计算量很大。为减少计算量，在传送信息时，常采用传统加密方法与公开密钥加密方法相结合的方式，即信息采用改进的DES或IDEA对话密钥加密，然后使用RSA密钥加密对话密钥和信息摘要，对方收到信息后，用不同的密钥解密并可核对信息摘要。</p><blockquote><p>RSA加解密特点：</p><ul><li>RSA密钥管理的方便，计算量很大速度、相对比较慢。</li><li>RSA安全性很高，能够抵抗到目前为止已知的绝大多数密码攻击。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十章、网络相关</title>
      <link href="/2019/07/30/%E7%AC%AC%E5%8D%81%E7%AB%A0%E3%80%81%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/"/>
      <url>/2019/07/30/%E7%AC%AC%E5%8D%81%E7%AB%A0%E3%80%81%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="一、了解DNS解析吗？"><a href="#一、了解DNS解析吗？" class="headerlink" title="一、了解DNS解析吗？"></a>一、了解DNS解析吗？</h2><p>域名到IP地址的映射，DNS解析请求采用UDP数据报，且明文。之所以采用UDP，TCP连接的开销大，故采用UDP作为DNS的运输层协议，这也将导致只有13个根域名服务器的结果。</p><p>现在假如访问一个网站<code>www.baidu.com</code>，从按下回车到百度页面显示到电脑上会经历如下几个步骤：<br>1、计算机会向运营商(移动、电信、联通等)发出打开<code>www.baidu.com</code>的请求。<br>2、运营商收到请求后会到自己的DNS服务器中找<code>www.baidu.com</code>这个域名所对应的服务器的IP地址(也就是百度的服务器的IP地址)，这里比如是<code>180.149.132.47</code>。<br>3、运营商用第二步得到的IP地址去找到百度的服务器请求得到数据后返回给请求端。</p><p>其中第二步就是我们所说的DNS解析过程，域名和IP地址的关系其实就是我们的身份证号和姓名的关系，都是来标记一个人或者是一个网站的，只是IP地址\身份证号只是一串没有意义的数字，辨识度低，又不好记，所以就会在IP上加上一个域名以便区分，或是做的更加个性化，但是如果真的要来准确的区分还是要靠身份证号码或者是IP的，所以DNS解析就应运而生了。</p><h2 id="二、怎么解决DNS劫持？"><a href="#二、怎么解决DNS劫持？" class="headerlink" title="二、怎么解决DNS劫持？"></a>二、怎么解决DNS劫持？</h2><p>先分析DNS被劫持的原因，根本原因就是以下两点：<br>1、恶意攻击，拦截运营商的解析过程，把自己的非法东西嵌入其中。<br>2、运营商为了利益或者一些其他的因素，允许一些第三方在自己的链接里打打广告之类的。</p><p>防止DNS劫持的手段：<br>1、httpDNS<br><code>HttpDNS</code>是使用<code>HTTP</code>协议向DNS服务器的80端口进行请求，代替传统的DNS协议向DNS服务器的53端口进行请求，绕开了运营商的<code>Local DNS</code>，从而避免了使用运营商<code>Local DNS</code>造成的劫持和跨网问题。</p><p>2、长连接</p><h2 id="三、TCP和UDP的区别"><a href="#三、TCP和UDP的区别" class="headerlink" title="三、TCP和UDP的区别"></a>三、TCP和UDP的区别</h2><p>TCP是面向链接的，虽然说网络的不安全不稳定特性决定了多少次握手都不能保证连接的可靠性，但TCP的三次握手在最低限度上（实际上也很大程度上保证了）保证了连接的可靠性；而UDP不是面向连接的，UDP传送数据前并不与对方建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收，当然也不用重发，所以说UDP是无连接的、不可靠的一种数据传输协议。 </p><p><strong>简单的说，TCP注重数据可靠性，而UDP数据传输快点，但安全性一般。</strong></p><p>UDP特点：<br>1、无连接<br>2、尽最大努力交付<br>3、面向报文</p><p>TCP特点：<br>1、面向连接<br>2、可靠传输<br>3、面向字节流<br>4、流量控制<br>5、拥塞控制</p><h2 id="四、HTTPS都使用了哪些加密手段？为什么？"><a href="#四、HTTPS都使用了哪些加密手段？为什么？" class="headerlink" title="四、HTTPS都使用了哪些加密手段？为什么？"></a>四、HTTPS都使用了哪些加密手段？为什么？</h2><p>1、连接建立过程中使用非对称加密<br>2、数据传输过程中使用对称加密</p><h2 id="五、理解HTTPS"><a href="#五、理解HTTPS" class="headerlink" title="五、理解HTTPS"></a>五、理解HTTPS</h2><p><code>HTTPS</code>是以安全为目标的<code>HTTP</code>通道，简单讲是<code>HTTP</code>的安全版，即<code>HTTP+SSL/TSL</code>。HTTPS使用端口443，而不是象`HTTP那样使用端口80来通信。SSL使用40位关键字作为RC4流加密算法，这对于商业信息的加密是合适的。</p><p><code>HTTPS</code>的建立流程的过程：<br>1、客户端将自己支持的加密算法(<code>Cipher Suite</code>)发送给服务器，请求服务器证书<br>2、服务器选取一组加密算法，并将证书返回给客户端<br>3、客户端校验证书合法性，生成随机密钥，用公钥加密后发送给服务器<br>4、服务器用私钥解密出对称密钥，返回一个响应，<code>HTTPS</code>连接建立完成<br>5、随后双方通过这个对称密钥进行安全的数据通信。</p><h2 id="六、详谈HTTPS通信机制，HTTPS是如何进行安全通信的"><a href="#六、详谈HTTPS通信机制，HTTPS是如何进行安全通信的" class="headerlink" title="六、详谈HTTPS通信机制，HTTPS是如何进行安全通信的?"></a>六、详谈HTTPS通信机制，HTTPS是如何进行安全通信的?</h2><p><code>HTTPS</code>是以安全为目标的<code>HTTP</code>通道，简单讲是<code>HTTP</code>的安全版，即<code>HTTP+SSL/TSL</code>。其作用是：<br>1、通过证书等信息确认网站的真实性；<br>2、建立加密的信息通道；<br>3、数据内容的完整性。</p><p>这里需要弄清楚<code>HTTPS</code>建立通讯的流程是什么样子？在其它问题中已经做了相关描述。</p><p>重点部分：<br><code>Charles</code>作为一个中间人代理，当浏览器和服务器通信时，<code>Charles</code>接收服务器的证书，但动态生成一张证书发送给浏览器，也就是说<code>Charles</code>作为中间代理在浏览器和服务器之间通信，所以通信的数据可以被<code>Charles</code>拦截并解密。由于<code>Charle</code>s更改了证书，浏览器校验不通过会给出安全警告，必须安装<code>Charles</code>的证书后才能进行正常访问。</p><p>简单来说，就是Charles作为“中间人代理”，拿到了服务器证书公钥和<code>HTTPS</code>连接的对称密钥，前提是客户端选择信任并安装<code>Charles</code>的CA证书，否则客户端就会“报警”并中止连接。</p><p>其详细流程如下：<br>1、客户端向服务器发起<code>HTTPS</code>请求<br>2、<code>Charles</code>拦截客户端的请求，伪装成客户端向服务器进行请求<br>3、服务器向“客户端”（实际上是<code>Charles</code>）返回服务器的CA证书<br>4、<code>Charles</code>拦截服务器的响应，获取服务器证书公钥，然后自己制作一张证书，将服务器证书替换后发送给客户端。（这一步，<code>Charles</code>拿到了服务器证书的公钥）<br>5、客户端接收到“服务器”（实际上是<code>Charles</code>）的证书后，生成一个对称密钥，用<code>Charles</code>的公钥加密，发送给“服务器”（Charles）<br>6、<code>Charles</code>拦截客户端的响应，用自己的私钥解密对称密钥，然后用服务器证书公钥加密，发送给服务器。（这一步，<code>Charles</code>拿到了对称密钥）<br>7、服务器用自己的私钥解密对称密钥，向“客户端”（<code>Charles</code>）发送响应<br>8、<code>Charles</code>拦截服务器的响应，替换成自己的证书后发送给客户端<br>9、连接建立，<code>Charles</code>拿到了服务器证书的公钥和客户端与服务器协商的对称密钥，之后就可以解密或者修改加密的报文了。</p><p>更多详情请参考<a href="https://blog.csdn.net/zwjemperor/article/details/80719427" target="_blank" rel="noopener">浅谈HTTPS通信机制和Charles抓包原理</a></p><h2 id="七、谈谈GET和POST的区别"><a href="#七、谈谈GET和POST的区别" class="headerlink" title="七、谈谈GET和POST的区别"></a>七、谈谈GET和POST的区别</h2><p><code>HTTP/HTTPS</code>请求方法包括<code>GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE</code>。其中<code>GET</code>和<code>POST</code>最为常用。</p><p>从语义角度来说，<code>GET</code>是从指定的资源请求数据，<code>POST</code>是向指定的资源提交要被处理的数据。通俗点将，<code>GET</code>是获取数据，POST是<code>更新数据</code>。<br>具体区别可以大致总结为一下几点：</p><p>(1) GET的URL可见，POST的URL不可见；<br>(2) GET请求可以被缓存，POST不会被缓存；<br>(3) GET请求可以保留在浏览器历史记录中，POST不会；（是否引起Server端的任何状态变化）<br>(4) GET请求有长度限制，2048个字节，POST长度没有限制；<br>(5) GET请求是幂等性的，POST是非幂等性的；（同一个请求方式执行多次或一次的效果是否完全相同）<br>(6) GET请求的安全性没有POST高。</p><h2 id="八、理解HTTP"><a href="#八、理解HTTP" class="headerlink" title="八、理解HTTP"></a>八、理解HTTP</h2><p>著名的<code>OSI/RM</code>模型（<code>Open System Interconnection/Reference Model</code>）将计算机网络体系结构的通信协议划分为七层，自下而上依次为：<br>物理层（Physics Layer）、<br>数据链路层（Data Link Layer）、<br>网络层（Network Layer）、<br>传输层（Transport Layer）、<br>会话层（Session Layer）、<br>表示层（Presentation Layer）、<br>应用层（Application Layer）。</p><p><code>HTTP</code>通信的基本单位是报文，<code>HTTP</code>报文由从客户机到服务器的请求和从服务器到客户机的响应构成，包括请求报文和响应报文。</p><p>请求报文格式如下：<br>请求行 － 通用信息头 － 请求头 － 实体头 － 报文主体<br>响应报文格式如下：<br>状态行 － 通用信息头 － 响应头 － 实体头 － 报文主体</p><p><strong>两者的区别主要在于请求行与状态行：</strong><br>请求行由方法字段、URL字段、HTTP协议版本字段和CRLF构成；<br>状态行由版本、状态码、短语、CRLF构成。</p><blockquote><p>状态码的含义<br>1xx：http请求已经接受，继续处理请求<br>2xx：http请求已经处理完成<br>3xx：把请求访问的URL重定向到其它目录<br>4xx：客户端出现错误<br>5xx：服务端出现错误</p></blockquote><p>更多请参考<a href="https://www.jianshu.com/p/c5eb856d63eb" target="_blank" rel="noopener">iOS开发之HTTP与HTTPS网络请求</a></p><h2 id="九、理解TCP连接的建立需要通过三次握手，连接的断开需要通过四次挥手的过程。"><a href="#九、理解TCP连接的建立需要通过三次握手，连接的断开需要通过四次挥手的过程。" class="headerlink" title="九、理解TCP连接的建立需要通过三次握手，连接的断开需要通过四次挥手的过程。"></a>九、理解TCP连接的建立需要通过三次握手，连接的断开需要通过四次挥手的过程。</h2><p>采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误。</p><p>采用两次握手不行，原因就是考虑失效的连接请求的特殊情况。而在三次握手中，<code>client</code>和<code>server</code>都有一个发<code>syn</code>和收<code>ack</code>的过程，双方都是发后能收，表明通信则准备工作OK。</p><p>为什么不是四次握手呢？大家应该知道通信中著名的蓝军红军约定，这个例子说明，通信不可能100%可靠，而上面的三次握手已经做好了通信的准备工作，再增加握手，并不能显著提高可靠性，而且也没有必要。</p><ul><li>三次握手：</li></ul><p>第一次握手：建立连接时，客户端发送<code>SYN</code>包(syn=j)到服务器，并进入<code>SYN_SEND</code>状态，等待服务器确认；<br>第二次握手：服务器收到<code>SYN</code>包，必须确认客户<code>SYN</code>（ack=j+1），同时自己也发送一个<code>SYN</code>包（syn=k），即<code>SYN+ACK</code>包，此时服务器进入<code>SYN_RECV</code>状态；<br>第三次握手：客户端收到服务器的<code>SYN＋ACK</code>包，向服务器发送确认包<code>ACK</code>(ack=k+1)，此包发送完毕，客户端和服务器进入<code>ESTABLISHED</code>状态，完成三次握手。 </p><p>完成三次握手，客户端与服务器开始传送数据。</p><ul><li>四次挥手：</li></ul><blockquote><p>假设客户端主动关闭，服务器被动关闭。</p></blockquote><p>第一次握手：客户端发送一个<code>FIN</code>(结束)，用来关闭客户到服务端的连接。此时客户端不能发送数据，但还可以接受数据。<br>第二次握手：服务端收到这个<code>FIN</code>，他发回一个<code>ACK</code>(确认)，确认收到序号为收到序号+1（和<code>SYN</code>一样，一个<code>FIN</code>将占用一个序号）。此时虽然客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个<code>CLOSE-WAIT</code>状态持续的时间。<br>第三次握手：服务端发送一个<code>FIN</code>(结束)到客户端，服务端关闭客户端的连接。此时服务端也将不继续发送数据。<br>第四次握手：客户端发送<code>ACK</code>(确认)报文确认，并将确认的序号+1，这样关闭完成。</p><p>服务器只要收到了客户端发出的确认，立即进入<code>CLOSED</code>状态。从整个流程来看，服务器结束TCP连接的时间要比客户端早一些。至此，完成四次挥手。</p><h2 id="十、为什么建立连接是三次握手，关闭连接确是四次挥手呢？"><a href="#十、为什么建立连接是三次握手，关闭连接确是四次挥手呢？" class="headerlink" title="十、为什么建立连接是三次握手，关闭连接确是四次挥手呢？"></a>十、为什么建立连接是三次握手，关闭连接确是四次挥手呢？</h2><p>建立连接的时候，服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把<code>ACK</code>和<code>SYN</code>放在一个报文里发送给客户端。</p><p>而关闭连接时，服务器收到对方的<code>FIN</code>报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送<code>FIN</code>报文给对方来表示同意现在关闭连接，因此，己方<code>ACK</code>和<code>FIN</code>一般都会分开发送，从而导致多了一次。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第九章、KVO和KVC相关</title>
      <link href="/2019/07/30/%E7%AC%AC%E4%B9%9D%E7%AB%A0%E3%80%81KVO%E5%92%8CKVC%E7%9B%B8%E5%85%B3/"/>
      <url>/2019/07/30/%E7%AC%AC%E4%B9%9D%E7%AB%A0%E3%80%81KVO%E5%92%8CKVC%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="一、为什么都俗称KVO技术为黑魔法"><a href="#一、为什么都俗称KVO技术为黑魔法" class="headerlink" title="一、为什么都俗称KVO技术为黑魔法"></a>一、为什么都俗称KVO技术为黑魔法</h2><p>内部神秘、外观简洁。</p><h2 id="二、阐述系统KVO的实现原理"><a href="#二、阐述系统KVO的实现原理" class="headerlink" title="二、阐述系统KVO的实现原理"></a>二、阐述系统KVO的实现原理</h2><p>当观察一个对象时，一个新的类<code>（NSKVONotifying_A）</code>会动态被创建。这个类继承自该对象的原本的类，并重写了被观察属性的<code>setter</code>方法。重写的<code>setter</code>方法会负责在调用原<code>setter</code>方法之前和之后，通知所有观察对象值的更改。最后把这个对象的isa指针(isa指针告诉runtime系统这个对象的类是什么)指向这个新创建的子类，对象就神奇的变成了新创建的子类的实例。</p><p>简而言之，KVO是系统关于观察者模式的一种实现；KVO运用了isa混写技术的runtime来动态的为某一个类添加一个子类，重写<code>setter</code>，同时将原有的isa指针重新指向新的类。</p><h2 id="三、谈谈KVO的本质"><a href="#三、谈谈KVO的本质" class="headerlink" title="三、谈谈KVO的本质"></a>三、谈谈KVO的本质</h2><p>当一个对象使用了KVO监听，iOS系统会修改这个对象的isa指针，改为指向一个全新的通过<code>runtime</code>动态创建的子类，子类拥有自己的<code>setter</code>方法实现，<code>setter</code>方法实现内部会顺序调用如下方法实现：<br>1、<code>willChangeValueForKey</code>方法、<br>2、原来的<code>setter</code>方法实现、<br>3、<code>didChangeValueForKey</code>方法，而<code>didChangeValueForKey</code>方法内部又会调用监听器的<code>observeValueForKeyPath:ofObject:change:context:</code>监听方法。</p><h2 id="四、关于手动触发KVO"><a href="#四、关于手动触发KVO" class="headerlink" title="四、关于手动触发KVO"></a>四、关于手动触发KVO</h2><p>被监听的属性的值被修改时，就会自动触发KVO。如果想要手动触发KVO，则需要我们自己调用<code>willChangeValueForKey</code>和<code>didChangeValueForKey</code>方法即可在不改变属性值的情况下手动触发KVO，并且这两个方法缺一不可。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第八章、RunLoop相关</title>
      <link href="/2019/07/30/%E7%AC%AC%E5%85%AB%E7%AB%A0%E3%80%81RunLoop%E7%9B%B8%E5%85%B3/"/>
      <url>/2019/07/30/%E7%AC%AC%E5%85%AB%E7%AB%A0%E3%80%81RunLoop%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="一、谈谈对RunLoop的使用理解"><a href="#一、谈谈对RunLoop的使用理解" class="headerlink" title="一、谈谈对RunLoop的使用理解"></a>一、谈谈对RunLoop的使用理解</h2><p>保持程序持续运行，程序一启动就会开一个主线程，主线程一开起来就会跑一个主线程对应的<code>RunLoop</code>，<code>RunLoop</code>保证主线程不会被销毁，也就保证了程序的持续运行。</p><p><code>UIApplicationMain</code>函数内启动了<code>RunLoop</code>，程序不会马上退出，而是保持运行状态。故每一个应用必须要有一个<code>RunLoop</code>。我们知道主线程一开起来，就会跑一个和主线程对应的<code>RunLoop</code>，那么<code>RunLoop</code>一定是在程序的入口<code>main</code>函数中开启。</p><h2 id="二、RunLoop内部实现逻辑？"><a href="#二、RunLoop内部实现逻辑？" class="headerlink" title="二、RunLoop内部实现逻辑？"></a>二、RunLoop内部实现逻辑？</h2><p>RunLoop的源码</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用DefaultMode启动</span></span><br><span class="line"><span class="keyword">void</span> <span class="built_in">CFRunLoopRun</span>(<span class="keyword">void</span>) &#123;<span class="comment">/* DOES CALLOUT */</span></span><br><span class="line">    int32_t result;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        result = <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), kCFRunLoopDefaultMode, <span class="number">1.0e10</span>, <span class="literal">false</span>);</span><br><span class="line">        CHECK_FOR_FORK();</span><br><span class="line">    &#125; <span class="keyword">while</span> (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里发现<code>RunLoop</code>确实是<code>do while</code>通过判断<code>result</code>的值实现的。因此，可以把<code>RunLoop</code>看成一个死循环。如果没有<code>RunLoop</code>，<code>UIApplicationMain</code>函数执行完毕之后将直接返回，也就没有程序持续运行一说了。</p><p>因为<code>Fundation</code>框架是基于<code>CFRunLoopRef</code>的一层OC封装，所以可以主要研究<code>CFRunLoopRef</code>源码对<code>RunLoop</code>进行更深一层分析理解。</p><h2 id="三、谈谈RunLoop和线程的关系"><a href="#三、谈谈RunLoop和线程的关系" class="headerlink" title="三、谈谈RunLoop和线程的关系"></a>三、谈谈RunLoop和线程的关系</h2><p>（1）每条线程都有唯一的一个与之对应的<code>RunLoop</code>对象<br>（2）<code>RunLoop</code>保存在一个全局的<code>Dictionary</code>里，线程作为<code>key</code>，<code>RunLoop</code>作为<code>value</code><br>（3）主线程的<code>RunLoop</code>已经自动创建好了，子线程的<code>RunLoop</code>需要主动创建<br>（4）<code>RunLoop</code>在第一次获取时创建，在线程结束时销毁</p><h2 id="四、谈谈NSTimer与RunLoop的关系"><a href="#四、谈谈NSTimer与RunLoop的关系" class="headerlink" title="四、谈谈NSTimer与RunLoop的关系"></a>四、谈谈NSTimer与RunLoop的关系</h2><p><code>NSTimer</code>只是被加到了<code>kCFRunLoopDefaultMode</code>模式下，当scroll被滑动时，<code>RunLoop</code>被切换到了<code>UITrackingRunLoopMode</code>模式下，所以NSTimer自然就不工作了。</p><p>简单理解，同一时刻<code>RunLoop</code>只能在一种模式下运行，处理一种模式下的状态。</p><p>更多参考<a href="https://www.cnblogs.com/LynnAIQ/p/6122124.html" target="_blank" rel="noopener">Timer与RunLoop</a></p><h2 id="五、程序中添加每3秒响应一次的NSTimer，当拖动tableview时NSTimer可能无法响应要怎么解决？"><a href="#五、程序中添加每3秒响应一次的NSTimer，当拖动tableview时NSTimer可能无法响应要怎么解决？" class="headerlink" title="五、程序中添加每3秒响应一次的NSTimer，当拖动tableview时NSTimer可能无法响应要怎么解决？"></a>五、程序中添加每3秒响应一次的NSTimer，当拖动tableview时NSTimer可能无法响应要怎么解决？</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">2</span> repeats:<span class="literal">YES</span> block:^(<span class="built_in">NSTimer</span> * _Nonnull timer) &#123;  </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"test"</span>);  </span><br><span class="line">    &#125;];  </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    FOUNDATION_EXPORT NSRunLoopMode const NSDefaultRunLoopMode;</span></span><br><span class="line"><span class="comment">FOUNDATION_EXPORT NSRunLoopMode const NSRunLoopCommonModes API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer1 forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br></pre></td></tr></table></figure><p>原因分析：<br>如果当前线程就是主线程，也就是UI线程时，某些UI事件，比如UIScrollView的拖动操作，会将<code>RunLoop</code>切换成<code>NSEventTrackingRunLoopMode</code>模式，在这个过程中，默认的<code>NSDefaultRunLoopMode</code>模式中注册的事件是不会被执行的。也就是说，此时使用<code>scheduledTimerWithTimeInterval</code>添加到<code>RunLoop</code>中的NSTimer就不会执行。</p><p>解决原因：<br>为了设置一个不被UI干扰的NSTimer，我们需要手动创建一个NSTimer，然后使用<code>NSRunLoop的addTimer:forMode:</code>方法来把NSTimer按照指定模式加入到RunLoop中。这里使用的模式是：<code>NSRunLoopCommonModes</code>，这个模式等效于<code>NSDefaultRunLoopMode</code>和<code>NSEventTrackingRunLoopMode</code>的结合。</p><h2 id="六、RunLoop是怎么响应用户操作的，谈谈具体流程"><a href="#六、RunLoop是怎么响应用户操作的，谈谈具体流程" class="headerlink" title="六、RunLoop是怎么响应用户操作的，谈谈具体流程"></a>六、RunLoop是怎么响应用户操作的，谈谈具体流程</h2><p>按键（HOME键、锁屏键、音量键等）、传感器（摇晃、加速等）、触摸屏幕等【物理事件】会触发<code>IOKit.framework</code>生成一个<code>IOHIDEvent</code>对象，然后<code>SpringBoard</code>会接收这个对象并通过<code>mach port</code>发给当前App的进程；接下来进程会触发<code>RunLoop</code>的基于port的Source1回调一个<code>__IOHIDEventSystemClientQueueCallback()</code>的API，这个API会相应触发Source0来调用<code>__UIApplicationHandleEventQueue()</code>，而此API再将传递到此的IOHIDEvent处理包装成上层所熟悉的UIEvent。最后<code>UIEvent</code>会被分发给UIWindow根据<code>Respond chain</code>来响应事件。</p><p>梳理整个流程如下：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">物理事件 (按键、传感器、触摸等)</span><br><span class="line">|<span class="type"></span></span><br><span class="line"><span class="type">IOHIDEvent</span> (由IOKit.framework生成，SpringBoard接收)</span><br><span class="line">|<span class="type"></span></span><br><span class="line"><span class="type">App</span>进程 (由mach port内核消息通信机制传递Event，SpringBoard-&gt;App)</span><br><span class="line">|<span class="type"></span></span><br><span class="line"><span class="type">触发Source1</span></span><br><span class="line">|<span class="type"></span></span><br><span class="line"><span class="type">回调 __IOHIDEventSystemClientQueueCallback</span>()</span><br><span class="line">|<span class="type"></span></span><br><span class="line"><span class="type">触发Source0</span></span><br><span class="line">|<span class="type"></span></span><br><span class="line"><span class="type">回调__UIApplicationHandleEventQueue</span>()</span><br><span class="line">|<span class="type"></span></span><br><span class="line"><span class="type">将IOHIDEvent</span>封装成UIEvent</span><br><span class="line">|<span class="type"></span></span><br><span class="line"><span class="type">识别此事件是UIGesture</span>或屏幕旋转等</span><br><span class="line">|<span class="type"></span></span><br><span class="line"><span class="type">分发UIWindow</span></span><br><span class="line">|<span class="type"></span></span><br><span class="line"><span class="type">根据响应链交给对应的responder</span>进行事件回调</span><br></pre></td></tr></table></figure><p>而这整个事件处理流程是基于<code>RunLoop</code>的基本处理循环进行的。在<code>main</code>函数开始后，主线程的<code>RunLoop</code>对象被创建完。如<code>UIEvent、UI</code>绘制等会统一在主线程的<code>RunLoop</code>对象的即将进入休眠前的时间点触发各自对应的代理回调方法，然后<code>RunLoop</code>进入休眠，直到被<code>NSTimer</code>定时器或<code>Source1</code>发来的内核消息事件唤醒，再分别对<code>Timer、Source0、Source1</code>发来的事件进行处理回调。</p><h2 id="七、谈谈对RunLoop的几种状态的理解"><a href="#七、谈谈对RunLoop的几种状态的理解" class="headerlink" title="七、谈谈对RunLoop的几种状态的理解"></a>七、谈谈对RunLoop的几种状态的理解</h2><p>目前已知的Mode有5种：<br>1、<code>kCFRunLoopDefaultMode</code>：App的默认Mode，通常主线程是在这个Mode下运行<br>2、<code>UITrackingRunLoopMode</code>：界面跟踪Mode，用于<code>UIScrollView</code>追踪触摸滑动，保证界面滑动时不受其他Mode影响<br>3、<code>UIInitializationRunLoopMode</code>：在刚启动App时进入的第一个Mode，启动完成后就不再使用<br>4、<code>GSEventReceiveRunLoopMode</code>：接受系统事件的内部Mode，通常用不到<br>5、<code>kCFRunLoopCommonModes</code>：一个占位用的Mode，不是一种真正的Mode</p><h2 id="八、说一说RunLoop的mode作用"><a href="#八、说一说RunLoop的mode作用" class="headerlink" title="八、说一说RunLoop的mode作用"></a>八、说一说RunLoop的mode作用</h2><p>1、model主要是用来指定事件在运行循环中的优先级的，分为：<br><code>NSDefaultRunLoopMode（kCFRunLoopDefaultMode）</code>：默认，空闲状态<br><code>UITrackingRunLoopMode</code>：UIScrollView滑动时<br><code>UIInitializationRunLoopMode</code>：启动时<br><code>NSRunLoopCommonModes（kCFRunLoopCommonModes）</code>：Mode集合</p><p>2、苹果公开提供的Mode有两个：<br><code>NSDefaultRunLoopMode（kCFRunLoopDefaultMode）</code><br><code>NSRunLoopCommonModes（kCFRunLoopCommonModes）</code></p><h2 id="九、实现一个常驻线程"><a href="#九、实现一个常驻线程" class="headerlink" title="九、实现一个常驻线程"></a>九、实现一个常驻线程</h2><p>1、为当前线程开启一个<code>RunLoop</code><br>2、向该<code>RunLoop</code>中添加一个<code>Port/Source</code>等维持<code>RunLoop</code>的事件循环<br>3、启动该<code>RunLoop</code></p><p>简单理解，只要往<code>RunLoop</code>中添加了<code>timer、source或者observer</code>就会继续执行，一个<code>RunLoop</code>通常必须包含一个输入源或者定时器来监听事件，如果一个都没有，<code>RunLoop</code>启动后立即退出。</p><p>更多参考<a href="https://www.jianshu.com/p/bc04369ce69d" target="_blank" rel="noopener">iOS利用RunLoop创建一个常驻线程</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第七章、多线程相关</title>
      <link href="/2019/07/30/%E7%AC%AC%E4%B8%83%E7%AB%A0%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3/"/>
      <url>/2019/07/30/%E7%AC%AC%E4%B8%83%E7%AB%A0%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="一、谈谈对GCD的认识理解"><a href="#一、谈谈对GCD的认识理解" class="headerlink" title="一、谈谈对GCD的认识理解"></a>一、谈谈对GCD的认识理解</h2><p><code>Grand Central Dispatch(GCD)</code>，主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。它是一个在线程池模式的基础上执行的并发任务。</p><p>特点：<br>1、GCD可用于多核的并行运算<br>2、GCD会自动利用更多的CPU内核（比如双核、四核）<br>3、GCD会自动管理线程的生命周期（创建线程、调度任务、销毁线程）<br>4、程序员只需要告诉GCD想要执行什么任务，不需要编写任何线程管理代码</p><h5 id="执行任务有两种方式：同步执行（sync）和异步执行（async）。两者的主要区别是：是否等待队列的任务执行结束，以及是否具备开启新线程的能力。"><a href="#执行任务有两种方式：同步执行（sync）和异步执行（async）。两者的主要区别是：是否等待队列的任务执行结束，以及是否具备开启新线程的能力。" class="headerlink" title="执行任务有两种方式：同步执行（sync）和异步执行（async）。两者的主要区别是：是否等待队列的任务执行结束，以及是否具备开启新线程的能力。"></a>执行任务有两种方式：同步执行（sync）和异步执行（async）。两者的主要区别是：是否等待队列的任务执行结束，以及是否具备开启新线程的能力。</h5><ul><li>同步执行（sync）：</li></ul><p>同步添加任务到指定的队列中，在添加的任务执行结束之前，会一直等待，直到队列里面的任务完成之后再继续执行。<br>只能在当前线程中执行任务，不具备开启新线程的能力。</p><ul><li>异步执行（async）：</li></ul><p>异步添加任务到指定的队列中，它不会做任何等待，可以继续执行任务。<br>可以在新的线程中执行任务，具备开启新线程的能力。</p><h5 id="GCD-中有两种队列：串行队列和并发队列。两者都符合-FIFO（先进先出）的原则。两者的主要区别是：执行顺序不同，以及开启线程数不同。"><a href="#GCD-中有两种队列：串行队列和并发队列。两者都符合-FIFO（先进先出）的原则。两者的主要区别是：执行顺序不同，以及开启线程数不同。" class="headerlink" title="GCD 中有两种队列：串行队列和并发队列。两者都符合 FIFO（先进先出）的原则。两者的主要区别是：执行顺序不同，以及开启线程数不同。"></a>GCD 中有两种队列：串行队列和并发队列。两者都符合 FIFO（先进先出）的原则。两者的主要区别是：执行顺序不同，以及开启线程数不同。</h5><ul><li>串行队列（Serial Dispatch Queue）：</li></ul><p>每次只有一个任务被执行。让任务一个接着一个地执行。（只开启一个线程，一个任务执行完毕后，再执行下一个任务）</p><ul><li>并发队列（Concurrent Dispatch Queue）：</li></ul><p>可以让多个任务并发（同时）执行。（可以开启多个线程，并且同时执行任务）</p><h5 id="既然我们有两种队列（串行队列-并发队列），两种任务执行方式（同步执行-异步执行），那么我们就有了六种不同的组合方式："><a href="#既然我们有两种队列（串行队列-并发队列），两种任务执行方式（同步执行-异步执行），那么我们就有了六种不同的组合方式：" class="headerlink" title="既然我们有两种队列（串行队列/并发队列），两种任务执行方式（同步执行/异步执行），那么我们就有了六种不同的组合方式："></a>既然我们有两种队列（串行队列/并发队列），两种任务执行方式（同步执行/异步执行），那么我们就有了六种不同的组合方式：</h5><p>1、同步执行 + 并发队列<br>在当前线程中执行任务，不会开启新线程，执行完一个任务，再执行下一个任务。<br>2、异步执行 + 并发队列<br>可以开启多个线程，任务交替（同时）执行。<br>3、同步执行 + 串行队列<br>不会开启新线程，在当前线程执行任务。任务是串行的，执行完一个任务，再执行下一个任务。<br>4、异步执行 + 串行队列<br>会开启新线程，但是因为任务是串行的，执行完一个任务，再执行下一个任务。<br>5、同步执行 + 主队列<br>在不同线程中调用结果也是不一样，在主线程中调用会出现死锁，而在其他线程中则不会。<br>6、异步执行 + 主队列<br>不会开启新线程，执行完一个任务，再执行下一个任务。</p><h2 id="二、谈谈对NSOperation、NSOperationQueue的认识理解"><a href="#二、谈谈对NSOperation、NSOperationQueue的认识理解" class="headerlink" title="二、谈谈对NSOperation、NSOperationQueue的认识理解"></a>二、谈谈对NSOperation、NSOperationQueue的认识理解</h2><p><code>NSOperation</code>、<code>NSOperationQueue</code>是基于GCD更高一层的封装，完全面向对象。但是比GCD更简单易用、代码可读性也更高。但是<code>NSOperation</code>是个抽象类，不能用来封装操作。只有使用它的子类来封装操作。（<code>NSInvocationOperation</code>、<code>NSBlockOperation</code>、自定义）</p><p>特点：<br>1、可添加完成的代码块，在操作完成后执行。<br>2、添加操作之间的依赖关系，方便的控制执行顺序。<br>3、设定操作执行的优先级。<br>4、可以很方便的取消一个操作的执行。<br>5、使用KVO观察对操作执行状态的更改：<code>isExecuting</code>、<code>isFinished</code>、<code>isCancelled</code>。</p><p>NSInvocationOperation：<br>在其他线程中单独使用子类<code>NSInvocationOperation</code>，操作是在当前调用的其他线程执行的，并没有开启新线程。</p><p>NSBlockOperation：<br>一般情况下，如果一个<code>NSBlockOperation</code>对象封装了多个操作。<code>NSBlockOperation</code>是否开启新线程，取决于操作的个数。如果添加的操作的个数多，就会自动开启新线程。当然开启的线程数是由系统来决定的。</p><p>自定义继承自NSOperation的子类：<br>在没有使用<code>NSOperationQueue</code>、在主线程单独使用自定义继承自<code>NSOperation</code>的子类的情况下，是在主线程执行操作，并没有开启新线程。</p><p><code>NSOperationQueue</code>控制串行执行、并发执行<br><code>maxConcurrentOperationCount</code>，叫做最大并发操作数。用来控制一个特定队列中可以有多少个操作同时参与并发执行。这里<code>maxConcurrentOperationCount</code>控制的不是并发线程的数量，而是一个队列中同时能并发执行的最大操作数。而且一个操作也并非只能在一个线程中运行。<br>简单来说，当最大并发操作数为1时，操作是按顺序串行执行的，并且一个操作完成之后，下一个操作才开始执行。当最大操作并发数为2时，操作是并发执行的，可以同时执行两个操作。而开启线程数量是由系统决定的，不需要我们来管理。</p><p>更多参考详情点击<a href="https://www.jianshu.com/p/4b1d77054b35" target="_blank" rel="noopener">iOS 多线程：『NSOperation、NSOperationQueue』详尽总结</a></p><h2 id="三、如何保证线程安全？"><a href="#三、如何保证线程安全？" class="headerlink" title="三、如何保证线程安全？"></a>三、如何保证线程安全？</h2><p>1、nonatomic atomic：使用atomic多线程原子性控制，atomic的原理给setter加上锁，getter不会加锁。OC在定义属性时有nonatomic和atomic两种选择<br>2、使用GCD实现atomic操作：给某字段的setter和getter方法加上同步队列<br>3、使用NSLock<br>4、使用互斥锁</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六章、Block相关</title>
      <link href="/2019/07/30/%E7%AC%AC%E5%85%AD%E7%AB%A0%E3%80%81Block%E7%9B%B8%E5%85%B3/"/>
      <url>/2019/07/30/%E7%AC%AC%E5%85%AD%E7%AB%A0%E3%80%81Block%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="一、你都遇到过哪些循环引用？你又是怎么解决的？"><a href="#一、你都遇到过哪些循环引用？你又是怎么解决的？" class="headerlink" title="一、你都遇到过哪些循环引用？你又是怎么解决的？"></a>一、你都遇到过哪些循环引用？你又是怎么解决的？</h2><p>1、NSTimer<br>创建使用<code>NSTimer</code>的时候，<code>NSTimer</code>会默认对当前self有个强引用，所有在self使用打算完成的时候，一定要先使用<code>NSTimer</code>的<code>invalidate</code>来停止是否时间控制对self的引用。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[_timer invalidate]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p>2、Block<br><code>Block</code>也是比较常见的循环引用问题，在<code>Block</code>中使用了self容易出现循环引用，因此很多人在使用block的时候，加入里面有用到self的操作都会声明一个<code>__weak</code>来修饰self。其实便不是这样的，不是所有使用了<code>Block</code>都会出现self循环引用问题，只有self拥有<code>Block</code>的强引用才会出现这种情况。<br>所以一般在函数中临时使用<code>Block</code>是不会出现循环应用的，因为这时候<code>Block</code>引用是属于栈的。当栈上的<code>Block</code>释放后，<code>Block</code>中对self的引用计数也会减掉。<br>当然不一定要self对<code>Block</code>有直接的引用才会出现，假如self的变量B，B中有个<code>Block</code>变量，就容易出现这种情况，需要注意的是在<code>Block</code>出现循环引用的，Xcode7之后的版本会出现警告提示（之前版本不确定）。</p><p>3、delegate<br><code>delegate</code>是iOS中开发中最常遇到的循环引用，一般在声明<code>delegate</code>的时候都要使用弱引用<code>weak</code>或者<code>assign</code></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>, <span class="keyword">nullable</span>) <span class="keyword">id</span> &lt;<span class="built_in">UITableViewDelegate</span>&gt; delegate;</span><br></pre></td></tr></table></figure><p>当然怎么选择使用<code>assign</code>还是<code>weak</code>，MRC的话只能用<code>assign</code>，在ARC的情况下最好使用<code>weak</code>，因为<code>weak</code>修饰的变量在是否后自动为指向nil，防止不安全的野指针存在。</p><h2 id="二、对Block基本的认识"><a href="#二、对Block基本的认识" class="headerlink" title="二、对Block基本的认识"></a>二、对Block基本的认识</h2><p>本质上也是一个OC对象，它内部也有一个isa指针，是封装了函数调用以及函数调用环境的OC对象。</p><p>根据<code>Block</code>的内存地址，系统把<code>Block</code>分为3类：<br><code>NSGlobalBlock</code>：全局Block，位于内存全局区。内部没有引用局部变量<br><code>NSMallocBlock</code>：堆区Block，位于内存堆区。引用了局部变量，存放的位置是堆区<br><code>NSStackBlock</code>：栈区Block，位于内存栈区。其实上面的<code>Block</code>在声明的时候其实默认隐藏了参数，默认参数是<code>__strong</code>，对应的是<code>__weak</code>，在ARC环境下，如果用<code>__weak</code>修饰的<code>Block</code>，就会生成栈区<code>Block</code>(<code>NSStackBlock</code>)；当然，如果<code>Block</code>内部没有引用外部变量，那么它还是全局的<code>Block</code>。</p><p>由此可见，<code>Block</code>是什么类型，主要是由两个因素决定的：<br>一个是是否引用了局部变量；<br>一个是是否是使用<code>strong</code>修饰的。</p><h2 id="三、为什么Block会产生循环引用？"><a href="#三、为什么Block会产生循环引用？" class="headerlink" title="三、为什么Block会产生循环引用？"></a>三、为什么Block会产生循环引用？</h2><p><code>Block</code>里面使用self不一定会引起循环引用。循环引用的原因是相互指引，相互是关键。如果相互这一层关系达不到就没有所谓的循环引用。</p><p>那么具体什么情况下会引起循环引用？<br>1、强引用自定义的<code>Block</code>，里面再次调用self，导致的循环引用。<br>2、循环引用的发生的条件就是强持有这个<code>Block</code>，并且被<code>Block</code>里面的加入的对象强持有。<br>3、使用NSNotification使用系统自带的<code>Block</code>会发生循环引用。</p><h2 id="四、Block为什么要是用copy修饰符"><a href="#四、Block为什么要是用copy修饰符" class="headerlink" title="四、Block为什么要是用copy修饰符"></a>四、Block为什么要是用copy修饰符</h2><p>因为<code>Block</code>变量默认为栈变量，为了能够在<code>Block</code>声明的作用域外使用，所以把<code>Block</code>拷贝到堆上去。</p><p>简单来说，为了<code>Block</code>属性声明和实际的操作一致，最好声明为<code>copy</code>。</p><h2 id="五、怎么理解Block截获变量的特性？"><a href="#五、怎么理解Block截获变量的特性？" class="headerlink" title="五、怎么理解Block截获变量的特性？"></a>五、怎么理解Block截获变量的特性？</h2><p>1、局部变量：基本数据类型，对象类型(对于基本数据类型的局部变量截获其值，对于对象类型的局部变量连同所有权修饰符一起截获)<br>2、静态局部变量：以指针形式截获局部静态变量<br>3、全局变量：不截获全局变量<br>4、静态全局变量：不截获静态全局变量</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五章、内存管理相关</title>
      <link href="/2019/07/29/%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9B%B8%E5%85%B3/"/>
      <url>/2019/07/29/%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="一、什么时候是用-autoreleasepool"><a href="#一、什么时候是用-autoreleasepool" class="headerlink" title="一、什么时候是用@autoreleasepool"></a>一、什么时候是用@autoreleasepool</h2><p>1、写基于命令行的的程序时，就是没有UI框架，如<code>AppKit、Cocoa</code>框架时。<br>2、当我们的应用有需要创建大量的临时变量的时候，可以是用<code>@autoreleasepool</code>来减少内存峰值。<br>3、for循环大量的图片数据等内存消耗大的场景。</p><h2 id="二、AutoreleasePool的实现原理"><a href="#二、AutoreleasePool的实现原理" class="headerlink" title="二、AutoreleasePool的实现原理"></a>二、AutoreleasePool的实现原理</h2><p>在编译时<code>@autoreleasepool{}</code>被转换为一个<code>__AtAutoreleasePool</code>，通常这个结构体会在初始化时调用<code>objc_autoreleasePoolPush()</code>方法，在析构时调用<code>objc_autoreleasePoolPop()</code>方法。而这些方法都是对<code>AutoreleasePoolPage</code>的简单封装。<code>AutoreleasePool</code>并没有单独的结构，而是由若干个<code>AutoreleasePoolPage</code>以双向链表的形式组合而成（分别对应结构中的<code>parent</code>指针和<code>child</code>指针）。所以想深入理解<code>AutoreleasePool</code>必须首先了解<code>AutoreleasePoolPage</code>。</p><p>可以使用<code>clang -rewrite-objc</code>命令将<code>Objective-C</code>代码重写成<code>C++</code>代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc main.m</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> __declspec(dllimport) <span class="function"><span class="keyword">void</span> * <span class="title">objc_autoreleasePoolPush</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> __declspec(dllimport) <span class="function"><span class="keyword">void</span> <span class="title">objc_autoreleasePoolPop</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">AtAutoreleasePool</span> &#123;</span></span><br><span class="line">  __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125;</span><br><span class="line">  ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125;</span><br><span class="line">  <span class="keyword">void</span> * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __OFFSETOFIVAR__(TYPE, MEMBER) ((long long) &amp;((TYPE *)0)-&gt;MEMBER)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述重写代码表现可以看出，单个<code>autoreleasepool</code>的运行过程可以简单地理解为<code>objc_autoreleasePoolPush()</code> 、<code>[obj release]</code>和<code>objc_autoreleasePoolPop(void *)</code>三个过程。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章、runtime相关</title>
      <link href="/2019/07/28/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%81runtime%E7%9B%B8%E5%85%B3/"/>
      <url>/2019/07/28/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%81runtime%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="一、objc中向一个对象发送消息-obj-foo-和objc-msgSend-函数之间有什么关系？"><a href="#一、objc中向一个对象发送消息-obj-foo-和objc-msgSend-函数之间有什么关系？" class="headerlink" title="一、objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？"></a>一、objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？</h2><p><code>objc_msgSend()</code>是<code>[obj foo]</code>的具体实现。<br>在runtime中，<code>objc_msgSend()</code>是一个c函数，<code>[obj foo]</code>会被翻译成这样的形式<code>objc_msgSend(obj, foo)</code>。</p><p>OC到C的转换过程分析：<code>[obj foo];</code>=&gt;<code>objc_msgSend(obj, @selector(foo));</code></p><h2 id="二、runtime简介"><a href="#二、runtime简介" class="headerlink" title="二、runtime简介"></a>二、runtime简介</h2><p>runtime简称运行时。OC就是运行时机制，其中最主要的是消息机制。对于C语言，函数的调用在编译的时候会决定调用哪个函数。对于OC的函数，属于动态调用过程，在编译的时候并不能决定真正调用哪个函数，只有在真正运行的时候才会根据函数的名称找到对应的函数来调用。</p><h2 id="三、说说什么是runtime"><a href="#三、说说什么是runtime" class="headerlink" title="三、说说什么是runtime"></a>三、说说什么是runtime</h2><p>1、OC是一个全动态语言，OC的一切都是基于runtime实现的。平时编写的OC代码，在程序运行过程中，其实最终都是转成了runtime的C语言代码，runtime算是OC的幕后工作者。<br>2、runtime是一套比较底层的纯C语言API，属于1个C语言库，包含了很多底层的C语言API。<br>3、runtimeAPI的实现是用C++开发的(源码中的实现文件都是mm)，是一套苹果开源的框架。</p><h2 id="四、runtime应用场景"><a href="#四、runtime应用场景" class="headerlink" title="四、runtime应用场景"></a>四、runtime应用场景</h2><p>1、动态交换两个方法的实现<br>2、动态添加属性<br>3、实现字典转模型的自动转换<br>4、动态添加方法<br>5、拦截并替换方法<br>6、实现<code>NSCoding</code>的自动归档和解档</p><h2 id="五、runtime函数的定义规则"><a href="#五、runtime函数的定义规则" class="headerlink" title="五、runtime函数的定义规则"></a>五、runtime函数的定义规则</h2><p>对对象进行操作的方法一般以<code>object_</code>开头<br>对类进行操作的方法一般以<code>class_</code>开头<br>对类或对象的方法进行操作的方法一般以<code>method_</code>开头<br>对成员变量进行操作的方法一般以<code>ivar_</code>开头<br>对属性进行操作的方法一般以<code>property_</code>开头开头<br>对协议进行操作的方法一般以<code>protocol_</code>开头</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三章、OC相关</title>
      <link href="/2019/07/27/%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81OC%E7%9B%B8%E5%85%B3/"/>
      <url>/2019/07/27/%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81OC%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="一、理解iOS中copy与mutablecopy"><a href="#一、理解iOS中copy与mutablecopy" class="headerlink" title="一、理解iOS中copy与mutablecopy"></a>一、理解iOS中copy与mutablecopy</h2><p>1、<code>copy</code>出来的字符串一定是不可变字符串，如果传入的是可变字符串，会发生深拷贝为不可变字符串，否则为浅拷贝。<br>2、<code>mutablecopy</code>一定是深拷贝，拷贝出来的一定是可变字符串或者数组，即使传入的是不可变字符串或者数组。</p><h2 id="二、理解NSString使用copy修饰的原理"><a href="#二、理解NSString使用copy修饰的原理" class="headerlink" title="二、理解NSString使用copy修饰的原理"></a>二、理解NSString使用copy修饰的原理</h2><p>这个<code>NSString</code>类型属性是一个指针，定义成<code>copy</code>，操作是拷贝一份等同的对象，这个指针指向新生成的拷贝对象。当使用<code>copy</code>时，这个拷贝的对象无论是拷贝自<code>NSString</code>还是<code>NSMutableString</code>结果都是不可变的<code>NSString</code>。而如果用<code>strong</code>，则指向一个字符串对象，若指向的是一个<code>NSMutableString</code>，则当指向的对象改变时，属性值也会发生相应改变，导致错误，因为是一个不可变字符串。</p><p>更多理解请参考<a href="https://www.jianshu.com/p/eda4957735ee" target="_blank" rel="noopener">理解iOS中深浅拷贝-为什么NSString使用copy</a></p><h2 id="三、理解iOS中分类"><a href="#三、理解iOS中分类" class="headerlink" title="三、理解iOS中分类"></a>三、理解iOS中分类</h2><p>所有的OC类和对象，在<code>runtime</code>层都是用<code>struct</code>表示的，category也不例外，在<code>runtime</code>层，category用结构体<code>category_t</code>。<br>结构体的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">category_t</span> &#123;</span></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">char</span> *name;     <span class="comment">//类的名字（name）</span></span><br><span class="line">      <span class="keyword">classref_t</span> cls;       <span class="comment">//类（cls）</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">instanceMethods</span>;</span> <span class="comment">//category中所有给类添加的实例方法的列表（instanceMethods）</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">classMethods</span>;</span>  <span class="comment">//category中所有添加的类方法的列表（classMethods）</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span>  <span class="comment">//category实现的所有协议的列表（protocols）</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *<span class="title">instanceProperties</span>;</span>  <span class="comment">//category中添加的所有属性（instanceProperties）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从category的定义也可以看出category可以添加实例方法、类方法；可以遵守协议，添加属性；但无法添加实例变量。</p><p>注意，在category中可以有属性（<code>property</code>），但是该属性只是生成了<code>getter</code>和<code>setter</code>方法的声明，并没有产生对应的实现，更不会添加对应的实例变量。如果想为实例对象添加实例变量，可以尝试使用对象关联技术。</p><p>简单来说，由运行时决议，不同分类中含有同名分类方法，最后参与编译的最后生效。</p><h2 id="四、理解iOS属性关键字"><a href="#四、理解iOS属性关键字" class="headerlink" title="四、理解iOS属性关键字"></a>四、理解iOS属性关键字</h2><p>关键字的原理：<br>对一个属性来说，无非俩个操作，读和取，对应的就是<code>get</code>和<code>set</code>方法；通俗一点讲，这些关键字是底层约定的一些标签，当你上层对声明的属性加上这些关键字时，底层会根据不同的标签，在<code>get</code>和<code>set</code>方法中，执行不同的代码。</p><ul><li>nonatomic、atomic</li></ul><p>简单从词意上理解，<code>nonatomic</code>非原子的，<code>atomic</code>原子的。属性默认是<code>atomic</code>，也就是原子性的。这对CP，是用于区分在多线程下，属性读取策略。<br><code>atomic</code>：不受其他线程的影响，在<code>get</code>一个属性时，立马给这个属性在当前线程加一个锁，只有当<code>get</code>完成后，才会解锁，才会同步其他线程的<code>set</code>值。<br><code>nonatomic</code>：受线程影响，在<code>get</code>一个属性时，不管是否有其他线程执行<code>set</code>方法，只返回<code>get</code>结束时的<code>set</code>值。</p><p>从这也可以看出，<code>nonatomic</code>声明的属性，执行速率上是要更快一点的；其实<code>atomic</code>这个属性在上层代码中，其实非常不常用，因为很少会遇到存在同时，多个线程对一个属性<code>set</code>。</p><ul><li>readwrite、readonly</li></ul><p>简单理解，<code>readwrite</code>读写，<code>readonly</code>只读。属性默认是<code>readwrite</code>，支持读写。这对CP，是对<code>set</code>和<code>get</code>方法的一个总开关。<br><code>readwrite</code>：属性同时具有<code>set</code>和<code>get</code>方法。<br><code>readonly</code>：属性只具有<code>get</code>方法。</p><ul><li>strong、weak</li></ul><p><code>strong</code>是每对这个属性引用一次，<code>retainCount</code>就会+1，只能修饰<code>NSObject</code>对象，不能修饰基本数据类型。是id和对象的默认修饰符。<br><code>weak</code>对属性引用时，<code>retainCount</code>不变，只能修饰<code>NSObject</code>对象，不能修饰基本数据类型。主要用于避免循环引用。</p><ul><li>assign</li></ul><p>可以修饰基本数据类型和<code>NSObject</code>对象。<br>对这个关键字声明的属性操作时，<code>retainCount</code>是一直不变的，一直为1，只有主动调用<code>release</code>时，才会释放。</p><ul><li>copy</li></ul><p>类似<code>strong</code>，只能修饰<code>NSObject</code>对象，不能修饰基本数据类型。和<code>strong</code>不一样的地方是，<code>copy</code>后的对象，指针地址是和之前不一样的，也就是说重新分配了一块内存，也就是所谓的深拷贝。这个关键字在用的时候，因为涉及到申请新的内存空间，所以要少用。</p><p>另外要注意，<code>copy</code>修饰可变类型的属性时要小心，如<code>NSMutableArray、NSMutableDictionary、NSMutableString</code>，因为会容易造成crash。</p><ul><li>iOS9的几个新关键字（nonnull、nullable、null_resettable、<strong>null_unspecified 、</strong>kindof）</li></ul><p>1、<code>nonnull</code>：不能为空（用来修饰属性，或者方法的参数，方法的返回值）<br>2、<code>nullable</code>：表示可以为空<br>3、<code>null_resettable</code>：<code>get</code>不能返回空，<code>set</code>可以为空（注意：如果使用<code>null_resettable</code>，必须重写<code>get</code>方法或者<code>set</code>方法，处理传递的值为空的情况)）<br>4、<code>__null_unspecified</code>：不确定是否为空<br>5、<code>__kindof</code>：放在类型前面，表示修饰这个类型<code>(__kindofMyCustomClass*)</code>。表示当前类，也可以表示当前类的子类</p><h2 id="五、思考不用assign去声明对象的原因"><a href="#五、思考不用assign去声明对象的原因" class="headerlink" title="五、思考不用assign去声明对象的原因"></a>五、思考不用assign去声明对象的原因</h2><p>因为<code>assign</code>修饰的对象（一般编译的时候会产生警告：<code>Assigningretainedobjecttounsafeproperty;objectwillbereleasedafterassignment</code>）在释放之后，指针的地址还是存在的，也就是说指针并没有被置为nil，造成野指针。对象分配在堆上的某块内存，如果在后续的内存分配中，刚好分到了这块地址，程序就会crash。</p><h2 id="六、理解用assign修饰基本数据类型的原理"><a href="#六、理解用assign修饰基本数据类型的原理" class="headerlink" title="六、理解用assign修饰基本数据类型的原理"></a>六、理解用assign修饰基本数据类型的原理</h2><p>因为基础数据类型是分配在栈上，栈的内存会由系统自己自动处理回收，不会造成野指针。</p><h2 id="七、浅谈对category的理解"><a href="#七、浅谈对category的理解" class="headerlink" title="七、浅谈对category的理解"></a>七、浅谈对category的理解</h2><p>分类就是对一个类的功能进行扩展，让这个类能够适应不同情况的需求。在一般的实际开发中，我们都会对系统的一些常用类进行扩展，比如，<code>NSString，UIButton，UILabel</code>等，简单来说类别是一种为现有的类添加新方法的方式。</p><p>利用OC的动态运行时分配机制，<code>category</code>提供了一种比继承更为简洁的方法来对类进行扩展，无需创建对象类的子类就能为现有的类添加新的方法，可以为任何已经存在的类添加方法，包括系统框架<code>UIKit</code>等。</p><p>可以把类的实现分开在不同的文件里面，这样做的好处：<br>1、声明私有方法<br>2、分解体积庞大的类文件<br>3、把<code>framework</code>的私有方法公开</p><p>更多详情请参考<a href="https://www.jianshu.com/p/041ec360a3be" target="_blank" rel="noopener">iOS开发中category优点和缺点，作用</a>    </p><h2 id="八、关于给category添加成员变量问题的思考"><a href="#八、关于给category添加成员变量问题的思考" class="headerlink" title="八、关于给category添加成员变量问题的思考"></a>八、关于给category添加成员变量问题的思考</h2><p>不能直接添加成员变量，但是可以通过<code>runtime</code>的方式间接实现添加成员变量的效果。    </p><h2 id="九、iOS关联对象技术底层原理"><a href="#九、iOS关联对象技术底层原理" class="headerlink" title="九、iOS关联对象技术底层原理"></a>九、iOS关联对象技术底层原理</h2><p>首先可以了解熟悉一下主要使用的三个函数：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相当于 setValue:forKey 进行关联value对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_setAssociatedObject</span>(<span class="params">id <span class="keyword">object</span>, <span class="keyword">const</span> <span class="keyword">void</span> *key, id <span class="keyword">value</span>, objc_AssociationPolicy policy</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来读取对象</span></span><br><span class="line"><span class="function">id <span class="title">objc_getAssociatedObject</span>(<span class="params">id <span class="keyword">object</span>, <span class="keyword">const</span> <span class="keyword">void</span> *key</span>)</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数来移除一个关联对象，或者使用objc_setAssociatedObject函数将key指定的关联对象设置为nil。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_removeAssociatedObjects</span>(<span class="params">id <span class="keyword">object</span></span>)</span>;</span><br></pre></td></tr></table></figure><p>给分类添加属性的例子，给<code>NSObject</code>新增name属性：</p><p>1、声明</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">Property</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></span><br></pre></td></tr></table></figure><p>2、实现</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import <span class="string">"NSObject+Property.h"</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *key = <span class="string">"name"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">Property</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 根据关联的key，获取关联的值。</span></span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 第一个参数：给哪个对象添加关联</span></span><br><span class="line">    <span class="comment">// 第二个参数：关联的key，通过这个key获取</span></span><br><span class="line">    <span class="comment">// 第三个参数：关联的value</span></span><br><span class="line">    <span class="comment">// 第四个参数:关联的策略</span></span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, key, name, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>3、使用</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSObject *objc = [[NSObject alloc] init]<span class="comment">;</span></span><br><span class="line">objc.name = @<span class="string">"龙海家园4栋402"</span><span class="comment">;</span></span><br><span class="line">NSLog(@<span class="string">"%@"</span>,objc.name)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>更多详情请参考<a href="https://www.cnblogs.com/someonelikeyou/p/7162613.html" target="_blank" rel="noopener">iOS objc_setAssociatedObject 关联对象的学习</a></p><h2 id="十、理解iOS成员变量和实例变量以及类方法和实例方法"><a href="#十、理解iOS成员变量和实例变量以及类方法和实例方法" class="headerlink" title="十、理解iOS成员变量和实例变量以及类方法和实例方法"></a>十、理解iOS成员变量和实例变量以及类方法和实例方法</h2><ul><li>成员变量和实例变量</li></ul><p>在接口<code>@interface</code>括号里面的统称为成员变量，实例变量是成员变量中的一种。<br>实例变量：<br>除去基本数据类型<code>int、float</code>….等，其他类型的变量都叫做实例变量。<br>类的成员变量：<br>实例变量加上基本数据类型变量也就是类的成员变量。</p><ul><li>类方法和实例方法</li></ul><p>类方法简单的来说，就是静态方法，类名直接是可以调用的，实例方法是必须要构建对象之后，用对象来调用的。<br>类方法在堆上分配内存，实例方法在堆栈上。</p><p>总之，<br>1、实例方法里面的self，是对象的首地址。<br>2、类方法里面的self，是<code>Class</code>。</p><p>尽管在同一个类里面的使用self，但是self却有着不同的解读。在类方法里面的self，可以翻译成<code>class self</code>；在实例方法里面的self，应该被翻译成为<code>object self</code>。尽管他们的名字都叫self，在类方法里面的self和实例方法里面的self有着本质上的不同。</p><h2 id="十一、iOS中堆和栈的区别"><a href="#十一、iOS中堆和栈的区别" class="headerlink" title="十一、iOS中堆和栈的区别"></a>十一、iOS中堆和栈的区别</h2><p><strong>堆是先进先出，栈是先进后出</strong></p><p><code>Objective-C</code>对象所占内存总是分配在堆空间，并且堆内存是由开发者自己释放的，即<code>release</code>。栈是由编译器管理自动释放的，在方法中（函数体）定义的变量通常在栈内。</p><p>特点：<br>1、栈区(<code>stack</code>)：由编译器自动分配释放，存放函数的参数值，局部变量等值。其操作方式类似于数据结构中的栈。<br>2、堆区(<code>heap</code>)：一般由程序员分配释放，若程序员不释放，则可能会引起内存泄漏。注堆和数据结构中的堆栈不一样，其类似于链表。</p><p>栈是一个用来存储局部和临时变量的存储空间。在现代操作系统中，一个线程会分配一个栈。当一个函数被调用，一个<code>stack frame</code>(栈帧)就会被压到stack里。里面包含这个函数涉及的参数、局部变量、返回地址等相关信息。当函数返回后，这个栈帧就会被销毁。而这一切都是自动的，由系统帮我们进行分配与销毁。对于开发者来说，我们无须自己调度。</p><p>堆从本质上来说，程序中所有的一切都在内存中。在堆上，我们可以任何时候分配内存空间以及释放销毁它。你必须显示的请求在堆上分配内存空间，如果你不使用垃圾回收机制，你必须显示的去释放它。这就是在你的函数调用前需要完成的事情。简单来说，就是<code>malloc</code>与<code>free</code>。</p><p>通常以这种方式创建对象：<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSObject *obj = <span class="comment">[<span class="comment">[NSObject alloc]</span> init]</span>;</span><br></pre></td></tr></table></figure></p><p>系统会在栈上存储obj这个指针变量，它所指的对象在堆中。通过<code>[NSObject alloc]</code>系统会为其在堆中开辟一块内存空间，并为其生成<code>NSObject</code>所需内存结构布局。</p><ul><li>栈对象：</li></ul><p>优点：<br>1、高速，在栈上分配内存是非常快的。<br>2、简单，栈对象有自己的生命周期，你永远不可能发生内存泄露。因为总是在超出它的作用域时被自动销毁了。<br>缺点：<br>栈对象严格的定义了生命周期也是其主要的缺点，栈对象的生命周期不适于<code>Objective-C</code>的引用计数内存管理方法。<br>在<code>Objective-C</code>中只支持一个类型对象：Block。<br>关于在<code>Block</code>中的对象的生命周期问题。出现这问题的原因是，<code>Block</code>是新的对象，当你使用<code>Block</code>时候，如果你想对其保持引用，你需要对其进行<code>copy</code>操作，（从栈上<code>copy</code>到堆中，并返回一个指向他的指针），而不是对其进行<code>retain</code>操作。</p><ul><li>堆对象：</li></ul><p>优点：<br>可以自己控制对象的生命周期。<br>缺点：<br>需要程序员手动释放，容易造成内存泄漏。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章、UI视图相关</title>
      <link href="/2019/07/26/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E3%80%81UI%E8%A7%86%E5%9B%BE%E7%9B%B8%E5%85%B3/"/>
      <url>/2019/07/26/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E3%80%81UI%E8%A7%86%E5%9B%BE%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="一、UITableView相关的数据源同步问题，即如何在tableview解决多线程情况下，数据的处理？"><a href="#一、UITableView相关的数据源同步问题，即如何在tableview解决多线程情况下，数据的处理？" class="headerlink" title="一、UITableView相关的数据源同步问题，即如何在tableview解决多线程情况下，数据的处理？"></a>一、UITableView相关的数据源同步问题，即如何在tableview解决多线程情况下，数据的处理？</h2><p>1、并行访问，数据拷贝;<br>2、串行访问。</p><h2 id="二、是否遇到过卡顿和掉帧的问题，如何解决的，为什么出现卡顿和掉帧的问题"><a href="#二、是否遇到过卡顿和掉帧的问题，如何解决的，为什么出现卡顿和掉帧的问题" class="headerlink" title="二、是否遇到过卡顿和掉帧的问题，如何解决的，为什么出现卡顿和掉帧的问题"></a>二、是否遇到过卡顿和掉帧的问题，如何解决的，为什么出现卡顿和掉帧的问题</h2><p>首先卡顿是在规定的的16.7ms之内，下一帧sync信号到来之前，并没有CPU和GPU共同完成下一帧页面的合成，于是就会造成卡顿、掉帧。</p><p>滑动优化方案：<br>CPU：<br>1、处理对象的创建、调整、销毁工作<br>2、预排版（布局计算、文本计算）<br>3、预渲染（文本等异步绘制、图片解码等）</p><p>GPU：<br>1、纹理渲染<br>2、视图混合</p><h2 id="三、理解离屏渲染"><a href="#三、理解离屏渲染" class="headerlink" title="三、理解离屏渲染"></a>三、理解离屏渲染</h2><p>GPU屏幕渲染有以下两种方式：<br>1、当前屏幕渲染（<code>On-Screen Rendering</code>），指的是在当前屏幕缓冲区内进行渲染<br>2、离屏渲染（<code>Off-Screen Rendering</code>），指的是在当前屏幕缓冲区以外新开辟的一个缓冲区进行渲染操作</p><p>离屏渲染：<br>当我们处理图层的属性在被指定为未被预合成之前不能直接在屏幕上显示，就触发了离屏渲染，离屏渲染的概念起源于GPU层面，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。</p><h2 id="四、离屏渲染何时被触发？"><a href="#四、离屏渲染何时被触发？" class="headerlink" title="四、离屏渲染何时被触发？"></a>四、离屏渲染何时被触发？</h2><p>1、圆角（当和<code>maskToBounds</code>一起使用时，单独的圆角不触发）<br>2、图层蒙版<br>3、阴影<br>4、光栅化<br>5、渐变</p><p>特殊的离屏渲染：<br>CPU渲染，如果我们重写了<code>drawRect</code>方法，并且使用任何<code>Core Graphics</code>的技术进行了绘制操作，就涉及到了CPU渲染。整个渲染过程由CPU在App内同步地完成，渲染得到的Bitmap最后再交由GPU用于显示。</p><p>要尽量避免使用离屏渲染：<br>1、上下文切换，GPU需要额外的开销<br>2、创建新的渲染缓冲区，内存消耗</p><p>高级回答：<br>触发离屏渲染会增加GPU的工作量，而增加了GPU的工作量很有可能导致CPU和GPU的工作总耗时超过了16.67ms，从而造成页面的卡顿和掉帧。</p><h2 id="五、使UITableView滑动更流畅的方案或思路都哪些？"><a href="#五、使UITableView滑动更流畅的方案或思路都哪些？" class="headerlink" title="五、使UITableView滑动更流畅的方案或思路都哪些？"></a>五、使UITableView滑动更流畅的方案或思路都哪些？</h2><p>（1）复用单元格<br>（2）使用不透明的视图，单元格中少使用动画<br>（3）图片使用异步加载，设置图片加载的并发数<br>（4）滑动时不加载图片，停止滑动时再加载<br>（5）图片和文字可以直接drawRect<br>（6）如果cell是动态行高，计算缓存单元格高度<br>（7）尽量少<code>reloadData</code>，只用<code>reloadRowsAtIndexPaths</code><br>（8）cell高度固定直接用rowHeight属性设置高度</p><h2 id="六、CALayer与UIView有什么区别？"><a href="#六、CALayer与UIView有什么区别？" class="headerlink" title="六、CALayer与UIView有什么区别？"></a>六、CALayer与UIView有什么区别？</h2><p>（1）<code>UIView</code>是iOS系统中界面元素的继承。所有的界面元素都继承自它，他本身完全是由<code>CoreAnimation</code>来实现的。它真正的绘图部分，是由一个叫<code>CALayer</code>的类来管理。<code>UIView</code>本身更像是一个<code>CALayer</code>的管理器，访问它的跟绘图和跟坐标有关的属性，如<code>frame，bounds</code>等，实际上内部都是在访问它所包含的<code>CALayer</code>的相关属性。<br>（2）<code>UIView</code>有个layer属性，可以返回它的主<code>CALayer</code>实例，<code>UIView</code>有一个<code>layerClass</code>方法，返回主layer所使用的类，<code>UIView</code>的子类，可以通过重载这个方法，来让<code>UIView</code>使用不同的<code>CALayer</code>来显示。<br>（3）<code>UIView</code>的<code>CALayer</code>类似<code>UIView</code>的子View树形结构，也可以向它的layer上添加子layer。<br>（4）<code>CALayer</code>坐标系统与<code>UIView</code>有点不一样，它多了一个<code>anchorPoint</code>的属性。<br>（5）<code>UIView</code>的layer树形在系统内部，被系统维护着三份copy：逻辑树、动画树、显示树。<br>（6）<code>CALayer</code>默认修改属性支持隐式动画<br>（7）<code>UIView</code>可以接受并处理事件，<code>CALayer</code>不可以。</p><h2 id="七、简单说下UITableView、UIButton、UIWindow控件的继承关系"><a href="#七、简单说下UITableView、UIButton、UIWindow控件的继承关系" class="headerlink" title="七、简单说下UITableView、UIButton、UIWindow控件的继承关系"></a>七、简单说下UITableView、UIButton、UIWindow控件的继承关系</h2><p>（1）UITableView的继承关系：<br><code>UITableView-&gt;UIScrollView-&gt;UIView-&gt;UIResponder-&gt;NSObject</code><br>（2）UIButton的继承关系：<br><code>UIButton-&gt;UIControl-&gt;UIView-&gt;UIResponder-&gt;NSObject</code><br>（3）UIWindow的继承关系：<br><code>UIWindow-&gt;UIView-&gt;UIView-&gt;UIResponder-&gt;NSObject</code></p><h2 id="八、我们调用-UIView-setNeedsDisplay-方法的时候，不会立马发送对应视图的绘制工作，为什么？"><a href="#八、我们调用-UIView-setNeedsDisplay-方法的时候，不会立马发送对应视图的绘制工作，为什么？" class="headerlink" title="八、我们调用[UIView setNeedsDisplay]方法的时候，不会立马发送对应视图的绘制工作，为什么？"></a>八、我们调用<code>[UIView setNeedsDisplay]</code>方法的时候，不会立马发送对应视图的绘制工作，为什么？</h2><p>调用<code>[UIView setNeedsDisplay]</code>后，会调用系统的同名方法<code>[view.layer setNeedsDisplay]</code>方法在当前view上面打上一个脏标记。当前Runloop将要结束的时候才会调用<code>[CALayer display]</code>方法，然后进入到视图真正的绘制工作当中。</p><h2 id="九、是否知道异步绘制？如何进行异步绘制？"><a href="#九、是否知道异步绘制？如何进行异步绘制？" class="headerlink" title="九、是否知道异步绘制？如何进行异步绘制？"></a>九、是否知道异步绘制？如何进行异步绘制？</h2><p>基于系统开的口子<code>[layer.delegate displayLayer:]</code>方法。<br>如果实现/遵从了<code>dispayLayer</code>这个方法，我们就可以进行绘制。里面需要做：<br>1）代理负责生产对应的Bitmap<br>2）设置bitmap作为<code>layer.contents</code>属性的值</p><h2 id="十、UITableViewCell的重用机制描述一下"><a href="#十、UITableViewCell的重用机制描述一下" class="headerlink" title="十、UITableViewCell的重用机制描述一下"></a>十、UITableViewCell的重用机制描述一下</h2><p>在开发过程中，<br><code>- (nullable __kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier;</code><br><code>- (__kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier forIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(6_0);</code><br>有这两个方法调起UITableViewCell的重用机制，在tableView新建的时候，会新建一个复用池，这个复用池在OC底层可能是一个队列，保存着当前cell.pool中的复用标识符就是<code>reuseIdentifier</code>，标识着不同种类的cell，所以当我们调用<code>dequeueReusableCellWithIdentifier</code>时，会通过当前<code>reuseIdentifier</code>查找到对应的cell，也就是展示的原型。</p><p>在创建tableView的时候，会创建一个空的复用池，然后在tableView内部对pool进行管理，一般有两种用法，一种是取出一个空的cell的时候再去创建新的cell，另外一种是预先注册cell，之后再直接从复用池取出来用，不需要初始化。</p><p>对于第一种用法：第一次调用<code>tableView:cellForRowAtIndexPath</code>由于复用池是空的，会首先创建cell添加到复用池中，第二次调用，当前复用池中有一个cell，这时候因为tableView上面还未填满，而且复用池的唯一的那个cell已经在使用了，所以取出来的cell仍然为nil，于是继续新建一个cell并返回，复用池再添加一个cell，当前复用池中cell的个数为2。假如当前tableView只能容纳5个cell。那么在滚动到第6个cell时，从tableView的复用池取出来的cell将会是第0行的那个cell。以此类推，当滚动到第7行时，会从复用池取出来第1行的那个cell。 另外，此时不再继续往复用池添加新的cell。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章、底层相关</title>
      <link href="/2019/07/26/%E7%AC%AC%E4%B8%80%E7%AB%A0%E3%80%81%E5%BA%95%E5%B1%82%E7%9B%B8%E5%85%B3/"/>
      <url>/2019/07/26/%E7%AC%AC%E4%B8%80%E7%AB%A0%E3%80%81%E5%BA%95%E5%B1%82%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="一、谈谈OC的反射弧机制"><a href="#一、谈谈OC的反射弧机制" class="headerlink" title="一、谈谈OC的反射弧机制"></a>一、谈谈OC的反射弧机制</h2><p>程序可以访问、检测和修改它本身状态或行为的一种能力。OC的反射机制，即在动态运行状态下可以构造任意一个类或对象，知道这个类的所有属性和方法。</p><h2 id="二、探索分析App启动时间优化问题"><a href="#二、探索分析App启动时间优化问题" class="headerlink" title="二、探索分析App启动时间优化问题"></a>二、探索分析App启动时间优化问题</h2><p>启动慢问题分析：<br>通过代码工程的设置<code>Product-&gt;Scheme-&gt;Edit Scheme-&gt;Run-&gt;Environment Variables</code> 设置：<code>key:DYLD_PRINT_STATISTICS value:1</code></p><p>时间分为两个部分：<br>main-pre：系统环境布局时间，创建进程，加载解析可执行文件(库加载，堆栈环境配置等等)<br>main：<code>从main</code>函数到第一个界面显示时间</p><p>启动慢的影响的主要因素：<br>1、库加载越多，启动越慢<br>2、<code>Objc</code>类越多，越慢<br>3、静态对象全局对象越多，启动越慢<br>4、<code>Objc</code>的<code>+load</code>越多，启动越慢</p><p>解决方法：<br>1、尽量避免过多使用<code>+load</code>方法，可以使用<code>+initlalize</code>替代。<br>在系统第一次使用到这个类的使用，才会使用到他的<code>+(void)initlalize</code>方法。<br>2、减少<code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</code>里面的操作，在启动页出现后再进行相关操作。<br>例如放到子线程中去执行</p><h2 id="三、点击-Run-之后发生了什么？"><a href="#三、点击-Run-之后发生了什么？" class="headerlink" title="三、点击 Run 之后发生了什么？"></a>三、点击 Run 之后发生了什么？</h2><p>简单来说，点击Run之后App进行编译、汇编、链接、代码签名以及启动执行等操作。</p><p>因为某些操作流程及其原理中在其它总结中做了相关的介绍说明。这里主要介绍代码签名以及启动执行。</p><ul><li>代码签名</li></ul><p>每次<code>build</code>之后，都会发现工程目录下多了一个<code>.app</code>文件。在<code>.app</code>目录中，有又一个叫<code>_CodeSignature</code>的子目录，这是一个plist文件，里面包含了程序的代码签名，你的程序一旦签名，就没有办法更改其中的任何东西，包括资源文件，可执行文件等，iOS系统会检查这个签名。<br>签名过程本身是由命令行工具<code>codesign</code>来完成的。如果你在Xcode中<code>build</code>一个应用，这个应用构建完成之后会自动调用<code>codesign</code>命令进行签名，这也是<code>link</code>之后的一个关键步骤。</p><ul><li>启动</li></ul><p>其实在启动过程中，<code>dyld</code>（动态链接器）起了很重要的作用，进行动态链接，进行符号和地址的一个绑定。</p><p><code>dyld</code>主要在启动过程中主要做了以下事情：<br>1、加载所依赖的<code>dylibs</code><br>2、Fix-ups：Rebase修正地址偏移，因为OSX和iOS搞了一个叫<code>ASLR</code>的东西来做地址偏移（随机化）来避免收到攻击<br>3、Fix-ups：Binding确定<code>Non-LazyPointer</code>地址，进行符号地址绑定。<br>4、ObjCruntime初始化：加载所有类<br>5、Initializers：执行<code>load方法</code>和<code>__attribute__((constructor))</code>修饰的函数</p><h2 id="四、请简述OC的编译过程。"><a href="#四、请简述OC的编译过程。" class="headerlink" title="四、请简述OC的编译过程。"></a>四、请简述OC的编译过程。</h2><p>高级编程语言想要成为可执行文件需要先编译为汇编语言再汇编为机器语言，机器语言也是计算机能够识别的唯一语言，但是OC并不能直接编译为汇编语言，而是要先转写为纯C语言再进行编译和汇编的操作，从OC到C语言的过渡就是由<code>runtime</code>来实现的。然而我们使用OC进行面向对象开发，而C语言更多的是面向过程开发，这就需要将面向对象的类转变为面向过程的结构体。</p><p>更多详情的过程：<br>iOS编译采用<code>Clang</code>作为编译器前端，<code>LLVM</code>作为编译器后端，编译器前端负责语法分析、语义分析，生成中间码<code>(LLVMIR)</code>，在这个过程中，会进行类型检查，如果发现错误或者警告会标注出来在哪一行；编译器后端会进行机器无关的代码优化，生成机器语言，并且进行机器相关的代码优化。</p><ul><li><code>Clang</code>的编译过程</li></ul><p>预处理<br>预处理器会处理源文件中的宏定义，将代码中的宏用其对应定义的具体内容进行替换，删除注释，展开头文件，产生<code>.i</code>文件。</p><p>词法分析<br>预处理完成了以后，开始词法分析，这里会把代码切成一个个Token，比如大小括号、等于号，还有字符串等。</p><p>语法分析<br>语法分析，在<code>Clang</code>中由<code>Parser</code>和<code>Sema</code>两个模块配合完成，验证语法是否正确，根据当前语言的语法，生成语意节点，并将所有节点组合成抽象语法树<code>AST</code>。</p><p>静态分析<br>一旦编译器把源码生成了抽象语法树，编译器可以对这棵树做分析处理，以找出代码中的错误，比如类型检查：即检查程序中是否有类型错误。例如：如果代码中给某个对象发送了一个消息，编译器会检查这个对象是否实现了这个消息（函数、方法）。此外，<code>Clang</code>对整个程序还做了其它更高级的一些分析，以确保程序没有错误。</p><p>类型检查<br>一般会把类型检查分为两类：动态的和静态的。动态的在运行时做检查，静态的在编译时做检查。以往，编写代码时可以向任意对象发送任何消息，在运行时，才会检查对象是否能够响应这些消息。由于只是在运行时做此类检查，所以叫做动态类型。</p><p>至于静态类型，是在编译时做检查。当在代码中使用<code>ARC</code>时，编译器在编译期间，会做许多的类型检查：因为编译器需要知道哪个对象该如何使用。</p><ul><li><code>LLVM</code>的编译过程</li></ul><p>目标代码的生成与优化<br>CodeGen负责将语法树<code>AST</code>丛顶至下遍历，翻译成<code>LLVMIR</code>中间码，<code>LLVMIR</code>中间码编译过程的前端的输出后端的输入。<br>编译器后端主要包括代码生成器、代码优化器。代码生成器将中间代码转换为目标代码，代码优化器主要是进行一些优化，比如删除多余指令，选择合适寻址方式等，如果开启了<code>Bitcode</code>苹果会做进一步的优化，有新的后端架构还是可以用这份优化过的<code>Bitcode</code>去生成。优化中间代码生成输出汇编代码，把之前的<code>.i</code>文件转换为汇编语言，产生<code>.s</code>文件</p><p>汇编<br>目标代码需要经过汇编器处理，把汇编语言文件转换为机器码文件，产生<code>.o</code>文件。</p><p>链接<br>链接又分为静态链接和动态链接。对<code>.o</code>文件中的对于其他的库的引用的地方进行引用，生成最后的可执行文件(同时也包括多个<code>.o</code>文件进行link)。</p><p>静态链接<br>在编译链接期间发挥作用，把目标文件和静态库一起链接形成可执行文件。</p><p>动态链接<br>链接过程推迟到运行时再进行。如果多个程序都用到了一个库，那么每个程序都要将其链接到可执行文件中，非常冗余，动态链接的话，多个程序可以共享同一段代码，不需要在磁盘上存多份拷贝，但是动态链接发生在启动或运行时，增加了启动时间，造成一些性能的影响。</p><p>静态库不方便升级，必须重新编译，动态库的升级更加方便。</p><h2 id="五、深入理解iOS开发中的Bitcode功能"><a href="#五、深入理解iOS开发中的Bitcode功能" class="headerlink" title="五、深入理解iOS开发中的Bitcode功能"></a>五、深入理解iOS开发中的Bitcode功能</h2><p><code>LLVM</code>是目前苹果采用的编译器工具链，<code>Bitcode</code>是<code>LLVM</code>编译器的中间代码的一种编码，<code>LLVM</code>的前端可以理解为<code>C/C++/OC/Swift</code>等编程语言，<code>LLVM</code>的后端可以理解为各个芯片平台上的汇编指令或者可执行机器指令数据，那么，<code>Bitcode</code>就是位于这两者直接的中间码。<code>LLVM</code>的编译工作原理是前端负责把项目程序源代码翻译成<code>Bitcode</code>中间码，然后再根据不同目标机器芯片平台转换为相应的汇编指令以及翻译为机器码。</p><p>这样设计就可以让<code>LLVM</code>成为了一个编译器架构，可以轻而易举的在<code>LLVM</code>架构之上发明新的语言(前端)，以及在<code>LLVM</code>架构下面支持新的CPU(后端)指令输出，虽然<code>Bitcode</code>仅仅只是一个中间码不能在任何平台上运行，但是它可以转化为任何被支持的CPU架构，包括现在还没被发明的CPU架构，也就是说现在打开<code>Bitcode</code>功能提交一个App到应用商店，以后如果苹果新出了一款手机并CPU也是全新设计的，在苹果后台服务器一样可以从这个App的<code>Bitcode</code>开始编译转化为新CPU上的可执行程序，可供新手机用户下载运行这个App。</p><p> 更多详情参考<a href="https://www.cnblogs.com/shaoting/p/6650897.html" target="_blank" rel="noopener">深入理解iOS开发中的Bitcode功能</a></p><h2 id="六、探寻OC对象的本质"><a href="#六、探寻OC对象的本质" class="headerlink" title="六、探寻OC对象的本质"></a>六、探寻OC对象的本质</h2><p>OC的对象结构都是通过基础<code>C\C++</code>的结构体实现的。我们通过创建OC文件及对象，并将OC文件转化为<code>C++</code>文件来探寻OC对象的本质。</p><p>转化为C语言其实就是一个结构体</p><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NSObject_IMPL</span> </span>&#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那么这个结构体占多大的内存空间呢，我们发现这个结构体只有一个成员，isa指针，而指针在64位架构中占8个字节。也就是说一个NSObjec对象所占用的内存是8个字节。但是我们发现<code>NSObject</code>对象中还有很多方法，那这些方法不占用内存空间吗？其实类的方法等也占用内存空间，但是这些方法所占用的存储空间并不在<code>NSObject</code>对象中。</p><p>为了探寻OC对象在内存中如何体现，我们来看下面一段代码</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSObject *objc = <span class="comment">[<span class="comment">[NSObject alloc]</span> init]</span>;</span><br></pre></td></tr></table></figure><p>上面一段代码在内存中如何体现的呢？上述一段代码中系统为<code>NSObject</code>对象分配8个字节的内存空间，用来存放一个成员isa指针。那么isa指针这个变量的地址就是结构体的地址，也就是<code>NSObject</code>对象的地址。<br>假设isa的地址为<code>0x100400110</code>，那么上述代码分配存储空间给<code>NSObject</code>对象，然后将存储空间的地址赋值给objc指针。objc存储的就是isa的地址。objc指向内存中<code>NSObject</code>对象地址，即指向内存中的结构体，也就是isa的位置。</p><h2 id="七、探寻Class的本质"><a href="#七、探寻Class的本质" class="headerlink" title="七、探寻Class的本质"></a>七、探寻Class的本质</h2><p>我们知道不管是类对象还是元类对象，类型都是<code>Class</code>，<code>class</code>和<code>mete-class</code>的底层都是<code>objc_class</code>结构体的指针，内存中就是结构体。</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Class</span> objectClass = [NSObject <span class="keyword">class</span>]<span class="comment">;        </span></span><br><span class="line"><span class="keyword">Class</span> objectMetaClass = object_getClass([NSObject <span class="keyword">class</span>])<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>点击Class来到内部，我们可以发现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> *<span class="title">Class</span>;</span></span><br></pre></td></tr></table></figure><p>Class对象其实是一个指向<code>objc_class</code>结构体的指针。因此我们可以说类对象或元类对象在内存中其实就是<code>objc_class</code>结构体。</p><p>我们来到<code>objc_class</code>内部，但是<code>OBJC2_UNAVAILABLE;</code>说明这些代码已经不在使用了。那么目前<code>objc_class</code>的结构是什么样的呢？通过objc源码中去查找<code>objc_class</code>结构体的内容。</p><p>发现这个结构体继承<code>objc_object</code>并且结构体内有一些函数，因为这是<code>c++</code>结构体，在c上做了扩展，因此结构体中可以包含函数。发现<code>objc_object</code>中有一个isa指针，那么<code>objc_class</code>继承<code>objc_object</code>，也就同样拥有一个isa指针。</p><p>简单点说，通过Runtime等源码知道，<code>class-&gt;objc_class-&gt;objc_object</code>。</p><p>更多详情请参考<a href="https://juejin.im/post/5ad210636fb9a028da7cf90c" target="_blank" rel="noopener">iOS底层原理总结 - 探寻Class的本质</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS自定义服务器下载安装ipa流程</title>
      <link href="/2019/04/25/iOS%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85ipa%E6%B5%81%E7%A8%8B/"/>
      <url>/2019/04/25/iOS%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85ipa%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h5 id="一、在码云https-gitee-com上新建一个项目，并命名testApp，需要注意的是一定要是public模式，得到工程仓库-https-gitee-com-1019459067-testApp"><a href="#一、在码云https-gitee-com上新建一个项目，并命名testApp，需要注意的是一定要是public模式，得到工程仓库-https-gitee-com-1019459067-testApp" class="headerlink" title="一、在码云https://gitee.com上新建一个项目，并命名testApp，需要注意的是一定要是public模式，得到工程仓库:https://gitee.com/1019459067/testApp"></a>一、在码云<a href="https://gitee.com" target="_blank" rel="noopener">https://gitee.com</a>上新建一个项目，并命名<code>testApp</code>，需要注意的是一定要是<code>public</code>模式，得到工程仓库:<a href="https://gitee.com/1019459067/testApp" target="_blank" rel="noopener">https://gitee.com/1019459067/testApp</a></h5><h5 id="二、新建iOS测试工程项目，并命名testApp"><a href="#二、新建iOS测试工程项目，并命名testApp" class="headerlink" title="二、新建iOS测试工程项目，并命名testApp"></a>二、新建iOS测试工程项目，并命名<code>testApp</code></h5><h5 id="三、将iOS项目打包，注意：这里为了测试方便，一定要采用Apple官方的打包模式。在进行到导出ipa的时候，进行到下一步时："><a href="#三、将iOS项目打包，注意：这里为了测试方便，一定要采用Apple官方的打包模式。在进行到导出ipa的时候，进行到下一步时：" class="headerlink" title="三、将iOS项目打包，注意：这里为了测试方便，一定要采用Apple官方的打包模式。在进行到导出ipa的时候，进行到下一步时："></a>三、将iOS项目打包，注意：这里为了测试方便，一定要采用Apple官方的打包模式。在进行到导出ipa的时候，进行到下一步时：</h5><p><img src="/2019/04/25/iOS自定义服务器下载安装ipa流程/001.png" alt></p><p>需要将图示部分选中，为了导出<code>manifest.plist</code>文件</p><h5 id="四、点击Next，接下来出现如下界面"><a href="#四、点击Next，接下来出现如下界面" class="headerlink" title="四、点击Next，接下来出现如下界面"></a>四、点击<code>Next</code>，接下来出现如下界面</h5><p><img src="/2019/04/25/iOS自定义服务器下载安装ipa流程/002.png" alt></p><p>因plist的链接要求一定是https的，而且必须是公网ssl。所以暂时填写之前仓库的地址，后续可以更新的。在网上听说<code>自签名及免费的https不可用</code>，这里楼主没有做测试，其实还是有的，只是屡战屡败而已~~~</p><h5 id="五、最后到处ipa，得到如下内容："><a href="#五、最后到处ipa，得到如下内容：" class="headerlink" title="五、最后到处ipa，得到如下内容："></a>五、最后到处ipa，得到如下内容：</h5><p><img src="/2019/04/25/iOS自定义服务器下载安装ipa流程/003.png" alt></p><p><code>manifest.plist</code>内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plist</span> <span class="attr">version</span>=<span class="string">"1.0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>items<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>assets<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>kind<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>software-package<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>url<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>https://gitee.com/1019459067/testApp<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>kind<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>display-image<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>url<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>https://gitee.com/1019459067/testApp<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>kind<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>full-size-image<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>url<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>https://gitee.com/1019459067/testApp<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>metadata<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>bundle-identifier<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>com.xwh.testApp<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>bundle-version<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>kind<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>software<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>title<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>testApp<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plist</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="六、接下来，将得到的manifest-plist上传至仓库中"><a href="#六、接下来，将得到的manifest-plist上传至仓库中" class="headerlink" title="六、接下来，将得到的manifest.plist上传至仓库中"></a>六、接下来，将得到的<code>manifest.plist</code>上传至<a href="https://gitee.com/1019459067/testApp" target="_blank" rel="noopener">仓库</a>中</h5><p>git命令：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">add</span> -A</span><br><span class="line">git commit -m <span class="string">"testApp"</span></span><br><span class="line">git <span class="keyword">push</span></span><br></pre></td></tr></table></figure><h5 id="七、获取manifest-plist下载链接："><a href="#七、获取manifest-plist下载链接：" class="headerlink" title="七、获取manifest.plist下载链接："></a>七、获取<code>manifest.plist</code>下载链接：</h5><p><img src="/2019/04/25/iOS自定义服务器下载安装ipa流程/004.png" alt></p><p><img src="/2019/04/25/iOS自定义服务器下载安装ipa流程/005.png" alt></p><p><img src="/2019/04/25/iOS自定义服务器下载安装ipa流程/006.png" alt></p><p>获取地址：<code>https://gitee.com/1019459067/testApp/raw/master/manifest.plist</code>，这个地址在下载ipa时会用到，而且非常重要!!!后续要用到</p><h5 id="八、在自己Mac电脑上搭建Apache服务器，此处可自行网上寻找教程"><a href="#八、在自己Mac电脑上搭建Apache服务器，此处可自行网上寻找教程" class="headerlink" title="八、在自己Mac电脑上搭建Apache服务器，此处可自行网上寻找教程"></a>八、在自己Mac电脑上搭建Apache服务器，此处可自行网上寻找教程</h5><p>在目录下<code>/Library/WebServer/Documents</code>新建文件夹<code>testApp</code></p><ul><li><p>1、将iOS工程导出的ipa放入 文件夹<code>testApp</code>中</p></li><li><p>2、在文件夹<code>testApp</code>中新建<code>index.html</code></p><p>  <code>index.html</code>中的内容如下：</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"title top-space"</span> <span class="attr">style</span>=<span class="string">"font-size: 50; text-align: center;"</span>&gt;</span>testApp<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"download_content top-space"</span> <span class="attr">style</span>=<span class="string">"text-align: center;"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"download_btn"</span> <span class="attr">style</span>=<span class="string">"font-size: 45; text-align: center;"</span> <span class="attr">href</span>=<span class="string">"itms-services://?action=download-manifest&amp;url=https://gitee.com/1019459067/testApp/raw/master/manifest.plist"</span>&gt;</span>download<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果图如下：</p><p><img src="/2019/04/25/iOS自定义服务器下载安装ipa流程/007.png" alt></p><h5 id="九、获取testApp-ipa下载链接"><a href="#九、获取testApp-ipa下载链接" class="headerlink" title="九、获取testApp.ipa下载链接"></a>九、获取<code>testApp.ipa</code>下载链接</h5><p>根据第8步可以获取<code>testApp.ipa</code>地址为：<code>http://172.20.108.15/testApp/testApp.ipa</code></p><h5 id="十、更新仓库中manifest-plist的内容"><a href="#十、更新仓库中manifest-plist的内容" class="headerlink" title="十、更新仓库中manifest.plist的内容"></a>十、更新仓库中<code>manifest.plist</code>的内容</h5><p>将第8步中的    <code>http://172.20.108.15/testApp/testApp.ipa</code> 更新到</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>kind<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>software-package<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>url<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>http://172.20.108.15/testApp/testApp.ipa<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注： <code>manifest.plist</code>中的图片可以自行更新。</p><h5 id="十一、可以进行App下载了-在手机浏览器上访问"><a href="#十一、可以进行App下载了-在手机浏览器上访问" class="headerlink" title="十一、可以进行App下载了.在手机浏览器上访问"></a>十一、可以进行App下载了.在手机浏览器上访问</h5><p><code>http://172.20.108.15/testApp/index.html</code></p><p><img src="/2019/04/25/iOS自定义服务器下载安装ipa流程/008.png" alt></p><p>————恭喜已经完成了整个教程!!!去浪你个儿浪吧————</p>]]></content>
      
      
      <categories>
          
          <category> 基本技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> ipa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac上搭建基于Python的Flask服务</title>
      <link href="/2019/04/04/Mac%E4%B8%8A%E6%90%AD%E5%BB%BA%E5%9F%BA%E4%BA%8EPython%E7%9A%84Flask%E6%9C%8D%E5%8A%A1/"/>
      <url>/2019/04/04/Mac%E4%B8%8A%E6%90%AD%E5%BB%BA%E5%9F%BA%E4%BA%8EPython%E7%9A%84Flask%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="一、环境要求"><a href="#一、环境要求" class="headerlink" title="一、环境要求"></a>一、环境要求</h2><ul><li>macOS Mojave 10.14.2</li><li>Python 2.7.15</li><li>pip 18.0</li><li>Flask 1.0.2</li></ul><h2 id="二、背景"><a href="#二、背景" class="headerlink" title="二、背景"></a>二、背景</h2><p>Flask<a href="http://docs.jinkan.org/docs/flask/" target="_blank" rel="noopener">（官网地址）</a>是一个使用<code>Python</code>编写的轻量级<code>Web应用框架</code>。其<code>WSGI</code>工具箱采用<code>Werkzeug</code>，模板引擎则使用<code>Jinja2</code>，使用 BSD 授权。<br>Flask也被称为“microframework”，因为它使用简单的核心，用<code>extension</code>增加其他功能。Flask没有默认使用的数据库、窗体验证工具。然而，Flask保留了扩增的弹性，可以用Flask-extension加入这些功能：</p><ul><li>ORM；</li><li>窗体验证工具；</li><li>文件上传；</li><li>各种开放式身份验证技术。</li></ul><p>最新版本为1.0.2。</p><h2 id="三、安装"><a href="#三、安装" class="headerlink" title="三、安装"></a>三、安装</h2><p>一般情况下，Mac系统头自带Python 2.7的环境，直接输入命令安装就行。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ pip <span class="keyword">install</span> flask</span><br></pre></td></tr></table></figure><p>安装成功输出结果如下：</p><p><img src="/2019/04/04/Mac上搭建基于Python的Flask服务/001.jpg" alt></p><p>检测是否安装成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ flask</span><br></pre></td></tr></table></figure><p>输出如下：</p><p><img src="/2019/04/04/Mac上搭建基于Python的Flask服务/002.jpg" alt></p><h2 id="四、使用"><a href="#四、使用" class="headerlink" title="四、使用"></a>四、使用</h2><h4 id="1、创建一个新的文件夹Flask"><a href="#1、创建一个新的文件夹Flask" class="headerlink" title="1、创建一个新的文件夹Flask"></a>1、创建一个新的文件夹<code>Flask</code></h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> Flask</span><br></pre></td></tr></table></figure><h4 id="2、进入Flask，新建一个文件hello-py，内容如下："><a href="#2、进入Flask，新建一个文件hello-py，内容如下：" class="headerlink" title="2、进入Flask，新建一个文件hello.py，内容如下："></a>2、进入<code>Flask</code>，新建一个文件<code>hello.py</code>，内容如下：</h4><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">app = Flask(__name_<span class="number">_</span>)</span><br><span class="line"> </span><br><span class="line">@app.route(<span class="string">'/'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Index Page'</span></span><br><span class="line"> </span><br><span class="line">@app.route(<span class="string">'/hello'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello, World'</span></span><br><span class="line"> </span><br><span class="line">@app.route(<span class="string">'/user/&lt;username&gt;'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_user_profile</span><span class="params">(username)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="comment"># show the user profile for that user</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'User %s'</span> % username</span><br><span class="line"> </span><br><span class="line">@app.route(<span class="string">'/post/&lt;int:post_id&gt;'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_post</span><span class="params">(post_id)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="comment"># show the post with the given id, the id is an integer</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Post %d'</span> % post_id</span><br><span class="line"> </span><br><span class="line">@app.route(<span class="string">'/buy'</span>, methods=[<span class="string">'POST'</span>])</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buy</span><span class="params">()</span></span><span class="symbol">:</span></span><br><span class="line">    stripe_token = request.form[<span class="string">'stripeToken'</span>]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name_<span class="number">_</span> == <span class="string">"__main__"</span><span class="symbol">:</span></span><br><span class="line">app.run()</span><br></pre></td></tr></table></figure><h4 id="3、回到到文件夹Flask所在的目录，执行以下命令启动服务："><a href="#3、回到到文件夹Flask所在的目录，执行以下命令启动服务：" class="headerlink" title="3、回到到文件夹Flask所在的目录，执行以下命令启动服务："></a>3、回到到文件夹<code>Flask</code>所在的目录，执行以下命令启动服务：</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  Flask git:(master) ✗ <span class="builtin-name">export</span> <span class="attribute">FLASK_APP</span>=hello.py</span><br><span class="line">➜  Flask git:(master) ✗ <span class="builtin-name">export</span> <span class="attribute">FLASK_DEBUG</span>=1</span><br><span class="line">➜  Flask git:(master) ✗ flask run</span><br></pre></td></tr></table></figure><p>成功后结果如下：</p><p><img src="/2019/04/04/Mac上搭建基于Python的Flask服务/003.jpg" alt></p><h4 id="4、打开浏览器访问：http-127-0-0-1-5000"><a href="#4、打开浏览器访问：http-127-0-0-1-5000" class="headerlink" title="4、打开浏览器访问：http://127.0.0.1:5000"></a>4、打开浏览器访问：<a href="http://127.0.0.1:5000" target="_blank" rel="noopener">http://127.0.0.1:5000</a></h4><p><img src="/2019/04/04/Mac上搭建基于Python的Flask服务/004.jpg" alt></p><p>说明安装启动成功。</p><p>其它访问测试如下：</p><ul><li>访问：<a href="http://127.0.0.1:5000" target="_blank" rel="noopener">http://127.0.0.1:5000</a>，我们会看到输出：Index Page</li><li>访问：<a href="http://127.0.0.1:5000/hello" target="_blank" rel="noopener">http://127.0.0.1:5000/hello</a>，会看到输出：Hello, World</li><li>访问：<a href="http://127.0.0.1:5000/user/微wx笑" target="_blank" rel="noopener">http://127.0.0.1:5000/user/微wx笑</a>， 会看到输出：User 微wx笑</li><li>访问：<a href="http://127.0.0.1:5000/buy" target="_blank" rel="noopener">http://127.0.0.1:5000/buy</a>，我们会收到提示：方法不支持</li></ul><h2 id="五、服务器对外可见"><a href="#五、服务器对外可见" class="headerlink" title="五、服务器对外可见"></a>五、服务器对外可见</h2><p>按上面运行服务器的方式，您将注意到服务器只能从您自己的计算机访问，而不能从网络中的任何其他计算机访问。<br>这是默认值，因为在调试模式下，应用程序的用户可以在计算机上执行任意的Python代码。如果禁用调试器或信任网络上的用户，则可以通过在命令行中添加–host = 0.0.0.0来使服务器公开可用：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flask <span class="builtin-name">run</span> <span class="attribute">--host</span>=0.0.0.0</span><br></pre></td></tr></table></figure><blockquote><p>注意：<br>第一次使用时会弹出提示，是否允许接入网络，点击<code>允许</code>即可。然后，即可以让局域网内的其他设备进行访问。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Flask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS安装WebDriverAgent及真机远程控制</title>
      <link href="/2019/04/03/iOS%E5%AE%89%E8%A3%85WebDriverAgent%E5%8F%8A%E7%9C%9F%E6%9C%BA%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
      <url>/2019/04/03/iOS%E5%AE%89%E8%A3%85WebDriverAgent%E5%8F%8A%E7%9C%9F%E6%9C%BA%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="一、测试环境要求"><a href="#一、测试环境要求" class="headerlink" title="一、测试环境要求"></a>一、测试环境要求</h2><ul><li>1、MacOS Mojava</li><li>2、Xcode Version 10.1 (10B61)</li><li>3、iPhone8 Plus - iOS11.0</li></ul><h2 id="二、具体步骤"><a href="#二、具体步骤" class="headerlink" title="二、具体步骤"></a>二、具体步骤</h2><h4 id="1、克隆WebDriverAgent"><a href="#1、克隆WebDriverAgent" class="headerlink" title="1、克隆WebDriverAgent"></a>1、克隆<code>WebDriverAgent</code></h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://github.com/facebook/WebDriverAgent.git</span><br></pre></td></tr></table></figure><h4 id="2、安装Carthage，Carthage是一个第三方包管理工具，使用npm打包响应的js文件"><a href="#2、安装Carthage，Carthage是一个第三方包管理工具，使用npm打包响应的js文件" class="headerlink" title="2、安装Carthage，Carthage是一个第三方包管理工具，使用npm打包响应的js文件"></a>2、安装<code>Carthage</code>，Carthage是一个第三方包管理工具，使用npm打包响应的js文件</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>carthage</span><br></pre></td></tr></table></figure><p>如果你的Mac没有安装<code>Carthage</code>，请先安装，不然引导脚本将无法执行完成。</p><h4 id="3、进入工程目录，运行引导脚本"><a href="#3、进入工程目录，运行引导脚本" class="headerlink" title="3、进入工程目录，运行引导脚本"></a>3、进入工程目录，运行引导脚本</h4><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  testing <span class="keyword">cd</span> WebDriverAgent </span><br><span class="line">➜  WebDriverAgent git:(master) ./Scripts/<span class="keyword">bootstrap</span>.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure><p>结果输出如下：</p><p><img src="/2019/04/03/iOS安装WebDriverAgent及真机远程控制/001.jpg" alt></p><p>至此项目初始化完成！</p><h2 id="三、配置证书"><a href="#三、配置证书" class="headerlink" title="三、配置证书"></a>三、配置证书</h2><h4 id="1、打开项目工程"><a href="#1、打开项目工程" class="headerlink" title="1、打开项目工程"></a>1、打开项目工程</h4><p><img src="/2019/04/03/iOS安装WebDriverAgent及真机远程控制/002.jpg" alt></p><h4 id="2、配置WebDriverAgentRunner这个target的证书，依次按下图执行"><a href="#2、配置WebDriverAgentRunner这个target的证书，依次按下图执行" class="headerlink" title="2、配置WebDriverAgentRunner这个target的证书，依次按下图执行"></a>2、配置<code>WebDriverAgentRunner</code>这个<code>target</code>的证书，依次按下图执行</h4><p><img src="/2019/04/03/iOS安装WebDriverAgent及真机远程控制/003.jpg" alt></p><blockquote><p>注意：<br>第三步中，使用个人免费或公司或企业版账户，都需要修改bundleid，默认的为<code>com.facebook.WebDriverAgentRunner</code>，在buildsetting中改成自己可用的即可。</p></blockquote><h2 id="四、运行并测试"><a href="#四、运行并测试" class="headerlink" title="四、运行并测试"></a>四、运行并测试</h2><p>按<code>Command+U</code>执行或点击Xcode菜单栏<code>Product</code>-&gt;<code>Test</code>进行测试</p><p><img src="/2019/04/03/iOS安装WebDriverAgent及真机远程控制/004.jpg" alt></p><p>运行成功后，在你的iOS设备上有一个<code>WebDriverAgent</code>，并且在Xcode控制台会打印一个IP地址<code>http://169.254.252.118:8100</code>，此时在你的iOS的浏览器输入这个ip，比如我的是<code>http://169.254.252.118:8100/status</code>，会显示一些json信息，说明此时已经安装并运行成功。</p><h2 id="五、查看结果"><a href="#五、查看结果" class="headerlink" title="五、查看结果"></a>五、查看结果</h2><h4 id="1、http-169-254-252-118-8100-status"><a href="#1、http-169-254-252-118-8100-status" class="headerlink" title="1、http://169.254.252.118:8100/status"></a>1、<a href="http://169.254.252.118:8100/status" target="_blank" rel="noopener">http://169.254.252.118:8100/status</a></h4><p><img src="/2019/04/03/iOS安装WebDriverAgent及真机远程控制/005.jpg" alt></p><h4 id="2、http-169-254-252-118-8100-inspector"><a href="#2、http-169-254-252-118-8100-inspector" class="headerlink" title="2、http://169.254.252.118:8100/inspector"></a>2、<a href="http://169.254.252.118:8100/inspector" target="_blank" rel="noopener">http://169.254.252.118:8100/inspector</a></h4><p><img src="/2019/04/03/iOS安装WebDriverAgent及真机远程控制/006.jpg" alt></p><h2 id="六、远程控制"><a href="#六、远程控制" class="headerlink" title="六、远程控制"></a>六、远程控制</h2><h4 id="1、背景"><a href="#1、背景" class="headerlink" title="1、背景"></a>1、背景</h4><p>考虑到简单稳定起见，并没有用到<a href="https://github.com/openstf/ios-minicap" target="_blank" rel="noopener">ios-minicap</a>这么高大上的项目。</p><p>当然，我这里也参考了<a href="https://github.com/yxys01/iOS_remote/blob/master/README_zh-cn.md" target="_blank" rel="noopener">iOS-remote使用指南</a>一文进行安装测试，但是在最后一步</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn tomcat7:<span class="keyword">run</span><span class="bash">-war</span></span><br></pre></td></tr></table></figure><p>的时候失败。</p><h4 id="2、原理"><a href="#2、原理" class="headerlink" title="2、原理"></a>2、原理</h4><p>因为是利用WDA，所以手机需要连接上一台Mac。然后利用WDA的截图接口，不停的截图，将获取到的屏幕截图，显示到网页上。然后捕获鼠标在网页上的点击，传递给WDA。</p><h4 id="3、wdaproxy安装"><a href="#3、wdaproxy安装" class="headerlink" title="3、wdaproxy安装"></a>3、<a href="https://github.com/openatx/wdaproxy" target="_blank" rel="noopener"><code>wdaproxy</code></a>安装</h4><p>更多详细的安装请参考项目中的<code>readme.md</code>。这里只做最简单的阐述。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">brew </span>install openatx/tap/wdaproxy</span><br></pre></td></tr></table></figure><p>安装成功结果如下，注意，需要到根目录下进行安装才能成功！</p><p><img src="/2019/04/03/iOS安装WebDriverAgent及真机远程控制/007.jpg" alt></p><h4 id="4、运行WDA"><a href="#4、运行WDA" class="headerlink" title="4、运行WDA"></a>4、运行<code>WDA</code></h4><p>回到<code>WebDriverAgent</code>工程的上级目录，运行以下命令：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>wdaproxy -W ../WebDriverAgent</span><br></pre></td></tr></table></figure><p>成功后的结果如下：</p><p><img src="/2019/04/03/iOS安装WebDriverAgent及真机远程控制/008.jpg" alt></p><p>第一次运行的时候，可能出现设备信任的问题，点击确认就可以了。刚刚在测试过程中，我试了好几次没有出现，然后重复执行了以下命令，好像就可以了。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>brew install openatx/tap/wdaproxy</span><br><span class="line"><span class="variable">$ </span>wdaproxy -W ../WebDriverAgent</span><br></pre></td></tr></table></figure><p>成功后，在浏览器中输入<a href="http://172.20.133.248:8100" target="_blank" rel="noopener">http://172.20.133.248:8100</a>。这个地址是在运行成功后终端找到的。</p><p><img src="/2019/04/03/iOS安装WebDriverAgent及真机远程控制/010.jpg" alt></p><h4 id="5、点击上图中的Remote，即可进行远程控制了。"><a href="#5、点击上图中的Remote，即可进行远程控制了。" class="headerlink" title="5、点击上图中的Remote，即可进行远程控制了。"></a>5、点击上图中的<code>Remote</code>，即可进行远程控制了。</h4><p><img src="/2019/04/03/iOS安装WebDriverAgent及真机远程控制/011.jpg" alt></p><p>到此为止教程结束。</p><blockquote><p>总结：<br>不过全程还是一台电脑通过USB连接一台iPhone进行所谓的远程控制。没有达到真正的一台PC控制多个设备的效果。更重要的目的，能通过Mac或PC进行无线远程操控，也没达到。不过，这里猜测一下，<a href="https://www.ztestin.com" target="_blank" rel="noopener">Testin云测 | 众测</a>在iOS上的远程测试也很有可能是采用这种方式进行的。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> WebDriverAgent </tag>
            
            <tag> wda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>上传Github的代码添加Cocoapods支持</title>
      <link href="/2019/03/24/%E4%B8%8A%E4%BC%A0Github%E7%9A%84%E4%BB%A3%E7%A0%81%E6%B7%BB%E5%8A%A0Cocoapods%E6%94%AF%E6%8C%81/"/>
      <url>/2019/03/24/%E4%B8%8A%E4%BC%A0Github%E7%9A%84%E4%BB%A3%E7%A0%81%E6%B7%BB%E5%8A%A0Cocoapods%E6%94%AF%E6%8C%81/</url>
      
        <content type="html"><![CDATA[<p>这里我将从最初的开始进行介绍，包括Github上创建项目已经上传项目，到最后的支持Cocoapods。这里主要以Objecte-C为例介绍。</p><h3 id="一、上传代码至GitHub"><a href="#一、上传代码至GitHub" class="headerlink" title="一、上传代码至GitHub"></a>一、上传代码至GitHub</h3><p>至于如何创建GitHub账号，请自行百度。</p><h5 id="1、首先我们打开github-com，然后创建自己的项目工程"><a href="#1、首先我们打开github-com，然后创建自己的项目工程" class="headerlink" title="1、首先我们打开github.com，然后创建自己的项目工程"></a>1、首先我们打开github.com，然后创建自己的项目工程</h5><p><img src="/2019/03/24/上传Github的代码添加Cocoapods支持/001.jpg" alt><br>这里注意那个MIT License，在后面添加Cocoapods支持的时候会用到（稍后介绍）。</p><h5 id="2、点击创建仓库，然后将仓库clone到本地"><a href="#2、点击创建仓库，然后将仓库clone到本地" class="headerlink" title="2、点击创建仓库，然后将仓库clone到本地"></a>2、点击创建仓库，然后将仓库clone到本地</h5><p><img src="/2019/03/24/上传Github的代码添加Cocoapods支持/002.jpg" alt></p><h5 id="3、将工程上传至仓库中"><a href="#3、将工程上传至仓库中" class="headerlink" title="3、将工程上传至仓库中"></a>3、将工程上传至仓库中</h5><p><img src="/2019/03/24/上传Github的代码添加Cocoapods支持/003.jpg" alt></p><p>这里的LICENSE就是刚才说的MIT License添加的文件。CameraDemo是示例工程，WHCamera就是提供给他人使用的库。<br>然后提交到Github就可以了。</p><h3 id="二、创建podspec文件"><a href="#二、创建podspec文件" class="headerlink" title="二、创建podspec文件"></a>二、创建podspec文件</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  <span class="selector-tag">CameraDemo</span> <span class="selector-tag">git</span><span class="selector-pseudo">:(master)</span> ✗ <span class="selector-tag">pod</span> <span class="selector-tag">spec</span> <span class="selector-tag">create</span> <span class="selector-tag">WHCamera</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">Specification</span> <span class="selector-tag">created</span> <span class="selector-tag">at</span> <span class="selector-tag">WHCamera</span><span class="selector-class">.podspec</span></span><br><span class="line">➜  <span class="selector-tag">CameraDemo</span> <span class="selector-tag">git</span><span class="selector-pseudo">:(master)</span> ✗ <span class="selector-tag">ls</span></span><br><span class="line"><span class="selector-tag">CameraDemo</span>           <span class="selector-tag">LICENSE</span>              <span class="selector-tag">WHCamera</span></span><br><span class="line"><span class="selector-tag">CameraDemo</span><span class="selector-class">.xcodeproj</span> <span class="selector-tag">README</span><span class="selector-class">.md</span>            <span class="selector-tag">WHCamera</span><span class="selector-class">.podspec</span></span><br></pre></td></tr></table></figure><p>此时在工程文件夹下也会多一个<code>WHCamera.podspec</code>文件。</p><h3 id="三、编辑podspec文件"><a href="#三、编辑podspec文件" class="headerlink" title="三、编辑podspec文件"></a>三、编辑podspec文件</h3><p>这里用Sublime Text打开并做了如下编辑。<a href="https://guides.cocoapods.org/syntax/podspec.html#specification" target="_blank" rel="noopener">关于podspec文件详解</a></p><p>这里我做的编辑更新如下：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Pod::Spec.new do |s|</span><br><span class="line">  s.<span class="attr">name</span>         = <span class="string">"WHCamera"</span></span><br><span class="line">  s.<span class="attr">version</span>      = <span class="string">"0.0.1"</span></span><br><span class="line">  s.<span class="attr">summary</span>      = <span class="string">"A Library for iOS to use for Camera."</span></span><br><span class="line">  s.<span class="attr">description</span>  = &lt;&lt;-DESC</span><br><span class="line">                    <span class="string">"基于Object-C的iOS纯原生API相机，高度集成，使用快捷简单。可快速集成使用。最低支持iOS7的系统。"</span></span><br><span class="line">                   DESC</span><br><span class="line">  s.<span class="attr">platform</span>     = :ios, <span class="string">"7.0"</span></span><br><span class="line">  s.<span class="attr">homepage</span>     = <span class="string">"https://github.com/1019459067/CameraDemo"</span></span><br><span class="line">  s.<span class="attr">license</span>      = <span class="string">"MIT"</span></span><br><span class="line">  s.<span class="attr">author</span>       = &#123; <span class="string">"xiaoweihua"</span> =&gt; <span class="string">"1019459067@qq.com"</span> &#125;</span><br><span class="line">  s.<span class="attr">source</span>       = &#123; :<span class="attr">git</span> =&gt; <span class="string">"https://github.com/1019459067/CameraDemo.git"</span>, :<span class="attr">tag</span> =&gt; <span class="string">"#&#123;s.version&#125;"</span> &#125;</span><br><span class="line">  s.<span class="attr">source_files</span>  = <span class="string">"WHCamera/*.&#123;h,m&#125;"</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="四、验证podspec文件"><a href="#四、验证podspec文件" class="headerlink" title="四、验证podspec文件"></a>四、验证podspec文件</h3><p>接下来执行下面的命令进行验证：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  CameraDemo <span class="symbol">git:</span>(master) ✗ pod <span class="class"><span class="keyword">lib</span> <span class="title">lint</span> <span class="title">WHCamera</span>.<span class="title">podspec</span></span></span><br></pre></td></tr></table></figure><p>成功的结果如下：</p><p><img src="/2019/03/24/上传Github的代码添加Cocoapods支持/004.jpg" alt></p><p>若失败则根据提示做对应修改，一开始我没有选定平台<code>s.platform = :ios, &quot;7.0&quot;</code>，所以一直报错。</p><h3 id="五、在Github上创建release版本"><a href="#五、在Github上创建release版本" class="headerlink" title="五、在Github上创建release版本"></a>五、在Github上创建release版本</h3><p><img src="/2019/03/24/上传Github的代码添加Cocoapods支持/005.jpg" alt><br><img src="/2019/03/24/上传Github的代码添加Cocoapods支持/006.jpg" alt><br><img src="/2019/03/24/上传Github的代码添加Cocoapods支持/007.jpg" alt></p><h3 id="六、注册CocoaPods账号"><a href="#六、注册CocoaPods账号" class="headerlink" title="六、注册CocoaPods账号"></a>六、注册CocoaPods账号</h3><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  CameraDemo git:(master) pod trunk register xxxxxx@qq.com <span class="string">'用户名'</span></span><br><span class="line">[!] Please verify the session <span class="keyword">by</span> clicking the link <span class="keyword">in</span> the verification email <span class="literal">that</span> has been sent <span class="keyword">to</span> xxxxxx@qq.com</span><br></pre></td></tr></table></figure><p>打开邮件中的链接, 这样就成功注册了Cocoapods账号。</p><p>检查是否创建成功的命令如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  CameraDemo gi<span class="variable">t:</span>(master) pod trunk <span class="keyword">me</span></span><br><span class="line">  - Name:     用户名</span><br><span class="line">  - Emai<span class="variable">l:</span>    xxxxxx@qq.<span class="keyword">com</span></span><br><span class="line">  - Since:    March <span class="number">24</span><span class="keyword">th</span>, <span class="number">08</span>:<span class="number">07</span></span><br><span class="line">  - Pod<span class="variable">s:</span>     None</span><br><span class="line">  - Session<span class="variable">s:</span></span><br><span class="line">    - March <span class="number">24</span><span class="keyword">th</span>, <span class="number">08</span>:<span class="number">07</span> - July <span class="number">30</span><span class="keyword">th</span>, <span class="number">08</span>:<span class="number">08</span>. IP: <span class="number">113.92</span>.<span class="number">152.160</span></span><br><span class="line">➜  CameraDemo gi<span class="variable">t:</span>(master)</span><br></pre></td></tr></table></figure><h3 id="七、上传代码到CocoaPods"><a href="#七、上传代码到CocoaPods" class="headerlink" title="七、上传代码到CocoaPods"></a>七、上传代码到CocoaPods</h3><p>首先检测文件格式的有效性：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  CameraDemo <span class="string">git:</span>(master) ✗ pod spec lint</span><br><span class="line"></span><br><span class="line"> -&gt; WHCamera (<span class="number">0.0</span><span class="number">.1</span>)</span><br><span class="line">    - NOTE  | <span class="string">xcodebuild:</span>  <span class="string">note:</span> Using <span class="keyword">new</span> build system</span><br><span class="line">    - NOTE  | [iOS] <span class="string">xcodebuild:</span>  <span class="string">note:</span> Planning build</span><br><span class="line">    - NOTE  | [iOS] <span class="string">xcodebuild:</span>  <span class="string">note:</span> Constructing build description</span><br><span class="line">    - NOTE  | [iOS] <span class="string">xcodebuild:</span>  <span class="string">warning:</span> Skipping code signing because the target does not have an Info.plist file. (<span class="keyword">in</span> target <span class="string">'App'</span>)</span><br><span class="line"></span><br><span class="line">Analyzed <span class="number">1</span> podspec.</span><br><span class="line"></span><br><span class="line">WHCamera.podspec passed validation.</span><br><span class="line"></span><br><span class="line">➜  CameraDemo <span class="string">git:</span>(master) ✗</span><br></pre></td></tr></table></figure><p>警告可以使用<code>--allow-warnings</code>忽略.</p><p>出现<code>passed validation</code>就说明通过验证了。然后执行：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod trunk <span class="built_in">push</span> WHCamera.podspec --allow-<span class="built_in">warnings</span></span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod trunk <span class="keyword">push</span></span><br></pre></td></tr></table></figure><p>成功的结果如下：<br><img src="/2019/03/24/上传Github的代码添加Cocoapods支持/008.jpg" alt></p><p>好像这个地方需要等待很长时间～～～</p><h3 id="八、检查上传是否成功"><a href="#八、检查上传是否成功" class="headerlink" title="八、检查上传是否成功"></a>八、检查上传是否成功</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">pod search WHCamera</span></span><br></pre></td></tr></table></figure><p>第一次搜索失败：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[!] Unable <span class="keyword">to</span> <span class="built_in">find</span> a pod <span class="keyword">with</span> <span class="built_in">name</span>, author, summary, <span class="built_in">or</span> description matching `WHCamera`</span><br></pre></td></tr></table></figure><p>如果搜索不到，建议删除本地的CocoaPods的搜索目录，执行以下命令：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  rm ~<span class="regexp">/Library/</span>Caches<span class="regexp">/CocoaPods/</span>search_index.json</span><br></pre></td></tr></table></figure><p><img src="/2019/03/24/上传Github的代码添加Cocoapods支持/009.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 基本技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
            <tag> Cocoapods </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac下使用免费实现内网穿透</title>
      <link href="/2019/01/27/Mac%E4%B8%8B%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
      <url>/2019/01/27/Mac%E4%B8%8B%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="一、环境"><a href="#一、环境" class="headerlink" title="一、环境"></a>一、环境</h1><p>MacOS Mojava(此条件非必须)</p><h1 id="二、ngrok"><a href="#二、ngrok" class="headerlink" title="二、ngrok"></a>二、<a href="https://ngrok.com/" target="_blank" rel="noopener">ngrok</a></h1><p>下载地址：<a href="https://ngrok.com/download" target="_blank" rel="noopener">https://ngrok.com/download</a><br><img src="/2019/01/27/Mac下使用免费实现内网穿透/001.png" alt></p><h1 id="三、使用"><a href="#三、使用" class="headerlink" title="三、使用"></a>三、使用</h1><p>1、下载之后直接解压得到 一个 ngrok 文件</p><p>2、直接终端运行<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ chmod <span class="keyword">a</span>+x ngrok</span><br></pre></td></tr></table></figure></p><p>即可修改权限。</p><p>3、开启服务<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ ./ngrok http <span class="string">localhost:</span><span class="number">8080</span></span><br></pre></td></tr></table></figure></p><p>4、结果如下：<br><img src="/2019/01/27/Mac下使用免费实现内网穿透/002.png" alt></p><p>5、http、https服务器即可通过手机4G网络访问：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span><span class="comment">//8dfccac4.ngrok.io</span></span><br><span class="line"><span class="symbol">https:</span><span class="comment">//8dfccac4.ngrok.io</span></span><br></pre></td></tr></table></figure></p><h1 id="四、问题"><a href="#四、问题" class="headerlink" title="四、问题"></a>四、问题</h1><p>需要主要的是！！！！➜ 必须开启web服务</p><p>若没开启出现如下错误：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**Failed to complete tunnel connection**</span></span><br><span class="line"></span><br><span class="line">The connection to [<span class="string">**https://8dfccac4.ngrok.io**</span>](<span class="link">https://8dfccac4.ngrok.io/</span>) was successfully tunneled to your ngrok client, but the client failed to establish a connection to the local address [<span class="string">**localhost:8080**</span>](<span class="link">http://localhost:8080/</span>).</span><br><span class="line"></span><br><span class="line">Make sure that a web service is running on [<span class="string">**localhost:8080**</span>](<span class="link">http://localhost:8080/</span>) and that it is a valid address.</span><br><span class="line"></span><br><span class="line">The error encountered was: <span class="strong">**dial tcp**</span> [<span class="strong">**::1**</span>]<span class="strong">**:8080: getsockopt: connection refused**</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 基本技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
            <tag> 内网穿透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS开发之基本算法</title>
      <link href="/2018/09/26/iOS%E5%BC%80%E5%8F%91%E4%B9%8B%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/"/>
      <url>/2018/09/26/iOS%E5%BC%80%E5%8F%91%E4%B9%8B%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h4 id="关于常有的算法罗列"><a href="#关于常有的算法罗列" class="headerlink" title="关于常有的算法罗列"></a>关于常有的算法罗列</h4><p><img src="/2018/09/26/iOS开发之基本算法/001.png" alt></p><h3 id="一、冒泡排序算法-Bubble-Sort"><a href="#一、冒泡排序算法-Bubble-Sort" class="headerlink" title="一、冒泡排序算法(Bubble Sort)"></a>一、冒泡排序算法(Bubble Sort)</h3><p>相邻元素进行比较，按照升序或者降序，交换两个相邻元素的位置，是一种“稳定排序算法”</p><h4 id="1、动图演示"><a href="#1、动图演示" class="headerlink" title="1、动图演示"></a>1、动图演示</h4><p><img src="/2018/09/26/iOS开发之基本算法/002.gif" alt></p><h4 id="2、算法步骤"><a href="#2、算法步骤" class="headerlink" title="2、算法步骤"></a>2、算法步骤</h4><blockquote><p>1、比较相邻的元素。如果第一个比第二个大，就交换他们两个。<br>2、对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。<br>3、针对所有的元素重复以上的步骤，除了最后一个。<br>4、持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p></blockquote><h4 id="3、OC代码示例"><a href="#3、OC代码示例" class="headerlink" title="3、OC代码示例"></a>3、OC代码示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)bubbleSortWithArray:(NSMutableArray *)<span class="built_in">array</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.count - <span class="number">1</span>; i++) &#123;</span><br><span class="line">         <span class="comment">//外层for循环控制循环次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">array</span>.count - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="comment">//内层for循环控制交换次数</span></span><br><span class="line">            <span class="keyword">if</span> ([<span class="built_in">array</span>[j] integerValue] &gt; [<span class="built_in">array</span>[j + <span class="number">1</span>] integerValue]) &#123;</span><br><span class="line">                [<span class="built_in">array</span> exchangeObjectAtIndex:j withObjectAtIndex:j + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、算法特点"><a href="#4、算法特点" class="headerlink" title="4、算法特点"></a>4、算法特点</h4><p>当输入的数据已经是正序时，最快；</p><p>当输入的数据已经是反序时，最慢。</p><h3 id="二、快速排序算法-quick-sort"><a href="#二、快速排序算法-quick-sort" class="headerlink" title="二、快速排序算法(quick sort)"></a>二、快速排序算法(quick sort)</h3><h4 id="1、动图演示-1"><a href="#1、动图演示-1" class="headerlink" title="1、动图演示"></a>1、动图演示</h4><p><img src="/2018/09/26/iOS开发之基本算法/003.gif" alt></p><h4 id="2、算法步骤-1"><a href="#2、算法步骤-1" class="headerlink" title="2、算法步骤"></a>2、算法步骤</h4><blockquote><p>1、从数列中挑出一个元素，称为 “基准”（pivot）；<br>2、重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；<br>3、递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</p></blockquote><p>递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p><h4 id="3、OC代码示例-1"><a href="#3、OC代码示例-1" class="headerlink" title="3、OC代码示例"></a>3、OC代码示例</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">- (void)quickSortArray:(NSMutableArray *)<span class="keyword">array</span></span><br><span class="line">            leftIndex:(NSInteger)left</span><br><span class="line">           rightIndex:(NSInteger)right &#123;</span><br><span class="line">   <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   NSInteger i = left;</span><br><span class="line">   NSInteger j = right;</span><br><span class="line">   <span class="comment">//记录基准数 pivoty</span></span><br><span class="line">   NSInteger key = [<span class="keyword">array</span>[i] integerValue];</span><br><span class="line">   <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">       <span class="comment">//首先从右边j开始查找(从最右边往左找)比基准数(key)小的值&lt;---</span></span><br><span class="line">       <span class="keyword">while</span> (i &lt; j &amp;&amp; key &lt;= [<span class="keyword">array</span>[j] integerValue]) &#123;</span><br><span class="line">           j--;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果从右边j开始查找的值[array[j] integerValue]比基准数小，则将查找的小值调换到i的位置</span></span><br><span class="line">       <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">           <span class="keyword">array</span>[i] = <span class="keyword">array</span>[j];</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//从i的右边往右查找到一个比基准数小的值时，就从i开始往后找比基准数大的值 ---&gt;</span></span><br><span class="line">       <span class="keyword">while</span> (i &lt; j &amp;&amp; [<span class="keyword">array</span>[i] integerValue] &lt;= key) &#123;</span><br><span class="line">           i++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果从i的右边往右查找的值[array[i] integerValue]比基准数大，则将查找的大值调换到j的位置</span></span><br><span class="line">       <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">           <span class="keyword">array</span>[j] = <span class="keyword">array</span>[i];</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//将基准数放到正确的位置，----改变的是基准值的位置(数组下标)---</span></span><br><span class="line">   <span class="keyword">array</span>[i] = @(key);</span><br><span class="line">   <span class="comment">//递归排序</span></span><br><span class="line">   <span class="comment">//将i左边的数重新排序</span></span><br><span class="line">   [<span class="keyword">self</span> quickSortArray:<span class="keyword">array</span> leftIndex:left rightIndex:i - <span class="number">1</span>];</span><br><span class="line">   <span class="comment">//将i右边的数重新排序</span></span><br><span class="line">   [<span class="keyword">self</span> quickSortArray:<span class="keyword">array</span> leftIndex:i + <span class="number">1</span> rightIndex:right];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、选择排序算法-select-sort"><a href="#三、选择排序算法-select-sort" class="headerlink" title="三、选择排序算法(select sort)"></a>三、选择排序算法(select sort)</h3><p>它是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间。</p><h4 id="选择排序算法一：-直接选择排序-straight-select-sort"><a href="#选择排序算法一：-直接选择排序-straight-select-sort" class="headerlink" title="选择排序算法一： 直接选择排序(straight select sort)"></a>选择排序算法一： 直接选择排序(straight select sort)</h4><h4 id="1、动图演示-2"><a href="#1、动图演示-2" class="headerlink" title="1、动图演示"></a>1、动图演示</h4><p><img src="/2018/09/26/iOS开发之基本算法/004.gif" alt></p><h4 id="2、算法步骤-2"><a href="#2、算法步骤-2" class="headerlink" title="2、算法步骤"></a>2、算法步骤</h4><blockquote><p>1、首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置<br>2、再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。<br>3、重复第二步，直到所有元素均排序完毕。</p></blockquote><h4 id="3、OC代码示例-2"><a href="#3、OC代码示例-2" class="headerlink" title="3、OC代码示例"></a>3、OC代码示例</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)selectSortWithArray:(NSMutableArray *)array &#123;</span><br><span class="line">    <span class="keyword">for</span> (int <span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; array.count; <span class="built_in">i</span>++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (int <span class="built_in">j</span> = <span class="built_in">i</span> + <span class="number">1</span>; <span class="built_in">j</span> &lt; array.count; <span class="built_in">j</span>++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[<span class="built_in">i</span>] &gt; array[<span class="built_in">j</span>]) &#123;</span><br><span class="line">                [array exchangeObjectAtIndex:<span class="built_in">i</span> withObjectAtIndex:<span class="built_in">j</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="选择排序算法二：-堆排序-heap-sort-涉及到完全二叉树的概念"><a href="#选择排序算法二：-堆排序-heap-sort-涉及到完全二叉树的概念" class="headerlink" title="选择排序算法二： 堆排序(heap sort 涉及到完全二叉树的概念)"></a>选择排序算法二： 堆排序(heap sort 涉及到完全二叉树的概念)</h4><h4 id="1、动图演示-3"><a href="#1、动图演示-3" class="headerlink" title="1、动图演示"></a>1、动图演示</h4><p><img src="/2018/09/26/iOS开发之基本算法/005.gif" alt></p><h4 id="2、算法步骤-3"><a href="#2、算法步骤-3" class="headerlink" title="2、算法步骤"></a>2、算法步骤</h4><blockquote><p>1、创建一个堆 H[0……n-1]；<br>2、把堆首（最大值）和堆尾互换；<br>3、把堆的尺寸缩小1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；<br>4、重复步骤2，直到堆的尺寸为 1。</p></blockquote><h4 id="3、OC代码示例-3"><a href="#3、OC代码示例-3" class="headerlink" title="3、OC代码示例"></a>3、OC代码示例</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)heapSortWithArray:(NSMutableArray *)<span class="keyword">array</span> &#123;</span><br><span class="line">    <span class="comment">//循环建立初始堆</span></span><br><span class="line">    <span class="built_in">for</span> (NSInteger i = <span class="keyword">array</span>.count * <span class="number">0.5</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        [self heapAdjustWithArray:<span class="keyword">array</span> parentIndex:i length:<span class="keyword">array</span>.count];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进行n-1次循环，完成排序</span></span><br><span class="line">    <span class="built_in">for</span> (NSInteger j = <span class="keyword">array</span>.count - <span class="number">1</span>; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">        <span class="comment">//最后一个元素和第一个元素进行交换</span></span><br><span class="line">        [<span class="keyword">array</span> exchangeObjectAtIndex:j withObjectAtIndex:<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//筛选R[0]结点，得到i-1个结点的堆</span></span><br><span class="line">        [self heapAdjustWithArray:<span class="keyword">array</span> parentIndex:<span class="number">0</span> length:j];</span><br><span class="line">        NSLog(@<span class="string">"第%ld趟:"</span>, <span class="keyword">array</span>.count - j);</span><br><span class="line">        [self printHeapSortResult:<span class="keyword">array</span> <span class="built_in">begin</span>:<span class="number">0</span> <span class="built_in">end</span>:<span class="keyword">array</span>.count - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)heapAdjustWithArray:(NSMutableArray *)<span class="keyword">array</span></span><br><span class="line">                parentIndex:(NSInteger)parentIndex</span><br><span class="line">                     length:(NSInteger)length &#123;</span><br><span class="line">    NSInteger temp = [<span class="keyword">array</span>[parentIndex] integerValue]; <span class="comment">//temp保存当前父结点</span></span><br><span class="line">    NSInteger child = <span class="number">2</span> * parentIndex + <span class="number">1</span>; <span class="comment">//先获得左孩子</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">while</span> (child &lt; length) &#123;</span><br><span class="line">        <span class="comment">//如果有右孩子结点，并且右孩子结点的值大于左孩子结点，则选取右孩子结点</span></span><br><span class="line">        <span class="built_in">if</span> (child + <span class="number">1</span> &lt; length &amp;&amp; [<span class="keyword">array</span>[child] integerValue] &lt; [<span class="keyword">array</span>[child + <span class="number">1</span>] integerValue]) &#123;</span><br><span class="line">            child++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果父结点的值已经大于孩子结点的值，则直接结束</span></span><br><span class="line">        <span class="built_in">if</span> (temp &gt;= [<span class="keyword">array</span>[child] integerValue]) &#123;</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//把孩子结点的值赋值给父结点</span></span><br><span class="line">        <span class="keyword">array</span>[parentIndex] = <span class="keyword">array</span>[child];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//选取孩子结点的左孩子结点，继续向下筛选</span></span><br><span class="line">        parentIndex = child;</span><br><span class="line">        child = <span class="number">2</span> * child + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">array</span>[parentIndex] = @(temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)printHeapSortResult:(NSMutableArray *)<span class="keyword">array</span></span><br><span class="line">                      <span class="built_in">begin</span>:(NSInteger)<span class="built_in">begin</span></span><br><span class="line">                        <span class="built_in">end</span>:(NSInteger)<span class="built_in">end</span> &#123;</span><br><span class="line">    <span class="built_in">for</span> (NSInteger i = <span class="number">0</span>; i &lt; <span class="built_in">begin</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">for</span> (NSInteger i = <span class="built_in">begin</span>; i &lt;= <span class="built_in">end</span>; i++) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印堆排序</span></span><br><span class="line">    NSLog(@<span class="string">"堆排序升序结果是---&gt;%@"</span>,<span class="keyword">array</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、插入排序-insert-sort"><a href="#四、插入排序-insert-sort" class="headerlink" title="四、插入排序(insert sort)"></a>四、插入排序(insert sort)</h3><p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><p>插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。</p><h4 id="1、动图演示-4"><a href="#1、动图演示-4" class="headerlink" title="1、动图演示"></a>1、动图演示</h4><p><img src="/2018/09/26/iOS开发之基本算法/006.gif" alt></p><h4 id="2、算法步骤-4"><a href="#2、算法步骤-4" class="headerlink" title="2、算法步骤"></a>2、算法步骤</h4><blockquote><p>1、将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。<br>2、从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面）</p></blockquote><h4 id="3、OC代码示例-4"><a href="#3、OC代码示例-4" class="headerlink" title="3、OC代码示例"></a>3、OC代码示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)insertSortWithArray:(NSMutableArray *)<span class="built_in">array</span> &#123;</span><br><span class="line">    NSInteger j;</span><br><span class="line">    <span class="keyword">for</span> (NSInteger i = <span class="number">1</span>; i &lt; <span class="built_in">array</span>.count; i++) &#123;</span><br><span class="line">        <span class="comment">//取出每一个待插入的数据，从array[1]开始查找</span></span><br><span class="line">        NSInteger temp = [<span class="built_in">array</span>[i] integerValue];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; temp &lt; [<span class="built_in">array</span>[j] integerValue]; j--) &#123;</span><br><span class="line">            <span class="comment">//如果之前的数比temp大，就将这个数往后移动一个位置，留出空来让temp插入，和整理扑克牌类似</span></span><br><span class="line">            [<span class="built_in">array</span>[j + <span class="number">1</span>]  integerValue] = [<span class="built_in">array</span>[j] integerValue]];</span><br><span class="line">            <span class="built_in">array</span>[j] = [NSNumber numberWithInteger:temp];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五、归并排序-merge-sort"><a href="#五、归并排序-merge-sort" class="headerlink" title="五、归并排序(merge sort)"></a>五、归并排序(merge sort)</h3><p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。007作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p><ul><li>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；</li><li>自下而上的迭代；</li></ul><p>在《数据结构与算法 JavaScript 描述》中，作者给出了自下而上的迭代方法。<br>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。</p><h4 id="1、动图演示-5"><a href="#1、动图演示-5" class="headerlink" title="1、动图演示"></a>1、动图演示</h4><p><img src="/2018/09/26/iOS开发之基本算法/007.gif" alt></p><h4 id="2、算法步骤-5"><a href="#2、算法步骤-5" class="headerlink" title="2、算法步骤"></a>2、算法步骤</h4><blockquote><p>1、申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；<br>2、设定两个指针，最初位置分别为两个已经排序序列的起始位置；<br>3、比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；<br>4、重复步骤 3 直到某一指针达到序列尾；<br>5、将另一序列剩下的所有元素直接复制到合并序列尾。</p></blockquote><h4 id="3、OC代码示例-5"><a href="#3、OC代码示例-5" class="headerlink" title="3、OC代码示例"></a>3、OC代码示例</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自顶向下的归并排序</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 递归使用归并排序,对array[left...right]的范围进行排序</span></span><br><span class="line"><span class="comment"> @param array 数组</span></span><br><span class="line"><span class="comment"> @param left 左边界</span></span><br><span class="line"><span class="comment"> @param right 右边界</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (void)mergeSortWithArray:(<span class="type">NSMutableArray</span> *)array</span><br><span class="line">                      <span class="keyword">left</span>:(<span class="type">NSInteger</span>)<span class="keyword">left</span></span><br><span class="line">                     <span class="keyword">right</span>:(<span class="type">NSInteger</span>)<span class="keyword">right</span> &#123;</span><br><span class="line">    <span class="comment">//判断递归到底的情况</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">left</span> &gt;= <span class="keyword">right</span>) &#123;</span><br><span class="line">        <span class="comment">//这时候只有一个元素或者是不存在的情况</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中间索引的位置</span></span><br><span class="line">    <span class="type">NSInteger</span> middle = (<span class="keyword">right</span> + <span class="keyword">left</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//对 left --- middle 区间的元素进行排序操作</span></span><br><span class="line">    [<span class="keyword">self</span> mergeSortWithArray:array <span class="keyword">left</span>:<span class="keyword">left</span> <span class="keyword">right</span>:middle];</span><br><span class="line">    <span class="comment">//对 middle + 1 ---- right 区间的元素进行排序操作</span></span><br><span class="line">    [<span class="keyword">self</span> mergeSortWithArray:array <span class="keyword">left</span>:middle + <span class="number">1</span> <span class="keyword">right</span>:<span class="keyword">right</span>];</span><br><span class="line">    <span class="comment">//两边排序完成后进行归并操作</span></span><br><span class="line">    [<span class="keyword">self</span> mergeSortWithArray:array <span class="keyword">left</span>:<span class="keyword">left</span> middle:middle <span class="keyword">right</span>:<span class="keyword">right</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 对 [left middle] 和 [middle + 1 right]这两个区间归并操作</span></span><br><span class="line"><span class="comment"> @param array 传入的数组</span></span><br><span class="line"><span class="comment"> @param left 左边界</span></span><br><span class="line"><span class="comment"> @param middle 中间位置</span></span><br><span class="line"><span class="comment"> @param right 右边界</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (void)mergeSortWithArray:(<span class="type">NSMutableArray</span> *)array</span><br><span class="line">                      <span class="keyword">left</span>:(<span class="type">NSInteger</span>)<span class="keyword">left</span></span><br><span class="line">                    middle:(<span class="type">NSInteger</span>)middle</span><br><span class="line">                     <span class="keyword">right</span>:(<span class="type">NSInteger</span>)<span class="keyword">right</span> &#123;</span><br><span class="line">    <span class="comment">//拷贝一个数组出来</span></span><br><span class="line">    <span class="type">NSMutableArray</span> *copyArray = [<span class="type">NSMutableArray</span> arrayWithCapacity:<span class="keyword">right</span> - <span class="keyword">left</span> + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">NSInteger</span> i = <span class="keyword">left</span>; i &lt;= <span class="keyword">right</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//这里要注意有left的偏移量，所以copyArray赋值的时候要减去left</span></span><br><span class="line">        copyArray[i - <span class="keyword">left</span>] = array[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">NSInteger</span> i = <span class="keyword">left</span>, j = middle + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//循环从left开始到right区间内给数组重新赋值，注意赋值的时候也是从left开始的，不要习惯写成了从0开始，还有都是闭区间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">NSInteger</span> k = <span class="keyword">left</span>; k &lt;= <span class="keyword">right</span>; k++) &#123;</span><br><span class="line">        <span class="comment">//当左边界超过中间点时 说明左半部分数组越界了 直接取右边部分的数组的第一个元素即可</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; middle) &#123;</span><br><span class="line">            <span class="comment">//给数组赋值 注意偏移量left 因为这里是从left开始的</span></span><br><span class="line">            array[k] = copyArray[j - <span class="keyword">left</span>];</span><br><span class="line">            <span class="comment">//索引++</span></span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; <span class="keyword">right</span>) &#123;<span class="comment">//当j大于右边的边界时证明有半部分数组越界了，直接取左半部分的第一个元素即可</span></span><br><span class="line">            array[k] = copyArray[i - <span class="keyword">left</span>];</span><br><span class="line">            <span class="comment">//索引++</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (copyArray[i - <span class="keyword">left</span>] &gt; copyArray[j - <span class="keyword">left</span>]) &#123;<span class="comment">//左右两半部分数组比较</span></span><br><span class="line">            <span class="comment">//当右半部分数组的第一个元素要小时 给数组赋值为右半部分的第一个元素</span></span><br><span class="line">            array[k] = copyArray[j - <span class="keyword">left</span>];</span><br><span class="line">            <span class="comment">//右半部分索引加1</span></span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//右半部分数组首元素大于左半部分数组首元素</span></span><br><span class="line">            array[k] = copyArray[i - <span class="keyword">left</span>];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六、希尔排序-shell-sort"><a href="#六、希尔排序-shell-sort" class="headerlink" title="六、希尔排序(shell sort)"></a>六、希尔排序(shell sort)</h3><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li></ul><p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p><h4 id="1、算法步骤"><a href="#1、算法步骤" class="headerlink" title="1、算法步骤"></a>1、算法步骤</h4><blockquote><p>1、选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1；</p><p>2、按增量序列个数 k，对序列进行 k 趟排序；</p><p>3、每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p></blockquote><h4 id="2、OC代码示例"><a href="#2、OC代码示例" class="headerlink" title="2、OC代码示例"></a>2、OC代码示例</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)shellAscendingOrderSort:(<span class="built_in">NSMutableArray</span> *)ascendingArr &#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *buckt = [<span class="keyword">self</span> createBucket];</span><br><span class="line">    <span class="built_in">NSNumber</span> *maxnumber = [<span class="keyword">self</span> listMaxItem:ascendingArr];</span><br><span class="line">    <span class="built_in">NSInteger</span> maxLength = numberLength(maxnumber);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> digit = <span class="number">1</span>; digit &lt;= maxLength; digit++) &#123;</span><br><span class="line">        <span class="comment">// 入桶</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSNumber</span> *item <span class="keyword">in</span> ascendingArr) &#123;</span><br><span class="line">            <span class="built_in">NSInteger</span> baseNumber = [<span class="keyword">self</span> fetchBaseNumber:item digit:digit];</span><br><span class="line">            <span class="built_in">NSMutableArray</span> *mutArray = buckt[baseNumber];</span><br><span class="line">            [mutArray addObject:item];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NSInteger</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buckt.count; i++) &#123;</span><br><span class="line">            <span class="built_in">NSMutableArray</span> *array = buckt[i];</span><br><span class="line">            <span class="keyword">while</span> (array.count != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">NSNumber</span> *number = [array objectAtIndex:<span class="number">0</span>];</span><br><span class="line">                ascendingArr[index] = number;</span><br><span class="line">                [array removeObjectAtIndex:<span class="number">0</span>];</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"希尔升序排序结果：%@"</span>, ascendingArr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSMutableArray</span> *)createBucket &#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *bucket = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; <span class="number">10</span>; index++) &#123;</span><br><span class="line">        <span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">        [bucket addObject:array];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bucket;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSNumber</span> *)listMaxItem:(<span class="built_in">NSArray</span> *)list &#123;</span><br><span class="line">    <span class="built_in">NSNumber</span> *maxNumber = list[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSNumber</span> *number <span class="keyword">in</span> list) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([maxNumber integerValue] &lt; [number integerValue]) &#123;</span><br><span class="line">            maxNumber = number;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxNumber;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSInteger</span> numberLength(<span class="built_in">NSNumber</span> *number) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *string = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%ld"</span>, (<span class="keyword">long</span>)[number integerValue]];</span><br><span class="line">    <span class="keyword">return</span> string.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSInteger</span>)fetchBaseNumber:(<span class="built_in">NSNumber</span> *)number digit:(<span class="built_in">NSInteger</span>)digit &#123;</span><br><span class="line">    <span class="keyword">if</span> (digit &gt; <span class="number">0</span> &amp;&amp; digit &lt;= numberLength(number)) &#123;</span><br><span class="line">        <span class="built_in">NSMutableArray</span> *numbersArray = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">        <span class="built_in">NSString</span> *string = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%ld"</span>, [number integerValue]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; numberLength(number); index++) &#123;</span><br><span class="line">            [numbersArray addObject:[string substringWithRange:<span class="built_in">NSMakeRange</span>(index, <span class="number">1</span>)]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NSString</span> *str = numbersArray[numbersArray.count - digit];</span><br><span class="line">        <span class="keyword">return</span> [str integerValue];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="七、基数排序-radix-sort"><a href="#七、基数排序-radix-sort" class="headerlink" title="七、基数排序(radix sort)"></a>七、基数排序(radix sort)</h3><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p><h4 id="基数排序-vs-计数排序-vs-桶排序"><a href="#基数排序-vs-计数排序-vs-桶排序" class="headerlink" title="基数排序 vs 计数排序 vs 桶排序"></a>基数排序 vs 计数排序 vs 桶排序</h4><p>基数排序有两种方法：</p><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><ul><li>基数排序：根据键值的每位数字来分配桶；</li><li>计数排序：每个桶只存储单一键值；</li><li>桶排序：每个桶存储一定范围的数值；</li></ul><h4 id="1、动图演示-6"><a href="#1、动图演示-6" class="headerlink" title="1、动图演示"></a>1、动图演示</h4><p><img src="/2018/09/26/iOS开发之基本算法/008.gif" alt></p><h4 id="2、OC代码示例-1"><a href="#2、OC代码示例-1" class="headerlink" title="2、OC代码示例"></a>2、OC代码示例</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)radixAscendingOrderSort:(<span class="built_in">NSMutableArray</span> *)ascendingArr &#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *buckt = [<span class="keyword">self</span> createBucket];</span><br><span class="line">    <span class="built_in">NSNumber</span> *maxnumber = [<span class="keyword">self</span> listMaxItem:ascendingArr];</span><br><span class="line">    <span class="built_in">NSInteger</span> maxLength = numberLength(maxnumber);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> digit = <span class="number">1</span>; digit &lt;= maxLength; digit++) &#123;</span><br><span class="line">        <span class="comment">// 入桶</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSNumber</span> *item <span class="keyword">in</span> ascendingArr) &#123;</span><br><span class="line">            <span class="built_in">NSInteger</span> baseNumber = [<span class="keyword">self</span> fetchBaseNumber:item digit:digit];</span><br><span class="line">            <span class="built_in">NSMutableArray</span> *mutArray = buckt[baseNumber];</span><br><span class="line">            [mutArray addObject:item];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NSInteger</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buckt.count; i++) &#123;</span><br><span class="line">            <span class="built_in">NSMutableArray</span> *array = buckt[i];</span><br><span class="line">            <span class="keyword">while</span> (array.count != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">NSNumber</span> *number = [array objectAtIndex:<span class="number">0</span>];</span><br><span class="line">                ascendingArr[index] = number;</span><br><span class="line">                [array removeObjectAtIndex:<span class="number">0</span>];</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"基数升序排序结果：%@"</span>, ascendingArr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="八、计数排序-counting-sort"><a href="#八、计数排序-counting-sort" class="headerlink" title="八、计数排序(counting sort)"></a>八、计数排序(counting sort)</h3><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><h4 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="/2018/09/26/iOS开发之基本算法/009.gif" alt></p><h3 id="九、桶排序-bucket-sort"><a href="#九、桶排序-bucket-sort" class="headerlink" title="九、桶排序(bucket sort)"></a>九、桶排序(bucket sort)</h3><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</p><ul><li>在额外空间充足的情况下，尽量增大桶的数量</li><li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中</li></ul><p>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。</p><h4 id="算法特点"><a href="#算法特点" class="headerlink" title="算法特点"></a>算法特点</h4><p>当输入的数据可以均匀的分配到每一个桶中，最快；</p><p>当输入的数据被分配到了同一个桶中，最慢。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>（<a href="https://www.jianshu.com/p/77ba54a46ad7" target="_blank" rel="noopener">此篇文章主要是学习转载</a>）更多精彩细节，请查看收集的算法视频～～～</p><blockquote><p>链接: <a href="https://pan.baidu.com/s/1OA4Edl99wyL6cxwN97w8FA" target="_blank" rel="noopener">https://pan.baidu.com/s/1OA4Edl99wyL6cxwN97w8FA </a><br>提取码: yvty </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 基本算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS FFmpeg学习资料总结</title>
      <link href="/2018/08/16/iOS-FFmpeg%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%80%BB%E7%BB%93/"/>
      <url>/2018/08/16/iOS-FFmpeg%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h2><p>目标：安装ffmpeg-3.4.2（这里根据脚本自动安装的，可能不是目前最新版，需要的请自行更改脚步）</p><p>推荐一个非常好用的编译<a href="https://github.com/kewlbear/FFmpeg-iOS-build-script" target="_blank" rel="noopener">FFmpeg脚本</a>.</p><p>在终端cd到刚才下载的脚本，执行<code>./build-ffmpeg.sh</code>,如果你没安装Yasm不用担心，脚本会提示你，你只需要按照提示，脚本会自动帮你下载（这一步网上很多说要自己先安装，反正我是没有，按照脚本提示一步到位），可谓是一键式编译。</p><p>等待大概十几分钟。。。输出结果如下：</p><p>验证编译结果如下：</p><p><img src="/2018/08/16/iOS-FFmpeg学习资料总结/001.png" alt></p><p>在终端cd到FFmpeg-iOS里面的lib文件:</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lipo -info libavfilter.<span class="keyword">a</span></span><br><span class="line">Architectures <span class="keyword">in</span> <span class="keyword">the</span> fat <span class="built_in">file</span>: libavfilter.<span class="keyword">a</span> are: armv7 i386 x86_64 arm64</span><br></pre></td></tr></table></figure><p>说明：<br><code>armv7</code> <code>arm64</code> <code>i386</code> <code>x86_64</code>这些是什么，其实这些是处理器的指令集。</p><ul><li><code>armv7</code>、<code>arm64</code>是ARM处理器的指令集，真机所支持的架构。目前iOS主要支持<code>arm64</code>.</li><li><code>i386</code> 、<code>x86_64</code>是Mac系统处理器指令集，模拟器32位、64所支持的架构。</li></ul><h2 id="二、验证安装"><a href="#二、验证安装" class="headerlink" title="二、验证安装"></a>二、验证安装</h2><h3 id="1、环境"><a href="#1、环境" class="headerlink" title="1、环境"></a>1、环境</h3><p>Xcode：Version 9.4.1</p><p>MacOS High Sierra：Version 10.13.6</p><h3 id="2、配置"><a href="#2、配置" class="headerlink" title="2、配置"></a>2、配置</h3><p>新建Xcode工程命名FFmpegDemo，上面编译好的FFmpeg-iOS添加到工程里面。</p><p>a、设置头文件路径，<code>Header Search Paths</code>-&gt;<code>$(SRCROOT)/FFmpeg-iOS/include</code><br><img src="/2018/08/16/iOS-FFmpeg学习资料总结/002.png" alt><br>b、设置库文件路径，<code>Library Search Paths</code>-&gt;<code>$(PROJECT_DIR)/FFmpeg-iOS/lib</code><br><img src="/2018/08/16/iOS-FFmpeg学习资料总结/003.png" alt><br>c、配置缺失的库，主要包括<code>CoreMedia.framework</code>、<code>AudioToolbox.framework</code>、<code>VideoToolbox.framework</code>、<code>libiconv.tbd</code>、<code>libbz2.tbd、libz.tbd</code>。<br><img src="/2018/08/16/iOS-FFmpeg学习资料总结/004.png" alt><br>完成后结果分别如下：</p><h3 id="3、验证"><a href="#3、验证" class="headerlink" title="3、验证"></a>3、验证</h3><p>在<code>ViewController.m</code>中输入如下代码进行验证：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"><span class="meta">#include <span class="meta-string">&lt;libavcodec/avcodec.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></span><br><span class="line">    </span><br><span class="line">    printf(<span class="string">"%s"</span>,avcodec_configuration());</span><br><span class="line">    <span class="built_in">UILabel</span> *lab = [<span class="built_in">UILabel</span> new];</span><br><span class="line">    lab.text = [<span class="built_in">NSString</span> stringWithUTF8String:avcodec_configuration()];</span><br><span class="line">    lab.numberOfLines = <span class="number">0</span>;</span><br><span class="line">    lab.frame = <span class="keyword">self</span>.view.bounds;</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:lab];</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动运行程序，结果如下，说明配置成功。</p><p><img src="/2018/08/16/iOS-FFmpeg学习资料总结/005.png" alt></p><h2 id="三、视频播放器原理"><a href="#三、视频播放器原理" class="headerlink" title="三、视频播放器原理"></a>三、视频播放器原理</h2><p>这里主要参考<a href="https://www.jianshu.com/p/e4ab6fcc7742" target="_blank" rel="noopener">视频播放器原理及相关基础知识介绍</a>。</p><p>播放一个视频文件的流程如下：<br><img src="/2018/08/16/iOS-FFmpeg学习资料总结/006.png" alt></p><h4 id="1、封装格式的作用："><a href="#1、封装格式的作用：" class="headerlink" title="1、封装格式的作用："></a>1、封装格式的作用：</h4><p>视频码流和音频码流按照一定的格式存储在一个文件中。</p><p>MPEG2-TS和FLV格式简介：<br><img src="/2018/08/16/iOS-FFmpeg学习资料总结/007.png" alt></p><h4 id="2、封装格式："><a href="#2、封装格式：" class="headerlink" title="2、封装格式："></a>2、封装格式：</h4><p><img src="/2018/08/16/iOS-FFmpeg学习资料总结/008.png" alt></p><h4 id="3、H264格式简介以及压缩方法"><a href="#3、H264格式简介以及压缩方法" class="headerlink" title="3、H264格式简介以及压缩方法"></a>3、H264格式简介以及压缩方法</h4><ul><li>I:红色的帧，当作图片直接压缩。特点：</li></ul><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>它是一个全帧压缩编码帧。它将全帧图像信息进行JPEG压缩编码及传输;</span><br><span class="line"><span class="number">2.</span>解码时仅用I帧的数据就可重构完整图像;</span><br><span class="line"><span class="number">3.</span>I帧描述了图像背景和运动主体的详情;</span><br><span class="line"><span class="number">4.</span>I帧不需要参考其他画面而生成;</span><br><span class="line"><span class="number">5.</span>I帧是P帧和B帧的参考帧(其质量直接影响到同组中以后各帧的质量);</span><br><span class="line"><span class="number">6.</span>I帧是帧组GOP的基础帧(第一帧),在一组中只有一个I帧;</span><br><span class="line"><span class="number">7.</span>I帧不需要考虑运动矢量;</span><br><span class="line"><span class="number">8.</span>I帧所占数据的信息量比较大。</span><br></pre></td></tr></table></figure><ul><li>P:蓝色的帧。以I帧为参考帧。前向预测编码帧。</li></ul><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.<span class="keyword">P</span>帧是I帧后面相隔<span class="number">1</span>~<span class="number">2</span>帧的编码帧;</span><br><span class="line"><span class="number">2</span>.<span class="keyword">P</span>帧采用运动补偿的方法传送它与前面的I或<span class="keyword">P</span>帧的差值及运动矢量(预测误差);</span><br><span class="line"><span class="number">3</span>.解码时必须将I帧中的预测值与预测误差求和后才能重构完整的<span class="keyword">P</span>帧图像;</span><br><span class="line"><span class="number">4</span>.<span class="keyword">P</span>帧属于前向预测的帧间编码。它只参考前面最靠近它的I帧或<span class="keyword">P</span>帧;</span><br><span class="line"><span class="number">5</span>.<span class="keyword">P</span>帧可以是其后面<span class="keyword">P</span>帧的参考帧,也可以是其前后的B帧的参考帧;</span><br><span class="line"><span class="number">6</span>.由于<span class="keyword">P</span>帧是参考帧,它可能造成解码错误的扩散;</span><br><span class="line"><span class="number">7</span>.由于是差值传送,<span class="keyword">P</span>帧的压缩比较高。</span><br></pre></td></tr></table></figure><ul><li>B:绿色的帧.</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1<span class="selector-class">.B</span>帧是由前面的<span class="selector-tag">I</span>或<span class="selector-tag">P</span>帧和后面的<span class="selector-tag">P</span>帧来进行预测的;</span><br><span class="line">2<span class="selector-class">.B</span>帧传送的是它与前面的<span class="selector-tag">I</span>或<span class="selector-tag">P</span>帧和后面的<span class="selector-tag">P</span>帧之间的预测误差及运动矢量;</span><br><span class="line">3<span class="selector-class">.B</span>帧是双向预测编码帧;</span><br><span class="line">4<span class="selector-class">.B</span>帧压缩比最高,因为它只反映丙参考帧间运动主体的变化情况,预测比较准确;</span><br><span class="line">5<span class="selector-class">.B</span>帧不是参考帧,不会造成解码错误的扩散。</span><br></pre></td></tr></table></figure><h2 id="四、音频编码数据"><a href="#四、音频编码数据" class="headerlink" title="四、音频编码数据"></a>四、音频编码数据</h2><h4 id="1、音频编码的作用。"><a href="#1、音频编码的作用。" class="headerlink" title="1、音频编码的作用。"></a>1、音频编码的作用。</h4><p>将音频采集数据压缩成为音频码流，从而降低音频的数据量。</p><h4 id="2、音频格式"><a href="#2、音频格式" class="headerlink" title="2、音频格式"></a>2、音频格式</h4><p><img src="/2018/08/16/iOS-FFmpeg学习资料总结/009.png" alt></p><h4 id="3、ACC格式简介以及简介"><a href="#3、ACC格式简介以及简介" class="headerlink" title="3、ACC格式简介以及简介"></a>3、ACC格式简介以及简介</h4><p>数据由大小不固定的ADTS构成.压缩方法复杂，可以将音频数据压缩10倍以上.</p><h2 id="五、视频像素数据"><a href="#五、视频像素数据" class="headerlink" title="五、视频像素数据"></a>五、视频像素数据</h2><p>1、视频像素数据作用</p><p>保存了屏幕上每个像素点的像素值.</p><p>2、格式</p><p>RGB24、RGB32、YUV420P、YUV422P、YUV444P。常用的为YUV420P。</p><p>3、特点</p><p>体积很大。一般情况1小时高清视频的RGB24格式的数据体积为：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3600</span>*<span class="number">25</span>*<span class="number">1920</span>*<span class="number">1080</span>*<span class="number">3</span>=<span class="number">559</span>GByte</span><br></pre></td></tr></table></figure><p>PS:这里帧率为25Hz，取样精度8bit.</p><p>4、RGB格式简介</p><p><img src="/2018/08/16/iOS-FFmpeg学习资料总结/010.png" alt></p><p>5、YUV格式简介<br><img src="/2018/08/16/iOS-FFmpeg学习资料总结/011.png" alt></p><h2 id="六、音频采样数据"><a href="#六、音频采样数据" class="headerlink" title="六、音频采样数据"></a>六、音频采样数据</h2><p>1、音频采样数据作用</p><p>保存了音频中每个采样点的值。</p><p>2、特点</p><p>体积很大。一般情况一首4分钟的PCM格式的歌曲体积为：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span>*<span class="number">60</span>*<span class="number">44100</span>*<span class="number">2</span>*<span class="number">2</span>=<span class="number">42.3</span>MByte</span><br></pre></td></tr></table></figure><p>PS:假定采样率为44100Hz，采样精度为16bit.</p><h2 id="七、视频解码知识"><a href="#七、视频解码知识" class="headerlink" title="七、视频解码知识"></a>七、视频解码知识</h2><p>1、纯净的视频解码流程</p><ul><li>压缩编码数据-&gt;像素数据</li><li>例如解码H.264，就是“H.264-&gt;YUV”</li></ul><p>2、一般的视频解码流程</p><ul><li>视频码流一般存储在一定的封装格式中。封装格式中通常还包含音频码流等内容。</li><li>对于封装格式中的视频，需要先从封装的格式中的提取视频码流，然后在进行解码。</li><li>例如解码MKV格式的视频文件，就是“MKV-&gt;H.264码流-&gt;YUV”。</li></ul><h2 id="八、FFmpeg解码的函数"><a href="#八、FFmpeg解码的函数" class="headerlink" title="八、FFmpeg解码的函数"></a>八、FFmpeg解码的函数</h2><p>1、FFmpeg解码的流程图如下所示：<br><img src="/2018/08/16/iOS-FFmpeg学习资料总结/012.png" alt></p><p>2、FFmpeg解码函数简介<br><img src="/2018/08/16/iOS-FFmpeg学习资料总结/013.png" alt></p><p>3、FFmpeg解码的数据结构<br><img src="/2018/08/16/iOS-FFmpeg学习资料总结/014.png" alt></p><p>4、FFmpeg数据结构分析<br><img src="/2018/08/16/iOS-FFmpeg学习资料总结/015.png" alt><br><img src="/2018/08/16/iOS-FFmpeg学习资料总结/016.png" alt><br><img src="/2018/08/16/iOS-FFmpeg学习资料总结/017.png" alt></p><p>5、解码后的数据为什么要经过sws_scale()函数处理？<br><img src="/2018/08/16/iOS-FFmpeg学习资料总结/018.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> FFmpeg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS逆向之移除Oplayer lite广告</title>
      <link href="/2018/08/06/iOS%E9%80%86%E5%90%91%E4%B9%8B%E7%A7%BB%E9%99%A4Oplayer-lite%E5%B9%BF%E5%91%8A/"/>
      <url>/2018/08/06/iOS%E9%80%86%E5%90%91%E4%B9%8B%E7%A7%BB%E9%99%A4Oplayer-lite%E5%B9%BF%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<h3 id="一、环境要求："><a href="#一、环境要求：" class="headerlink" title="一、环境要求："></a>一、环境要求：</h3><p>1、iPod touch6: iOS10.3.1(已经越狱)</p><p>2、Xcode安装<a href="https://github.com/AloneMonkey/MonkeyDev/wiki/%E5%AE%89%E8%A3%85" target="_blank" rel="noopener">MonkeyDev</a></p><p>3、OPlayer Lite.ipa(Window PP助手获取)【非必须】</p><h3 id="二、lldb调试定位"><a href="#二、lldb调试定位" class="headerlink" title="二、lldb调试定位"></a>二、lldb调试定位</h3><p>1、直接在app store上下载Oplayer lite播放神器，为了方便调试，最好将设备设置成语言英文，后面会用到！</p><p>2、通过ssh连接越狱设备</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ssh</span> <span class="selector-tag">root</span>@<span class="keyword">172</span>.<span class="keyword">20</span>.<span class="keyword">134</span>.<span class="keyword">8</span></span><br></pre></td></tr></table></figure><p>3、关闭设备上的其他进程，最好只保留Oplayer lite，通过以下命令获取设备上所有运行的进程，只查看目标进程：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iPod:~ root<span class="comment"># ps aux | grep OPlayer</span></span><br><span class="line">mobile   <span class="number"> 6593 </span>  3.6  6.5 <span class="number"> 1384832 </span><span class="number"> 66024 </span>  ??  Ss    5:27PM   0:20.84 /var/containers/Bundle/Application/AAAB1B0F-A9A6-455C-BE5B-8E0230A75252/OPlayer Lite.app/OPlayer Lite</span><br><span class="line">root     <span class="number"> 6607 </span>  0.0  0.0  <span class="number"> 624224 </span>    <span class="number"> 8 </span>s000  R+    5:29PM   0:00.00 grep OPlayer</span><br></pre></td></tr></table></figure><p>4、根据教程<a href="https://www.jianshu.com/p/c3becee8d7d4" target="_blank" rel="noopener">iOS10.3.1 砸壳之路</a>使用两种方式进行应用砸壳,这里笔者就不详述了。</p><p>笔者通过第一种静态方式结果如下：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">iPod:~ root# Clutch -i</span><br><span class="line">Installed apps:</span><br><span class="line">1:   快拍 - Snapchat &lt;com.toyopagroup.picaboo&gt;</span><br><span class="line">2:   优酷视频-世界杯赛事全程高清直播 &lt;com.youku.YouKu&gt;</span><br><span class="line">3:   央视影音 &lt;cn.vuclip.mobiletv&gt;</span><br><span class="line">4:   A4 Player &lt;com.pd.A4Player&gt;</span><br><span class="line">5:   可可英语-英语听力口语训练神器 &lt;com.kekenet.kkyy&gt;</span><br><span class="line">6:   VPN Plus Privacy Protector &lt;vpn.free.proxy.FreeVPN-Plus&gt;</span><br><span class="line">7:   搜狐视频-法医秦明1、2两季独家连播 &lt;com.sohu.iPhoneVideo&gt;</span><br><span class="line">8:   微博 &lt;com.sina.weibo&gt;</span><br><span class="line">9:   腾讯视频 &lt;com.tencent.live4iphone&gt;</span><br><span class="line">10:  Shazam 音乐神搜 &lt;com.shazam.Shazam&gt;</span><br><span class="line">11:  OPlayer Lite - media player &lt;com.olimsoft.oplayer.lite&gt;</span><br><span class="line">12:  VPN - Super Unlimited Proxy &lt;mobi.mobilejump.freevpn&gt;</span><br><span class="line">13:  天天快报 - 腾讯兴趣阅读平台 &lt;com.tencent.reading&gt;</span><br><span class="line">iPod:~ root# Clutch -d 11</span><br><span class="line">Zipping OPlayer Lite.app</span><br><span class="line"><span class="keyword">Error: </span>Could not obtain mach port, either the process is dead (codesign error?) or entitlements were not properly signed!</span><br><span class="line"></span><br><span class="line"><span class="keyword">Error: </span>Failed to dump &lt;OPlayer WatchKit Extension&gt; with arch arm64</span><br><span class="line"></span><br><span class="line">2018<span class="string">-08</span><span class="string">-06</span> 17:36:20.796 Clutch[6610:278690] failed operation :(</span><br><span class="line">2018<span class="string">-08</span><span class="string">-06</span> 17:36:20.796 Clutch[6610:278690] application &lt;NSOperationQueue: 0x1004be080&gt;&#123;name = 'NSOperationQueue 0x1004be080'&#125;</span><br><span class="line"><span class="keyword">Error: </span>Failed to dump &lt;OPlayer WatchKit Extension&gt;</span><br><span class="line"></span><br><span class="line">2018<span class="string">-08</span><span class="string">-06</span> 17:36:20.797 Clutch[6610:278690] failed operation :(</span><br><span class="line">2018<span class="string">-08</span><span class="string">-06</span> 17:36:20.797 Clutch[6610:278690] application &lt;NSOperationQueue: 0x1004be080&gt;&#123;name = 'NSOperationQueue 0x1004be080'&#125;</span><br><span class="line">ASLR slide: 0x100020000</span><br><span class="line">Dumping &lt;OPlayer Lite&gt; (arm64)</span><br><span class="line">Patched cryptid (64bit segment)</span><br><span class="line">Writing new checksum</span><br><span class="line">Zipping OPlayer WatchKit Extension.appex</span><br><span class="line">FAILED: &lt;OPlayer Lite bundleID: com.olimsoft.oplayer.lite&gt;</span><br><span class="line">Finished dumping com.olimsoft.oplayer.lite in 20.9 seconds</span><br></pre></td></tr></table></figure><p>很遗憾失败了，其原因自行百度。。。</p><p>所以最好通过动态砸壳来解决，若是大佬能通过Clutch方式解决，请私信me!!!</p><p>5、查看广告存在的位置</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">iPod:~ root<span class="comment"># cycript -p 6593          </span></span><br><span class="line">cy<span class="comment"># [[UIApp keyWindow] recursiveDescription].toString()</span></span><br><span class="line"></span><br><span class="line">`<span class="variable">&lt;UIWindow: 0x102661a40; frame = (0 0; 320 568); opaque = NO; autoresize = RM+BM; gestureRecognizers = &lt;NSArray: 0x17024f540&gt;</span>; layer = <span class="variable">&lt;UIWindowLayer: 0x170229900&gt;</span>&gt;</span><br><span class="line">   |<span class="string"> &lt;UITransitionView: 0x10d4e6eb0; frame = (0 0; 320 568); autoresize = W+H; layer = &lt;CALayer: 0x170634b40&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string"> &lt;UIView: 0x10d43e5f0; frame = (0 0; 320 568); autoresize = W+H; autoresizesSubviews = NO; layer = &lt;CALayer: 0x17042f420&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIView: 0x10d405740; frame = (0 0; 320 568); layer = &lt;CALayer: 0x17042f620&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;PlayerView: 0x10d43d560; frame = (0 0; 320 568); layer = &lt;CAEAGLLayer: 0x17042f680&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;AVPlayerDemoPlaybackView: 0x10d400320; frame = (0 0; 320 568); layer = &lt;AVPlayerLayer: 0x170633d20&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;AVPlayerLayerIntermediateLayer: 0x1706344e0&gt; (layer)</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;FigVideoContainerLayer: 0x1704578b0&gt; (layer)</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;FigVideoLayer: 0x17065cf80&gt; (layer)</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;FigSubtitleCALayer: 0x170457c40&gt; (layer)</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;AVPlayerLayerIntermediateLayer: 0x170628300&gt; (layer)</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;SubtitleLabel: 0x1026f95d0; baseClass = UILabel; frame = (0 0; 320 40); text = ''; userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x170291120&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UILabel: 0x10d4025d0; frame = (0 62; 320 20); text = 'IMG_4758.MOV'; userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x170290360&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UILabel: 0x10d410650; frame = (0 52; 320 50); text = ''; userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x17029e6e0&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIView: 0x1027b8070; frame = (0 0; 320 50); layer = &lt;CALayer: 0x174229e20&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIButton: 0x102734a50; frame = (0 0; 320 50); opaque = NO; layer = &lt;CALayer: 0x174229dc0&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIImageView: 0x10d435250; frame = (0 0; 320 50); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x170635e80&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UILabel: 0x10271ed60; frame = (60 0; 260 50); text = 'Buy the full version to r...'; userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x174283fc0&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;RoundedRectView: 0x10265a540; frame = (0 0; 320 64); layer = &lt;CALayer: 0x170429de0&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;PlaySeekView: 0x10d40c050; frame = (39 22; 242 32); layer = &lt;CALayer: 0x170427700&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UILabel: 0x10d452980; frame = (0 3; 60 25); text = '00:00:03'; userInteractionEnabled = NO; tag = 10000; layer = &lt;_UILabelLayer: 0x170292110&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;OBSlider: 0x10267c790; baseClass = UISlider; frame = (60 5; 118 22); opaque = NO; tag = 10002; layer = &lt;CALayer: 0x170427000&gt;; value: 3.000000&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIView: 0x10d42e1e0; frame = (39 7; 77 8); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x170635c80&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIImageView: 0x10d421cd0; frame = (-37 0; 114 8); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x170635cc0&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIImageView: 0x10d429350; frame = (2 7; 37 8); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x170635d20&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIImageView: 0x102692290; frame = (24 -4; 30 30); opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x170635d80&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UILabel: 0x10d425830; frame = (178 3; 64 25); text = '-00:00:07'; userInteractionEnabled = NO; tag = 10001; layer = &lt;_UILabelLayer: 0x17028d9d0&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIButton: 0x10d404790; frame = (258 6; 58 50); opaque = NO; layer = &lt;CALayer: 0x1704351c0&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIButton: 0x10d4192a0; frame = (0 6; 58 54); opaque = NO; layer = &lt;CALayer: 0x1704298a0&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIButton: 0x10d420dc0; frame = (268 16; 48 44); opaque = NO; layer = &lt;CALayer: 0x170426760&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIImageView: 0x102770f80; frame = (2 7; 44 30); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x17422c700&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIButton: 0x10d424e50; frame = (4 16; 48 44); opaque = NO; layer = &lt;CALayer: 0x170429c20&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIImageView: 0x10d4b9eb0; frame = (2 7; 44 30); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x170635c40&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;NewRoundedRectView: 0x10d4a96a0; frame = (-5 480; 330 90); layer = &lt;CALayer: 0x17062cce0&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIButton: 0x1026a2c40; frame = (34 4; 44 44); opaque = NO; layer = &lt;CALayer: 0x170429780&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIImageView: 0x10d4e0240; frame = (6.5 6.5; 31 31); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x170635bc0&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIButton: 0x10d42f130; frame = (86 4; 44 44); opaque = NO; layer = &lt;CALayer: 0x170424520&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIImageView: 0x10d4de1b0; frame = (6.5 6.5; 31 31); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x170635ae0&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIButton: 0x10d404a60; frame = (138 4; 44 44); opaque = NO; layer = &lt;CALayer: 0x170426040&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIImageView: 0x10d4dc1d0; frame = (6.5 6.5; 31 31); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x170635a20&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIButton: 0x10d416000; frame = (190 4; 44 44); opaque = NO; layer = &lt;CALayer: 0x170427220&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIImageView: 0x10d4d3830; frame = (6.5 6.5; 31 31); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x1706359e0&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIButton: 0x10d434c00; frame = (242 4; 44 44); opaque = NO; layer = &lt;CALayer: 0x1704291c0&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIImageView: 0x10d4d58c0; frame = (6.5 6.5; 31 31); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x170635980&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;MPVolumeView: 0x10d4c7520; frame = (20 56; 240 30); opaque = NO; layer = &lt;CALayer: 0x170632ea0&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;MPButton: 0x10d4c80b0; baseClass = UIButton; frame = (218.5 2; 21.5 18); opaque = NO; autoresize = LM+BM; layer = &lt;CALayer: 0x170428480&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIImageView: 0x10d4c83e0; frame = (-39.25 -41; 100 100); alpha = 0; opaque = NO; userInteractionEnabled = NO; tag = 1886548836; layer = &lt;CALayer: 0x170631b00&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIImageView: 0x10d4d1850; frame = (0 0; 21.5 18); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x1706358e0&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;MPVolumeSlider: 0x10d4c7920; baseClass = UISlider; frame = (0 -5; 211.5 28); opaque = NO; autoresize = W+BM; layer = &lt;CALayer: 0x17062b6c0&gt;; value: 0.000000&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIView: 0x10d498720; frame = (2 10; 207.5 8); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x170635460&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIImageView: 0x10d425ac0; frame = (0 0; 207.5 8); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x170635560&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIImageView: 0x10d4bc0f0; frame = (2 10; 0 8); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x1706355c0&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIImageView: 0x10d4be180; frame = (-3 -1; 30 30); opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x170635620&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIButton: 0x10d4a3210; frame = (276 40; 44 44); opaque = NO; layer = &lt;CALayer: 0x170428180&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIImageView: 0x1027764c0; frame = (6.5 6.5; 31 31); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x17422a9e0&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIButton: 0x10d4a4cb0; frame = (276 40; 44 44); hidden = YES; opaque = NO; layer = &lt;CALayer: 0x17042b500&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;FloatingView: 0x10d4add90; frame = (45 124; 230 160); hidden = YES; layer = &lt;CALayer: 0x170429300&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIButton: 0x10d41c3a0; frame = (21 4; 50 50); opaque = NO; layer = &lt;CALayer: 0x1704330c0&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIImageView: 0x102700650; frame = (0 0; 50 50); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x17422aa80&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIButton: 0x10d498e60; frame = (91 4; 50 50); opaque = NO; layer = &lt;CALayer: 0x1704249a0&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIImageView: 0x102779690; frame = (0 0; 50 50); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x17423cb20&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIButton: 0x10d4ae9f0; frame = (91 56; 50 50); opaque = NO; layer = &lt;CALayer: 0x170432e00&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIImageView: 0x1027b2f20; frame = (0 0; 50 50); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x174229f00&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIButton: 0x10d4b0900; frame = (21 106; 50 50); opaque = NO; layer = &lt;CALayer: 0x1704328e0&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIImageView: 0x1026656e0; frame = (0 0; 50 50); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x170634d20&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIButton: 0x102738580; frame = (91 106; 50 50); opaque = NO; tintColor = UIExtendedGrayColorSpace 1 1; layer = &lt;CALayer: 0x174223f40&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIImageView: 0x10d497630; frame = (0 0; 50 50); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x170634ba0&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIButton: 0x10d4b2960; frame = (161 4; 50 50); opaque = NO; tintColor = UIExtendedGrayColorSpace 1 1; layer = &lt;CALayer: 0x170425a80&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIImageView: 0x10d43f260; frame = (0 0; 50 50); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x170429160&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIButton: 0x10d4b49a0; frame = (161 106; 50 50); opaque = NO; layer = &lt;CALayer: 0x170627b20&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIImageView: 0x10d4b5500; frame = (0 0; 50 50); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x17042f880&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;FloatingView: 0x10d4b67e0; frame = (-5 188; 62 192); layer = &lt;CALayer: 0x170630ae0&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIButton: 0x10d4b6d20; frame = (11 3.2; 44 44); opaque = NO; tintColor = UIExtendedGrayColorSpace 1 1; layer = &lt;CALayer: 0x170633160&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIImageView: 0x10d436ff0; frame = (6.5 6.5; 31 31); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x170633ce0&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIButton: 0x10d4b7db0; frame = (11 50.4; 44 44); opaque = NO; tintColor = UIExtendedGrayColorSpace 1 1; layer = &lt;CALayer: 0x17062e040&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIImageView: 0x1026a9ad0; frame = (6.5 6.5; 31 31); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x1706337a0&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIButton: 0x10d4ba170; frame = (11 97.6; 44 44); opaque = NO; tintColor = UIExtendedGrayColorSpace 1 1; layer = &lt;CALayer: 0x170632760&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIImageView: 0x10d402990; frame = (7 7; 30 30); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x1706344c0&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIButton: 0x10d4bc3b0; frame = (11 144.8; 44 44); opaque = NO; tintColor = UIExtendedGrayColorSpace 1 1; layer = &lt;CALayer: 0x170632c20&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIImageView: 0x102797f20; frame = (6.5 6.5; 31 31); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x174229de0&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;FloatingView: 0x10d4b69a0; frame = (263 188; 62 192); layer = &lt;CALayer: 0x170632880&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIButton: 0x10d4be440; frame = (6 3.2; 44 44); opaque = NO; tintColor = UIExtendedGrayColorSpace 1 1; layer = &lt;CALayer: 0x170632be0&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIImageView: 0x10d44d340; frame = (6.5 6.5; 31 31); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x17062a280&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIButton: 0x10d4c04b0; frame = (6 50.4; 44 44); opaque = NO; tintColor = UIExtendedGrayColorSpace 1 1; layer = &lt;CALayer: 0x170629c00&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIImageView: 0x10d434ed0; frame = (6.5 6.5; 31 31); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x170632940&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIButton: 0x10d4c2490; frame = (6 97.6; 44 44); opaque = NO; tintColor = UIExtendedGrayColorSpace 1 1; layer = &lt;CALayer: 0x1702377c0&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIImageView: 0x10264f740; frame = (6.5 6.5; 31 31); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x170634b00&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIButton: 0x10d4c4090; frame = (6 144.8; 44 44); opaque = NO; tintColor = UIExtendedSRGBColorSpace 0.192157 0.760784 0.486275 1; layer = &lt;CALayer: 0x17062e5a0&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIImageView: 0x1026d5810; frame = (6.5 6.5; 31 31); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x17062f7c0&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UILabel: 0x10d4c6020; frame = (0 448; 320 30); text = ''; alpha = 0; userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x17048ae10&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UILabel: 0x10d4c6b50; frame = (0 284; 320 100); userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x17048a780&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;_UILabelContentLayer: 0x1706337c0&gt; (layer)</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;SingleHandRoundedRectView: 0x10d4d9d10; frame = (0 341; 227 227); hidden = YES; layer = &lt;CALayer: 0x170432e80&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIImageView: 0x10d4da0e0; frame = (0 0; 227 227); opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x170432de0&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIButton: 0x10d4d5b80; frame = (80 165; 52 52); opaque = NO; layer = &lt;CALayer: 0x170632dc0&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIImageView: 0x10268c4f0; frame = (10.5 10.5; 31 31); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x170426d00&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIButton: 0x10d4d1b10; frame = (150 160; 52 52); opaque = NO; layer = &lt;CALayer: 0x17062c6a0&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIImageView: 0x10d40f400; frame = (10.5 10.5; 31 31); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x17062abc0&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIButton: 0x10d4cfa80; frame = (105 75; 52 52); opaque = NO; layer = &lt;CALayer: 0x17062b9a0&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIImageView: 0x1026c59a0; frame = (10.5 10.5; 31 31); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x170432940&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIButton: 0x10d4d3af0; frame = (20 25; 52 52); opaque = NO; layer = &lt;CALayer: 0x170630e20&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIImageView: 0x10d416a20; frame = (10.5 10.5; 31 31); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x1706315a0&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIButton: 0x10d4d7870; frame = (10 95; 52 52); opaque = NO; layer = &lt;CALayer: 0x170433720&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIImageView: 0x10d4a5d50; frame = (10.5 10.5; 31 31); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x170629d00&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIButton: 0x10d4d9910; frame = (10 170; 52 52); opaque = NO; layer = &lt;CALayer: 0x170633c00&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIImageView: 0x10d403130; frame = (10.5 10.5; 31 31); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x1706265c0&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;SingleHandRoundedRectView: 0x10d4e4690; frame = (93 341; 227 227); hidden = YES; layer = &lt;CALayer: 0x170630000&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIImageView: 0x10d4e4860; frame = (0 0; 227 227); opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x1706273c0&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIButton: 0x10d4e0500; frame = (100 165; 52 52); opaque = NO; layer = &lt;CALayer: 0x170424ba0&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIImageView: 0x10d4006c0; frame = (10.5 10.5; 31 31); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x170632d60&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIButton: 0x10d4dc490; frame = (25 160; 52 52); opaque = NO; layer = &lt;CALayer: 0x170633100&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIImageView: 0x102655f40; frame = (10.5 10.5; 31 31); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x170632360&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIButton: 0x10d4da2d0; frame = (75 75; 52 52); opaque = NO; layer = &lt;CALayer: 0x170633180&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIImageView: 0x1026894c0; frame = (10.5 10.5; 31 31); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x17062f220&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIButton: 0x10d4de470; frame = (165 25; 52 52); opaque = NO; layer = &lt;CALayer: 0x170433580&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIImageView: 0x10266a930; frame = (10.5 10.5; 31 31); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x17042f800&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIButton: 0x10d4e21f0; frame = (165 95; 52 52); opaque = NO; layer = &lt;CALayer: 0x170433920&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIImageView: 0x10d42adc0; frame = (10.5 10.5; 31 31); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x170426c40&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIButton: 0x10d4e4290; frame = (170 170; 52 52); opaque = NO; layer = &lt;CALayer: 0x1704293e0&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIImageView: 0x102663010; frame = (10.5 10.5; 31 31); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x170426700&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIButton: 0x10d4e4a50; frame = (260 258; 52 52); hidden = YES; opaque = NO; layer = &lt;CALayer: 0x17062eb20&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIImageView: 0x10d41df50; frame = (1 1; 50 50); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x170432820&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIButton: 0x10d4e4d20; frame = (10 258; 52 52); hidden = YES; opaque = NO; layer = &lt;CALayer: 0x17062cf60&gt;&gt;</span></span><br><span class="line"><span class="string">   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> &lt;UIImageView: 0x1026f92a0; frame = (1 1; 50 50); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x1704270e0&gt;&gt;`</span></span><br></pre></td></tr></table></figure><p>这里需要说明的是，<code>[[UIApp keyWindow] recursiveDescription].toString()</code>是查看当前页面的所有view。稍微仔细点的同学就会主要到，每次进入播放界面时，界面上方都有一个banner，内容是<code>Buy the full version to remove ads?</code>.所以简单的方式是，通过搜索关键字查找控件。可得到如下结果：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;UILabel: <span class="number">0x10271ed60</span>; frame = (<span class="number">60</span> <span class="number">0</span>; <span class="number">260</span> <span class="number">50</span>); <span class="built_in">text</span> = 'Buy <span class="keyword">the</span> full <span class="built_in">version</span> <span class="keyword">to</span> r...'; userInteractionEnabled = NO;</span><br></pre></td></tr></table></figure><p>我们可以在后面进行lldb调试的时候，根据这个为依据进行查找调试。</p><p>5、利用debugserver结合LLDB调试app</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debugserver *:<span class="number">1234</span> -<span class="selector-tag">a</span> <span class="string">"OPlayer Lite"</span></span><br></pre></td></tr></table></figure><p>6、新建终端LLDB连接App</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lldb</span><br><span class="line"><span class="built_in">process</span> <span class="built_in">connect</span> <span class="built_in">connect</span>:<span class="comment">//172.20.128.176:1234</span></span><br></pre></td></tr></table></figure><p>7、接下来查看偏移地址</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">image</span> <span class="built_in">list</span> -o -f</span><br></pre></td></tr></table></figure><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[  <span class="number">0</span>] <span class="number">0x000000000005c000</span> /var/containers/Bundle/Application/AAAB1B0F-A9A6<span class="number">-455</span>C-BE5B<span class="number">-8E0230</span>A75252/OPlayer Lite.app/OPlayer Lite(<span class="number">0x000000010005c000</span>)</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">[  <span class="number">7</span>] <span class="number">0x0000000000350000</span> /Users/weihua/Library/Developer/Xcode/iOS DeviceSupport/<span class="number">10.3</span><span class="number">.1</span> (<span class="number">14E304</span>)/Symbols/System/Library/Frameworks/UIKit.framework/UIKit</span><br></pre></td></tr></table></figure><p>通过hopper v4分析<code>addSubview</code>在UIKit框架的偏移地址：<br>addSubview:0x0000000187775d24</p><p>通过<code>image list -o -f</code>分析UIKit框架在模块中加载的的起始偏移地址：<br>UIKit: 0x0000000000350000</p><p>设置断点：<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">br s -a <span class="number">0</span>x00000<span class="number">00000350000</span>+<span class="number">0</span>x0000<span class="number">000187775d24</span></span><br></pre></td></tr></table></figure></p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">* thread <span class="symbol">#1</span>, queue = 'com.apple.main-thread', stop reason = breakpoint <span class="number">1.1</span></span><br><span class="line">    frame <span class="symbol">#0</span>: <span class="number">0x0000000187ac5d24</span> UIKit`-[UIView(Hierarchy) addSubview:]</span><br><span class="line">UIKit`-[UIView(Hierarchy) addSubview:]:</span><br><span class="line">-&gt;  <span class="number">0x187ac5d24</span> &lt;+<span class="number">0</span>&gt;:  stp    <span class="keyword">x</span><span class="number">24</span>, <span class="keyword">x</span><span class="number">23</span>, [sp, #<span class="number">-0</span><span class="keyword">x</span><span class="number">40</span>]!</span><br><span class="line">    <span class="number">0x187ac5d28</span> &lt;+<span class="number">4</span>&gt;:  stp    <span class="keyword">x</span><span class="number">22</span>, <span class="keyword">x</span><span class="number">21</span>, [sp, <span class="symbol">#0</span><span class="keyword">x</span><span class="number">10</span>]</span><br><span class="line">    <span class="number">0x187ac5d2c</span> &lt;+<span class="number">8</span>&gt;:  stp    <span class="keyword">x</span><span class="number">20</span>, <span class="keyword">x</span><span class="number">19</span>, [sp, <span class="symbol">#0</span><span class="keyword">x</span><span class="number">20</span>]</span><br><span class="line">    <span class="number">0x187ac5d30</span> &lt;+<span class="number">12</span>&gt;: stp    <span class="keyword">x</span><span class="number">29</span>, <span class="keyword">x</span><span class="number">30</span>, [sp, <span class="symbol">#0</span><span class="keyword">x</span><span class="number">30</span>]</span><br><span class="line">Target <span class="number">0</span>: (OPlayer Lite) stopped.</span><br><span class="line">(lldb) po $<span class="keyword">x</span><span class="number">2</span></span><br><span class="line">&lt;PlayerView: <span class="number">0x1027f27d0</span><span class="comment">; frame = (0 0; 568 320); layer = &lt;CAEAGLLayer: 0x1704298c0&gt;&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">(lldb) c</span></span><br><span class="line"><span class="comment">Process 432 resuming</span></span><br><span class="line"><span class="comment">Process 432 stopped</span></span><br><span class="line"><span class="comment">* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1</span></span><br><span class="line"><span class="comment">    frame #0: 0x0000000187ac5d24 UIKit`-[UIView(Hierarchy) addSubview:]</span></span><br><span class="line"><span class="comment">UIKit`-[UIView(Hierarchy) addSubview:]:</span></span><br><span class="line"><span class="comment">-&gt;  0x187ac5d24 &lt;+0&gt;:  stp    x24, x23, [sp, #-0x40]!</span></span><br><span class="line"><span class="comment">    0x187ac5d28 &lt;+4&gt;:  stp    x22, x21, [sp, #0x10]</span></span><br><span class="line"><span class="comment">    0x187ac5d2c &lt;+8&gt;:  stp    x20, x19, [sp, #0x20]</span></span><br><span class="line"><span class="comment">    0x187ac5d30 &lt;+12&gt;: stp    x29, x30, [sp, #0x30]</span></span><br><span class="line"><span class="comment">Target 0: (OPlayer Lite) stopped.</span></span><br><span class="line"><span class="comment">(lldb) po $x2</span></span><br><span class="line"><span class="comment">&lt;UIView: 0x1027f32a0; frame = (0 0; 568 320); layer = &lt;CALayer: 0x17042dc40&gt;&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">......</span></span><br><span class="line"><span class="comment">......</span></span><br><span class="line"><span class="comment">......</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">(lldb) po $x2</span></span><br><span class="line"><span class="comment">&lt;UILayoutContainerView: 0x1027700d0; frame = (0 0; 320 568); autoresize = W+H; layer = &lt;CALayer: 0x1702374e0&gt;&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">(lldb) c</span></span><br><span class="line"><span class="comment">Process 432 resuming</span></span><br><span class="line"><span class="comment">Process 432 stopped</span></span><br><span class="line"><span class="comment">* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1</span></span><br><span class="line"><span class="comment">    frame #0: 0x0000000187ac5d24 UIKit`-[UIView(Hierarchy) addSubview:]</span></span><br><span class="line"><span class="comment">UIKit`-[UIView(Hierarchy) addSubview:]:</span></span><br><span class="line"><span class="comment">-&gt;  0x187ac5d24 &lt;+0&gt;:  stp    x24, x23, [sp, #-0x40]!</span></span><br><span class="line"><span class="comment">    0x187ac5d28 &lt;+4&gt;:  stp    x22, x21, [sp, #0x10]</span></span><br><span class="line"><span class="comment">    0x187ac5d2c &lt;+8&gt;:  stp    x20, x19, [sp, #0x20]</span></span><br><span class="line"><span class="comment">    0x187ac5d30 &lt;+12&gt;: stp    x29, x30, [sp, #0x30]</span></span><br><span class="line"><span class="comment">Target 0: (OPlayer Lite) stopped.</span></span><br><span class="line"><span class="comment">(lldb) po $x2</span></span><br><span class="line"><span class="comment">&lt;UIButton: 0x10f23eb00; frame = (0 0; 320 50); opaque = NO; layer = &lt;CALayer: 0x17042e180&gt;&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">(lldb) c</span></span><br><span class="line"><span class="comment">Process 432 resuming</span></span><br><span class="line"><span class="comment">Process 432 stopped</span></span><br><span class="line"><span class="comment">* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1</span></span><br><span class="line"><span class="comment">    frame #0: 0x0000000187ac5d24 UIKit`-[UIView(Hierarchy) addSubview:]</span></span><br><span class="line"><span class="comment">UIKit`-[UIView(Hierarchy) addSubview:]:</span></span><br><span class="line"><span class="comment">-&gt;  0x187ac5d24 &lt;+0&gt;:  stp    x24, x23, [sp, #-0x40]!</span></span><br><span class="line"><span class="comment">    0x187ac5d28 &lt;+4&gt;:  stp    x22, x21, [sp, #0x10]</span></span><br><span class="line"><span class="comment">    0x187ac5d2c &lt;+8&gt;:  stp    x20, x19, [sp, #0x20]</span></span><br><span class="line"><span class="comment">    0x187ac5d30 &lt;+12&gt;: stp    x29, x30, [sp, #0x30]</span></span><br><span class="line"><span class="comment">Target 0: (OPlayer Lite) stopped.</span></span><br><span class="line"><span class="comment">(lldb) po $x2</span></span><br><span class="line"><span class="comment">&lt;UILabel: 0x10f2009b0; frame = (60 0; 260 50); text = 'Buy the full version to r...'; userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x17028bc70&gt;&gt;</span></span><br></pre></td></tr></table></figure><p>到此为止找到了相关控件，然后通过<code>ni</code>命令往回追溯目标模块调用时的起始地址。</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">(lldb) ni</span><br><span class="line">Process <span class="number">432</span> stopped</span><br><span class="line">* thread <span class="symbol">#1</span>, queue = 'com.apple.main-thread', stop reason = instruction step over</span><br><span class="line">    frame <span class="symbol">#0</span>: <span class="number">0x0000000187ac5d28</span> UIKit`-[UIView(Hierarchy) addSubview:] + <span class="number">4</span></span><br><span class="line">UIKit`-[UIView(Hierarchy) addSubview:]:</span><br><span class="line">-&gt;  <span class="number">0x187ac5d28</span> &lt;+<span class="number">4</span>&gt;:  stp    <span class="keyword">x</span><span class="number">22</span>, <span class="keyword">x</span><span class="number">21</span>, [sp, <span class="symbol">#0</span><span class="keyword">x</span><span class="number">10</span>]</span><br><span class="line">    <span class="number">0x187ac5d2c</span> &lt;+<span class="number">8</span>&gt;:  stp    <span class="keyword">x</span><span class="number">20</span>, <span class="keyword">x</span><span class="number">19</span>, [sp, <span class="symbol">#0</span><span class="keyword">x</span><span class="number">20</span>]</span><br><span class="line">    <span class="number">0x187ac5d30</span> &lt;+<span class="number">12</span>&gt;: stp    <span class="keyword">x</span><span class="number">29</span>, <span class="keyword">x</span><span class="number">30</span>, [sp, <span class="symbol">#0</span><span class="keyword">x</span><span class="number">30</span>]</span><br><span class="line">    <span class="number">0x187ac5d34</span> &lt;+<span class="number">16</span>&gt;: <span class="keyword">add</span>    <span class="keyword">x</span><span class="number">29</span>, sp, <span class="symbol">#0</span><span class="keyword">x</span><span class="number">30</span>            <span class="comment">; =0x30 </span></span><br><span class="line"><span class="comment">Target 0: (OPlayer Lite) stopped.</span></span><br><span class="line"><span class="comment">(lldb)  </span></span><br><span class="line"><span class="comment">Process 432 stopped</span></span><br><span class="line"><span class="comment">* thread #1, queue = 'com.apple.main-thread', stop reason = instruction step over</span></span><br><span class="line"><span class="comment">    frame #0: 0x0000000187ac5d2c UIKit`-[UIView(Hierarchy) addSubview:] + 8</span></span><br><span class="line"><span class="comment">UIKit`-[UIView(Hierarchy) addSubview:]:</span></span><br><span class="line"><span class="comment">-&gt;  0x187ac5d2c &lt;+8&gt;:  stp    x20, x19, [sp, #0x20]</span></span><br><span class="line"><span class="comment">    0x187ac5d30 &lt;+12&gt;: stp    x29, x30, [sp, #0x30]</span></span><br><span class="line"><span class="comment">    0x187ac5d34 &lt;+16&gt;: add    x29, sp, #0x30            ; =0x30 </span></span><br><span class="line"><span class="comment">    0x187ac5d38 &lt;+20&gt;: mov    x20, x0</span></span><br><span class="line"><span class="comment">Target 0: (OPlayer Lite) stopped.</span></span><br><span class="line"><span class="comment">(lldb)  </span></span><br><span class="line"><span class="comment">(lldb) </span></span><br><span class="line"><span class="comment">error: invalid thread</span></span><br><span class="line"><span class="comment">Process 432 stopped</span></span><br><span class="line"><span class="comment">* thread #1, queue = 'com.apple.main-thread', stop reason = instruction step over</span></span><br><span class="line"><span class="comment">    frame #0: 0x0000000187ac5d30 UIKit`-[UIView(Hierarchy) addSubview:] + 12</span></span><br><span class="line"><span class="comment">UIKit`-[UIView(Hierarchy) addSubview:]:</span></span><br><span class="line"><span class="comment">-&gt;  0x187ac5d30 &lt;+12&gt;: stp    x29, x30, [sp, #0x30]</span></span><br><span class="line"><span class="comment">    0x187ac5d34 &lt;+16&gt;: add    x29, sp, #0x30            ; =0x30 </span></span><br><span class="line"><span class="comment">    0x187ac5d38 &lt;+20&gt;: mov    x20, x0</span></span><br><span class="line"><span class="comment">    0x187ac5d3c &lt;+24&gt;: mov    x0, x2</span></span><br><span class="line"><span class="comment">Target 0: (OPlayer Lite) stopped.</span></span><br><span class="line"><span class="comment">(lldb)  </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> ........</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">Process 432 stopped</span></span><br><span class="line"><span class="comment">* thread #1, queue = 'com.apple.main-thread', stop reason = instruction step over</span></span><br><span class="line"><span class="comment">    frame #0: 0x0000000187ac6074 UIKit`-[UIView(Hierarchy) addSubview:] + 848</span></span><br><span class="line"><span class="comment">UIKit`-[UIView(Hierarchy) addSubview:]:</span></span><br><span class="line"><span class="comment">-&gt;  0x187ac6074 &lt;+848&gt;: b      0x180414250               ; objc_release</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">UIKit`-[UIView(Internal) _addSubview:positioned:relativeTo:]:</span></span><br><span class="line"><span class="comment">    0x187ac6078 &lt;+0&gt;:   stp    x28, x27, [sp, #-0x60]!</span></span><br><span class="line"><span class="comment">    0x187ac607c &lt;+4&gt;:   stp    x26, x25, [sp, #0x10]</span></span><br><span class="line"><span class="comment">    0x187ac6080 &lt;+8&gt;:   stp    x24, x23, [sp, #0x20]</span></span><br><span class="line"><span class="comment">Target 0: (OPlayer Lite) stopped.</span></span><br><span class="line"><span class="comment">(lldb)  </span></span><br><span class="line"><span class="comment">Process 432 stopped</span></span><br><span class="line"><span class="comment">* thread #1, queue = 'com.apple.main-thread', stop reason = instruction step over</span></span><br><span class="line"><span class="comment">    frame #0: 0x00000001003d01f8 OPlayer Lite`_mh_execute_header + 3621368</span></span><br><span class="line"><span class="comment">OPlayer Lite`_mh_execute_header:</span></span><br><span class="line"><span class="comment">-&gt;  0x1003d01f8 &lt;+3621368&gt;: adrp   x8, 5089</span></span><br><span class="line"><span class="comment">    0x1003d01fc &lt;+3621372&gt;: ldr    x20, [x8, #0x630]</span></span><br><span class="line"><span class="comment">    0x1003d0200 &lt;+3621376&gt;: mov    x0, x19</span></span><br><span class="line"><span class="comment">    0x1003d0204 &lt;+3621380&gt;: mov    x1, x20</span></span><br><span class="line"><span class="comment">Target 0: (OPlayer Lite) stopped.</span></span><br><span class="line"><span class="comment">(lldb)  </span></span><br><span class="line"><span class="comment">Process 432 stopped</span></span><br><span class="line"><span class="comment">* thread #1, queue = 'com.apple.main-thread', stop reason = instruction step over</span></span><br><span class="line"><span class="comment">    frame #0: 0x00000001003d01fc OPlayer Lite`_mh_execute_header + 3621372</span></span><br><span class="line"><span class="comment">OPlayer Lite`_mh_execute_header:</span></span><br><span class="line"><span class="comment">-&gt;  0x1003d01fc &lt;+3621372&gt;: ldr    x20, [x8, #0x630]</span></span><br><span class="line"><span class="comment">    0x1003d0200 &lt;+3621376&gt;: mov    x0, x19</span></span><br><span class="line"><span class="comment">    0x1003d0204 &lt;+3621380&gt;: mov    x1, x20</span></span><br><span class="line"><span class="comment">    0x1003d0208 &lt;+3621384&gt;: bl     0x10106f28c               ; symbol stub for: objc_msgSend</span></span><br><span class="line"><span class="comment">Target 0: (OPlayer Lite) stopped.</span></span><br></pre></td></tr></table></figure><p>由结果看来，<code>OPlayer Lite</code>模块起始基地址为<code>0x1003d01f8</code>，<br>然后通过减去<code>OPlayer Lite</code>偏移地址<code>0x000000000005c000</code>,</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p/x <span class="number">0x1003d01f8</span><span class="number">-0x000000000005c000</span></span><br><span class="line">(long) $<span class="number">74</span> = <span class="number">0x00000001003741f8</span></span><br></pre></td></tr></table></figure><p>然后把<code>0x00000001003741f8</code>放入已经打开的Hopper Disassembler v4中，用快捷键<code>G</code>进行查找，结果如下：<br><img src="/2018/08/06/iOS逆向之移除Oplayer-lite广告/001.png" alt="01.png"></p><p>这里我们进行更加结果进行猜测，<code>addAds_OnLocalAds</code>很有可能是我们需要查找的结果。接下来，我们对其进行进行断点调试，先找到<code>addAds_OnLocalAds</code>的地址：</p><p><img src="/2018/08/06/iOS逆向之移除Oplayer-lite广告/002.png" alt="02.png"></p><p>地址为：<code>0x000000010037c518</code></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p/x <span class="number">0x000000010037c518</span>+<span class="number">0x000000000005c000</span></span><br><span class="line">(long) $<span class="number">76</span> = <span class="number">0x00000001003d8518</span></span><br></pre></td></tr></table></figure><p>可能此时设备卡顿不动，继续运行,并且移除所有命令：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(lldb) <span class="keyword">c</span></span><br><span class="line">Process <span class="number">432</span> resuming</span><br><span class="line">(lldb) <span class="keyword">br</span> del</span><br><span class="line">About <span class="keyword">to</span> <span class="keyword">delete</span> <span class="keyword">all</span> breakpoints, <span class="keyword">do</span> you want <span class="keyword">to</span> <span class="keyword">do</span> that?: [Y/n] <span class="keyword">y</span></span><br><span class="line">All breakpoints removed. (<span class="number">1</span> breakpoint)</span><br></pre></td></tr></table></figure><p>重新设置断点,即<code>addAds_OnLocalAds</code>处设置断点：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">br s -<span class="selector-tag">a</span> <span class="number">0</span>x00000001003d8518</span><br></pre></td></tr></table></figure><p>然后返回上一界面，重新播放视频，此时命令行输出：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* thread <span class="symbol">#1</span>, queue = 'com.apple.main-thread', stop reason = breakpoint <span class="number">2.1</span></span><br><span class="line">    frame <span class="symbol">#0</span>: <span class="number">0x00000001003d8518</span> OPlayer Lite`_mh_execute_header + <span class="number">3654936</span></span><br><span class="line">OPlayer Lite`_mh_execute_header:</span><br><span class="line">-&gt;  <span class="number">0x1003d8518</span> &lt;+<span class="number">3654936</span>&gt;: stp    d<span class="number">9</span>, d<span class="number">8</span>, [sp, #<span class="number">-0</span><span class="keyword">x</span><span class="number">50</span>]!</span><br><span class="line">    <span class="number">0x1003d851c</span> &lt;+<span class="number">3654940</span>&gt;: stp    <span class="keyword">x</span><span class="number">24</span>, <span class="keyword">x</span><span class="number">23</span>, [sp, <span class="symbol">#0</span><span class="keyword">x</span><span class="number">10</span>]</span><br><span class="line">    <span class="number">0x1003d8520</span> &lt;+<span class="number">3654944</span>&gt;: stp    <span class="keyword">x</span><span class="number">22</span>, <span class="keyword">x</span><span class="number">21</span>, [sp, <span class="symbol">#0</span><span class="keyword">x</span><span class="number">20</span>]</span><br><span class="line">    <span class="number">0x1003d8524</span> &lt;+<span class="number">3654948</span>&gt;: stp    <span class="keyword">x</span><span class="number">20</span>, <span class="keyword">x</span><span class="number">19</span>, [sp, <span class="symbol">#0</span><span class="keyword">x</span><span class="number">30</span>]</span><br><span class="line">Target <span class="number">0</span>: (OPlayer Lite) stopped.</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure><p>接下来获取名称及地址：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p (<span class="keyword">char</span>*)<span class="variable">$x1</span></span><br><span class="line">(<span class="keyword">char</span> *) <span class="variable">$78</span> = 0x0000000101454c97 <span class="string">"addAds_OnLocalAds"</span></span><br></pre></td></tr></table></figure><p>方法执行完以后应该返回的地址</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p/x $lr</span><br><span class="line">(unsigned long) $<span class="number">83</span> = <span class="number">0x00000001003d01f8</span></span><br><span class="line">(lldb) p/x <span class="number">0x00000001003d01f8</span><span class="number">-0x000000000005c000</span></span><br><span class="line">(long) $<span class="number">84</span> = <span class="number">0x00000001003741f8</span></span><br></pre></td></tr></table></figure><p><code>0x00000001003741f8</code>是我们需要的地址，根据这个地址可以在Hopper V4中进行跳转：</p><p><img src="/2018/08/06/iOS逆向之移除Oplayer-lite广告/003.png" alt="03.png"></p><p>在上图中，找了方法<code>addAds_OnLocalAds</code>方法，说明位置正确，然后根据汇编指令<code>cbnz</code>,可知这一处是一个判断语句。</p><p>最关键的信息是，我们还看到了在一个”PlayViewController”控制器中存在一个’localAdView’的成员变量。</p><p>同时继续往上继续查找，可以找到该方法是在<code>[PlayViewController viewWillAppear:]</code>中调用的，如下图：<br><img src="/2018/08/06/iOS逆向之移除Oplayer-lite广告/004.png" alt="04.png"></p><p>接下来，我们进行确认。</p><p>通过<code>class-dump</code>的方式获取头文件。这里不说具体原因了，命令如下：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>-<span class="title">dump</span> <span class="title">OPlayer_Lite</span>.<span class="title">decrypted</span> -<span class="title">H</span> -<span class="title">o</span> <span class="title">header</span></span></span><br></pre></td></tr></table></figure><p>然后在header文件夹中可以进行确认。</p><p>OK，到此为止，我们已经找到了 广告加载的界面的了。我们需要通过工程来进行最后的实现。</p><h3 id="三、MonkeyDev调试定位"><a href="#三、MonkeyDev调试定位" class="headerlink" title="三、MonkeyDev调试定位"></a>三、MonkeyDev调试定位</h3><p>这里为了简单，我采用了MonkeyDev来实现，当然也可以通过 Theos 的方式，笔者亲测成功！！！</p><p>关于如何安装MonkeyDev，请移步<a href="https://github.com/AloneMonkey/MonkeyDev/wiki/%E5%AE%89%E8%A3%85" target="_blank" rel="noopener">MonkeyDev安装教程及简介</a>。</p><p>需要说明的是，MonkeyDev的好处就是能通过界面调试app，定位控件，当然如果安装了Reveal那就更加简单，iOS上面的界面调试神器。但是<br>MonkeyDev需要已经破解了ipa，这里可以通过<code>Window上的PP助手</code>获取。</p><p>首先新建工程，命名<code>Oplayerlite</code>.其它的也不多了，直接贴关键代码。</p><p><img src="/2018/08/06/iOS逆向之移除Oplayer-lite广告/005.png" alt="07.png"></p><p>然后运行工程，发现之前的 ‘Buy the full version to remove ads?’ 相关的UIView已经没了，但是又出现了新的广告，以下截图来自Reveal，Xcode也可以。</p><p><img src="/2018/08/06/iOS逆向之移除Oplayer-lite广告/006.png" alt="08.png"></p><p>然后在<code>PlayViewController</code>中找到了相关的调用<code>GADBannerView *gAdView;</code>,然后通过头文件查找<code>GADBannerView</code>,结果找到了如下调用函数：</p><p><img src="/2018/08/06/iOS逆向之移除Oplayer-lite广告/007.png" alt="09.png"></p><p>此时抱着怀疑的态度试了修改工程中<code>OplayerliteDylib.xm</code>内容如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// See http://iphonedevwiki.net/index.php/Logos</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PlayViewController</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">UIView</span> *localAdView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">%hook PlayViewController</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)arg1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.localAdView = [[<span class="built_in">UIView</span> alloc]initWithFrame:<span class="built_in">CGRectZero</span>];</span><br><span class="line">    %orig;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">%end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%hook GADBannerView</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setFrame:(<span class="keyword">struct</span> <span class="built_in">CGRect</span>)arg1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"__%s__"</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">%end</span><br></pre></td></tr></table></figure><p>然后run一下，结果居然成功了。</p><p>OK，恭喜，到此为止真的实现了Oplayer lite播放时移除广告的功能。</p><h3 id="四、打包安装App至非越狱"><a href="#四、打包安装App至非越狱" class="headerlink" title="四、打包安装App至非越狱"></a>四、打包安装App至非越狱</h3><p>后面，我想这如何将此app安装的到非越狱的设备上。</p><p><img src="/2018/08/06/iOS逆向之移除Oplayer-lite广告/008.png" alt="10.png"></p><p>将此app进行到处，放入Payload文件中压缩，重命名为.ipa的文件。此时可能还无法进行安装，需要最后一步操作，进行ipa重签名。<br>具体请参考<a href="https://www.jianshu.com/p/f46f94983880" target="_blank" rel="noopener">iOS重签名操作</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 逆向开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS开发之上线AppStore流程</title>
      <link href="/2018/06/07/iOS%E5%BC%80%E5%8F%91%E4%B9%8B%E4%B8%8A%E7%BA%BFAppStore%E6%B5%81%E7%A8%8B/"/>
      <url>/2018/06/07/iOS%E5%BC%80%E5%8F%91%E4%B9%8B%E4%B8%8A%E7%BA%BFAppStore%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>作为一个iOS开发者，不仅仅是能够写出优美的代码。最终的我们的目的是能我们的项目上线，就显示十分完美了。</p><p>由于每次上线或多或少的都会有细节无法注意到。现在就以公司某个项目上线为基础。详细描述关于iOS上线的流程。</p><p>一般分为三个部分：BundleID申请、发布证书申请、提交审核。</p><h3 id="一、BundleID申请"><a href="#一、BundleID申请" class="headerlink" title="一、BundleID申请"></a>一、BundleID申请</h3><p>公司一般都是多人开发，为了方便测试，在开发阶段使用企业版账号进行项目开发。在开发完成后需要进行app store 上架，这里可以通过更新项目的buildID来实现。通过测试可知，用两种方式可实现更新：</p><ul><li>直接更换成新的bundleID；</li><li>将企业版账号下的bundleID进行删除，然后在个人开发者账号再次创建。</li></ul><h5 id="创建步骤如下："><a href="#创建步骤如下：" class="headerlink" title="创建步骤如下："></a>创建步骤如下：</h5><p>1、登陆<a href="https://developer.apple.com/account" target="_blank" rel="noopener">https://developer.apple.com/account</a>，进入如下界面<br>    <img src="/2018/06/07/iOS开发之上线AppStore流程/1-01.png" alt="img"></p><p>2、点击证书描述文件管理，进入如下界面<br>    <img src="/2018/06/07/iOS开发之上线AppStore流程/1-02.png" alt="img"></p><p>3、接下点击上图中的“+”即可进行bundleID的创建，这里以<code>com.xxxxxx.testApp</code>为例<br>    <img src="/2018/06/07/iOS开发之上线AppStore流程/1-03.png" alt="img"></p><p>4、点击<code>continue</code>，跳转下一界面，如下：<br>    <img src="/2018/06/07/iOS开发之上线AppStore流程/1-04.png" alt="img"></p><p>5、点击上图<code>Register</code>按钮，跳转下一界面，如下：<br>    <img src="/2018/06/07/iOS开发之上线AppStore流程/1-05.png" alt="img"></p><p>6、点击上图<code>Done</code>按钮，表示已经完成新的bundleID创建。</p><h3 id="二、发布证书申请"><a href="#二、发布证书申请" class="headerlink" title="二、发布证书申请"></a>二、发布证书申请</h3><p>在申请发布证书之前，我们需要进行<code>CertificateSigningRequest</code>创建，因为后续在进行发布证书申请时需要。</p><p>1、在Mac上搜索<code>钥匙串访问</code>即可，然后按下图所示，进行创建。<br><img src="/2018/06/07/iOS开发之上线AppStore流程/2-01.png" alt="img"></p><p>2、出现如下界面时，需要将信息填写完整。需要注意的是，前面三个选项可以任意填写，但是最后一个选项<code>请求是</code>必须选择<code>存储到磁盘</code>。点击<code>继续</code>后，可将证书存储到桌面，此时桌面可看见<code>CertificateSigningRequest.certSigningRequest</code>的文件。<br><img src="/2018/06/07/iOS开发之上线AppStore流程/2-02.png" alt="img"></p><p>3、回到苹果个人开发者网站上，点击<code>Provisioning Profiles</code>下<code>Distribution</code>，结果如下：<br><img src="/2018/06/07/iOS开发之上线AppStore流程/2-03.png" alt="img"></p><p>4、点击上图<code>+</code>按钮，出现如下界面，需要进行发布证书类型的选择，这里直接选择<code>App Store</code>，意味着我们需要申请的是AppStore发布证书，然后点击<code>Continue</code><br><img src="/2018/06/07/iOS开发之上线AppStore流程/2-04.png" alt="img"></p><p>5、接下来需要进行bundleID的绑定，此处应与第一部分中的第三小步中创建的bunldeid保持一致。(此处因示例原因，未保持一致)<br><img src="/2018/06/07/iOS开发之上线AppStore流程/2-05.png" alt="img"></p><p>6、点击上图中<code>Continue</code>后，出现如下界面，进行签名证书的选择<br><img src="/2018/06/07/iOS开发之上线AppStore流程/2-0601.png" alt="img"></p><p>需要注意的是：<br>此步骤可能出现另外一种情况，可能不存在选项，需要创建签名证书，此时这需要用到第1、2步中说创建的<code>CertificateSigningRequest</code>证书了。<br><img src="/2018/06/07/iOS开发之上线AppStore流程/2-0602.png" alt="img"></p><p>7、接下来，添加证书生成后的文件名称。<br><img src="/2018/06/07/iOS开发之上线AppStore流程/2-07.png" alt="img"></p><p>8、点击继续后即可进入下一个界面，点击<code>Download</code>，完成证书下载。<br><img src="/2018/06/07/iOS开发之上线AppStore流程/2-08.png" alt="img"></p><p>9、最后进入下载文件夹，找到刚刚生成的发布证书，并双击，将证书加入<code>钥匙串访问</code>中。<br><img src="/2018/06/07/iOS开发之上线AppStore流程/2-09.png" alt="img"></p><h3 id="三、提交审核"><a href="#三、提交审核" class="headerlink" title="三、提交审核"></a>三、提交审核</h3><p>终于来到了最后的提交审核阶段阶段。其中为了更完整的完整的描述此部分的操作详情，将操作分为三个阶段：</p><ul><li>在App Store Contect上先创建应用，必将应用信息填写完整；</li><li>完成工程项目的打包任务，并选择上传至AppStore平台；</li><li>将上传的iPa包与创建的应用进行绑定，并提交审核。</li></ul><h5 id="1、在App-Store-Connect上先创建应用，必将应用信息填写完整"><a href="#1、在App-Store-Connect上先创建应用，必将应用信息填写完整" class="headerlink" title="1、在App Store Connect上先创建应用，必将应用信息填写完整"></a>1、在App Store Connect上先创建应用，必将应用信息填写完整</h5><p>(1)开始创建应用<br><img src="/2018/06/07/iOS开发之上线AppStore流程/3-0101.png" alt="img"><br><img src="/2018/06/07/iOS开发之上线AppStore流程/3-0102.png" alt="img"></p><p>(2)填写应用名称，选择目标bundleID<br><img src="/2018/06/07/iOS开发之上线AppStore流程/3-02.png" alt="img"></p><p>(3)填写应用信息<br><img src="/2018/06/07/iOS开发之上线AppStore流程/3-03.png" alt="img"></p><p>(4)更新app价格与销售范围<br><img src="/2018/06/07/iOS开发之上线AppStore流程/3-04.png" alt="img"></p><p>(5)在准备提交选项内继续完善信息填写<br><img src="/2018/06/07/iOS开发之上线AppStore流程/3-05.png" alt="img"></p><h5 id="2、完成工程项目的打包任务，并选择上传至AppStore平台"><a href="#2、完成工程项目的打包任务，并选择上传至AppStore平台" class="headerlink" title="2、完成工程项目的打包任务，并选择上传至AppStore平台"></a>2、完成工程项目的打包任务，并选择上传至AppStore平台</h5><p>(1)打开Xcode，然后选择账号，开始进行Arachive，操作步骤如下<br><img src="/2018/06/07/iOS开发之上线AppStore流程/3-06.png" alt="img"><br><img src="/2018/06/07/iOS开发之上线AppStore流程/3-07.png" alt="img"></p><p>(2)接下来，进行上传ipa的操作，如下所示<br><img src="/2018/06/07/iOS开发之上线AppStore流程/3-08.png" alt="img"><br><img src="/2018/06/07/iOS开发之上线AppStore流程/3-09.png" alt="img"><br><img src="/2018/06/07/iOS开发之上线AppStore流程/3-10.png" alt="img"><br><img src="/2018/06/07/iOS开发之上线AppStore流程/3-11.png" alt="img"><br><img src="/2018/06/07/iOS开发之上线AppStore流程/3-12.png" alt="img"></p><hr><p>需要注意的是：</p><p>一般在进行这一步时，苹果会进行ipa的初步检测，包括权限控制、icon、luanch图片使用的合法性!</p><hr><p>当上传没有问题后，最后会出现如下结果!<br><img src="/2018/06/07/iOS开发之上线AppStore流程/3-13.png" alt="img"></p><p>至此为止，完成ipa上传流程!!!</p><h5 id="3、将上传的iPa包与创建的应用进行绑定，并提交审核"><a href="#3、将上传的iPa包与创建的应用进行绑定，并提交审核" class="headerlink" title="3、将上传的iPa包与创建的应用进行绑定，并提交审核"></a>3、将上传的iPa包与创建的应用进行绑定，并提交审核</h5><p>(1)打开App Store Contect，在<code>准备提交</code>选项中，找到<code>构建版本</code>，选择刚刚上传的版本记录<br><img src="/2018/06/07/iOS开发之上线AppStore流程/3-14.png" alt="img"><br><img src="/2018/06/07/iOS开发之上线AppStore流程/3-15.png" alt="img"></p><p>(2)点击<code>存储</code>，然后完成接下来的提交流程<br><img src="/2018/06/07/iOS开发之上线AppStore流程/3-16.png" alt="img"><br><img src="/2018/06/07/iOS开发之上线AppStore流程/3-17.png" alt="img"><br>点击上图中<code>提交</code>按钮，完成提交流程</p><p>(3)完成提交流程后，会自动跳转如下界面，至此已完成整个iOS上架打包流程<br><img src="/2018/06/07/iOS开发之上线AppStore流程/3-18.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> AppStore </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac上搭建Hexo的Github个人博客</title>
      <link href="/2016/03/21/Mac%E4%B8%8A%E6%90%AD%E5%BB%BAHexo%E7%9A%84Github%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2016/03/21/Mac%E4%B8%8A%E6%90%AD%E5%BB%BAHexo%E7%9A%84Github%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>作为一个NB的程序员，必须要有一个属于自己的blog。<br>市面上大多数人常有的blog网站有<a href="https://bbs.csdn.net/forums/ios" target="_blank" rel="noopener"><code>CSDN</code></a>、<a href="https://juejin.im/welcome/ios" target="_blank" rel="noopener"><code>掘金</code></a>、<a href="https://juejin.im/welcome/ios" target="_blank" rel="noopener"><code>我是开发者</code></a>、<a href="https://www.oschina.net/ios/codingList" target="_blank" rel="noopener"><code>oschina</code></a>、<a href="http://www.cocoachina.com/" target="_blank" rel="noopener"><code>cocoachina</code></a>、<a href="https://www.jianshu.com/" target="_blank" rel="noopener"><code>简书</code></a>。</p><h3 id="一、Node、npm、git环境安装"><a href="#一、Node、npm、git环境安装" class="headerlink" title="一、Node、npm、git环境安装"></a>一、Node、npm、git环境安装</h3><p>因为大多数程序员Mac电脑都支持或已经具备基本。本教程不做Nodejs、git环境的安装，如未安装，请自行百度。仅做简单的验证操作：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ <span class="keyword">node</span> <span class="title">-v</span></span><br><span class="line">v10.<span class="number">8.0</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ <span class="selector-tag">npm</span> <span class="selector-tag">-v</span></span><br><span class="line">6<span class="selector-class">.2</span><span class="selector-class">.0</span></span><br></pre></td></tr></table></figure><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ git --version</span><br><span class="line">git version <span class="number">2.17</span><span class="number">.2</span> (Apple Git<span class="number">-113</span>)</span><br></pre></td></tr></table></figure><h3 id="二、Hexo配置"><a href="#二、Hexo配置" class="headerlink" title="二、Hexo配置"></a>二、Hexo配置</h3><p>关于Hexo：<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">hexo官网</a></p><p>安装部署命令：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install </span>hexo-cli -g</span><br><span class="line">hexo init <span class="keyword">blog</span></span><br><span class="line"><span class="keyword">cd </span><span class="keyword">blog</span></span><br><span class="line"><span class="keyword">npm </span><span class="keyword">install</span></span><br><span class="line"><span class="keyword">hexo </span>server</span><br></pre></td></tr></table></figure><p>安装完成后如何新建Blog？</p><h5 id="1、新建文件夹MyGithubBlog，即项目名，用于放资源"><a href="#1、新建文件夹MyGithubBlog，即项目名，用于放资源" class="headerlink" title="1、新建文件夹MyGithubBlog，即项目名，用于放资源"></a>1、新建文件夹<code>MyGithubBlog</code>，即项目名，用于放资源</h5><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyProject gi<span class="variable">t:</span>(master) ✗ <span class="built_in">mkdir</span> MyGithubBlog</span><br></pre></td></tr></table></figure><h5 id="2、进入文件夹中，并进行初始化工作"><a href="#2、进入文件夹中，并进行初始化工作" class="headerlink" title="2、进入文件夹中，并进行初始化工作"></a>2、进入文件夹中，并进行初始化工作</h5><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  MyProject gi<span class="variable">t:</span>(master) ✗ <span class="keyword">cd</span> MyGithubBlog </span><br><span class="line">➜  MyGithubBlog gi<span class="variable">t:</span>(master) ✗ hexo init</span><br></pre></td></tr></table></figure><p>进度如下：<br><img src="/2016/03/21/Mac上搭建Hexo的Github个人博客/001.jpg" alt></p><h5 id="3、基础插件配置"><a href="#3、基础插件配置" class="headerlink" title="3、基础插件配置"></a>3、基础插件配置</h5><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">✗ hexo <span class="keyword">install</span></span><br></pre></td></tr></table></figure><h5 id="4、开始本地服务"><a href="#4、开始本地服务" class="headerlink" title="4、开始本地服务"></a>4、开始本地服务</h5><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">➜  MyGithubBlog <span class="string">git:</span>(master) ✗ hexo g      </span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Files loaded <span class="keyword">in</span> <span class="number">134</span> ms</span><br><span class="line">INFO  <span class="string">Generated:</span> index.html</span><br><span class="line">INFO  <span class="string">Generated:</span> archives/index.html</span><br><span class="line">INFO  <span class="string">Generated:</span> <span class="number">2019</span><span class="regexp">/03/</span><span class="number">21</span><span class="regexp">/hello-world/</span>index.html</span><br><span class="line">INFO  <span class="string">Generated:</span> archives<span class="regexp">/2019/</span>index.html</span><br><span class="line">INFO  <span class="string">Generated:</span> archives<span class="regexp">/2019/</span><span class="number">03</span>/index.html</span><br><span class="line">INFO  <span class="number">5</span> files generated <span class="keyword">in</span> <span class="number">195</span> ms</span><br><span class="line">➜  MyGithubBlog <span class="string">git:</span>(master) ✗ hexo s</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at <span class="string">http:</span><span class="comment">//localhost:4000 . Press Ctrl+C to stop.</span></span><br></pre></td></tr></table></figure><h5 id="5、访问http-localhost-4000，可以出现如下页面"><a href="#5、访问http-localhost-4000，可以出现如下页面" class="headerlink" title="5、访问http://localhost:4000，可以出现如下页面"></a>5、访问<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a>，可以出现如下页面</h5><p><img src="/2016/03/21/Mac上搭建Hexo的Github个人博客/002.jpg" alt></p><h3 id="三、使用github-pages"><a href="#三、使用github-pages" class="headerlink" title="三、使用github pages"></a>三、使用github pages</h3><p>github pages是给开发者建立一个私人页面，免费且没有空间流量限制。每个github账号都可以创建一个github pages项目。</p><h5 id="1、创建github-pages项目"><a href="#1、创建github-pages项目" class="headerlink" title="1、创建github pages项目"></a>1、创建github pages项目</h5><p>在github上新建一个项目，项目的名称必须是（你的用户名.github.io)才行</p><p><img src="/2016/03/21/Mac上搭建Hexo的Github个人博客/003.jpg" alt></p><h5 id="2、配置git信息-方便hexo和github通过ssh通信"><a href="#2、配置git信息-方便hexo和github通过ssh通信" class="headerlink" title="2、配置git信息(方便hexo和github通过ssh通信)"></a>2、配置git信息(方便hexo和github通过ssh通信)</h5><p>如何配置，公司使用过gitlab或常用Coding的童鞋应该知道，不再废话，属于基本操作。</p><h3 id="四、配置Deployment"><a href="#四、配置Deployment" class="headerlink" title="四、配置Deployment"></a>四、配置Deployment</h3><p>在MyGithubBlog项目根目录下里找到_config.yml文件，找到Deployment，然后按照如下修改：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># Deployment</span></span><br><span class="line"><span class="meta">## Docs: https:<span class="comment">//hexo.io/docs/deployment.html</span></span></span><br><span class="line"><span class="symbol">deploy:</span></span><br><span class="line"><span class="symbol">  type:</span> git </span><br><span class="line"><span class="symbol">  repo:</span> git@github.com:<span class="number">1019459067</span>/<span class="number">1019459067.</span>github.io.git</span><br><span class="line"><span class="symbol">  branch:</span> master</span><br></pre></td></tr></table></figure><h3 id="五、安装-hexo-deployer-git自动部署发布工具"><a href="#五、安装-hexo-deployer-git自动部署发布工具" class="headerlink" title="五、安装 hexo-deployer-git自动部署发布工具"></a>五、安装 hexo-deployer-git自动部署发布工具</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-deployer-git <span class="comment">--save</span></span><br></pre></td></tr></table></figure><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> audit fix</span><br></pre></td></tr></table></figure><h3 id="六、生成静态文件部署到github"><a href="#六、生成静态文件部署到github" class="headerlink" title="六、生成静态文件部署到github"></a>六、生成静态文件部署到github</h3><p>通过命令hexo clean &amp;&amp; hexo g &amp;&amp; hexo d，发布到github</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  MyGithubBlog git:(<span class="literal">master</span>) ✗ hexo clean</span><br></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  MyGithubBlog git:(<span class="literal">master</span>) ✗ hexo g</span><br></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  MyGithubBlog git:(<span class="literal">master</span>) ✗ hexo d</span><br></pre></td></tr></table></figure><p>通过链接就可以进行访问：<a href="https://1019459067.github.io/" target="_blank" rel="noopener">https://1019459067.github.io</a></p><h3 id="七、更改模板，发布博客"><a href="#七、更改模板，发布博客" class="headerlink" title="七、更改模板，发布博客"></a>七、更改模板，发布博客</h3><p><a href="http://theme-next.iissnan.com" target="_blank" rel="noopener">next主题</a></p><p><a href="https://hexo.io/zh-cn/docs/writing" target="_blank" rel="noopener">hexo写作教程</a></p><h3 id="八、Hexo中添加本地图片"><a href="#八、Hexo中添加本地图片" class="headerlink" title="八、Hexo中添加本地图片"></a>八、Hexo中添加本地图片</h3><p>1、把主页配置文件<code>_config.yml</code>里的<code>post_asset_folder:</code>这个选项设置为<code>true</code></p><p>2、在你的hexo目录下执行这样一句话<code>npm install hexo-asset-image --save</code>，这是下载安装一个可以上传本地图片的插件，来自dalao：dalao的git</p><p>3、等待一小段时间后，再运行<code>hexo n &quot;xxxx&quot;</code>来生成md博文时，<code>/source/_posts</code>文件夹内除了xxxx.md文件还有一个同名的文件夹</p><p>4、最后在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">你想输入的替代文字</span>](<span class="link">xxxx/图片名.jpg</span>)</span><br></pre></td></tr></table></figure><p>注意： xxxx是这个md文件的名字，也是同名文件夹的名字。只需要有文件夹名字即可，不需要有什么绝对路径。你想引入的图片就只需要放入xxxx这个文件夹内就好了，很像引用相对路径。</p><p>5、最后检查一下，<code>hexo g</code>生成页面后，进入<code>public\2019\03\21\index.html</code>文件中查看相关字段，可以发现，html标签内的语句是<code>&lt;img src=&quot;2017/02/26/xxxx/图片名.jpg&quot;&gt;</code>，而不是<code>&lt;img src=&quot;xxxx/图片名.jpg&gt;</code>。这很重要，关乎你的网页是否可以真正加载你想插入的图片。</p><h3 id="九、为hexo和next增加站内搜索功能"><a href="#九、为hexo和next增加站内搜索功能" class="headerlink" title="九、为hexo和next增加站内搜索功能"></a>九、为hexo和next增加站内搜索功能</h3><h5 id="1、安装插件"><a href="#1、安装插件" class="headerlink" title="1、安装插件"></a>1、安装插件</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-generator-<span class="keyword">search</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-generator-searchdb</span><br></pre></td></tr></table></figure><h5 id="2、修改hexo配置"><a href="#2、修改hexo配置" class="headerlink" title="2、修改hexo配置"></a>2、修改hexo配置</h5><p>在你的hexo目录下的_config.yml中增加如下配置：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">search:</span></span><br><span class="line"><span class="symbol">  path:</span> search.xml</span><br><span class="line"><span class="symbol">  field:</span> post</span><br><span class="line"><span class="symbol">  format:</span> html</span><br><span class="line"><span class="symbol">  limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure><p>配置上之后，其实搜索已经配置完成了，但现在我们还看不到搜索的入口，接下来我们需要在next的主体上进行配置</p><h5 id="3、配置next中的搜索入口"><a href="#3、配置next中的搜索入口" class="headerlink" title="3、配置next中的搜索入口"></a>3、配置next中的搜索入口</h5><p>打开themes\next_config.yml，打开local search:</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">Local</span> <span class="keyword">search</span></span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  # <span class="keyword">if</span> auto, trigger <span class="keyword">search</span> <span class="keyword">by</span> changing <span class="keyword">input</span></span><br><span class="line">  # <span class="keyword">if</span> manual, trigger <span class="keyword">search</span> <span class="keyword">by</span> pressing enter key or <span class="keyword">search</span> button</span><br><span class="line">  trigger: auto</span><br><span class="line">  # show top <span class="keyword">n</span> results per article, show all results <span class="keyword">by</span> setting to -1</span><br><span class="line">  top_n_per_article: 1</span><br></pre></td></tr></table></figure><h5 id="4、接下来就重新运行就可以看到效果。"><a href="#4、接下来就重新运行就可以看到效果。" class="headerlink" title="4、接下来就重新运行就可以看到效果。"></a>4、接下来就重新运行就可以看到效果。</h5><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>hexo s</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
            <tag> Mac </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
